<div align="center">
  <img height="60" src="https://img.icons8.com/color/344/javascript.png">
  <h1>Pyetje Javascript</h1>

---

Pyetjet tÃ« cilat mund tÃ« kenÃ« mÃ« shumÃ« se njÃ« pÃ«rgjigje tÃ« saktÃ« postohen nÃ« **storie** nÃ« kÃ«tÃ« [Instagram](https://www.instagram.com/theavocoder), tÃ« cilat do tÃ« postohen edhe kÃ«tu! PÃ«rditÃ«simi i fundit: 12 Qershor

Nga konceptet bazike tek ato tÃ« avancuara: testo se sa mirÃ« e njeh JavaScript-in, freskoni sado pak njohuritÃ« e juaja ose edhe pÃ«rgatitu pÃ«r intervisten tuaj tÃ« ardhshme! ğŸ’ª ğŸš€! PÃ«rgjigjet gjenden nÃ« **seksionet e mbyllura** pÃ«rfundi pyetjeve, thjesht kliko mbi to pÃ«r tÃ« hapur seksionin e pÃ«rgjigjeve. Ã‹shtÃ« vetÃ«m pÃ«r argÃ«tim, paÃ§ fat! â¤ï¸

Mos hezitoni tÃ« mÃ« kontaktoni! ğŸ˜Š
<a href="https://www.instagram.com/theavocoder">Instagram</a> || <a href="https://www.twitter.com/lydiahallie">Twitter</a> || <a href="https://www.linkedin.com/in/lydia-hallie">LinkedIn</a> || <a href="https://www.lydiahallie.dev">Blog</a>
</div>

| Ndjehuni tÃ« lirÃ« tÃ« i pÃ«rdorni nÃ« projektet e juaja |ğŸ˜ƒ  Do tÃ« e vlerÃ«soja shumÃ« referencimin tuaj nÃ« ketÃ« repositori, unÃ« i krijoj pyetjet dhe poashtu edhe pÃ«rgjigjet (lol) dhe komuniteti me ndihmon shumÃ« tÃ« e pÃ«rmirÃ«soj dhe tÃ« mirÃ«mbajÃ«! ğŸ’ªğŸ¼ Faleminderit!

---

<details><summary><b> See 20 Available Translations ğŸ‡¸ğŸ‡¦ğŸ‡ªğŸ‡¬ğŸ‡§ğŸ‡¦ğŸ‡©ğŸ‡ªğŸ‡ªğŸ‡¸ğŸ‡«ğŸ‡·ğŸ‡®ğŸ‡©ğŸ‡¯ğŸ‡µğŸ‡°ğŸ‡·ğŸ‡³ğŸ‡±ğŸ‡§ğŸ‡·ğŸ‡·ğŸ‡ºğŸ‡¹ğŸ‡­ğŸ‡¹ğŸ‡·ğŸ‡ºğŸ‡¦ğŸ‡»ğŸ‡³ğŸ‡¨ğŸ‡³ğŸ‡¹ğŸ‡¼ğŸ‡½ğŸ‡°</b></summary>
<p>

- [ğŸ‡¸ğŸ‡¦ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©](../ar-AR/README_AR.md)
- [ğŸ‡ªğŸ‡¬ Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø§Ù…ÙŠØ©](../ar-EG/README_ar-EG.md)
- [ğŸ‡§ğŸ‡¦ Bosanski](../bs-BS/README-bs_BS.md)
- [ğŸ‡©ğŸ‡ª Deutsch](../de-DE/README.md)
- [ğŸ‡ªğŸ‡¸ EspaÃ±ol](../es-ES/README-ES.md)
- [ğŸ‡«ğŸ‡· FranÃ§ais](../fr-FR/README_fr-FR.md)
- [ğŸ‡®ğŸ‡© Indonesia](../id-ID/README.md)
- [ğŸ‡®ğŸ‡¹ Italiano](../it-IT/README.md)
- [ğŸ‡¯ğŸ‡µ æ—¥æœ¬èª](../ja-JA/README-ja_JA.md)
- [ğŸ‡°ğŸ‡· í•œêµ­ì–´](../ko-KR/README-ko_KR.md)
- [ğŸ‡³ğŸ‡± Nederlands](../nl-NL/README.md)
- [ğŸ‡µğŸ‡± Polski](../pl-PL/README.md)
- [ğŸ‡§ğŸ‡· PortuguÃªs Brasil](../pt-BR/README_pt_BR.md)
- [ğŸ‡·o RomÃ¢nÄƒ](../ro-RO/README.ro.md)
- [ğŸ‡·ğŸ‡º Ğ ÑƒÑÑĞºĞ¸Ğ¹](../ru-RU/README.md)
- [ğŸ‡½ğŸ‡° Shqip](./sq-KS/README_sq_KS.md)
- [ğŸ‡¹ğŸ‡­ à¹„à¸—à¸¢](../th-TH/README-th_TH.md)
- [ğŸ‡¹ğŸ‡· TÃ¼rkÃ§e](../tr-TR/README-tr_TR.md)
- [ğŸ‡ºğŸ‡¦ Ğ£ĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°](../uk-UA/README.md)
- [ğŸ‡»ğŸ‡³ Tiáº¿ng Viá»‡t](../vi-VI/README-vi.md)
- [ğŸ‡¨ğŸ‡³ ç®€ä½“ä¸­æ–‡](../zh-CN/README-zh_CN.md)
- [ğŸ‡¹ğŸ‡¼ ç¹é«”ä¸­æ–‡](../zh-TW/README_zh-TW.md)

</p>
</details>

---

###### 1.  Cila Ã«shtÃ« vlera e saj?

```javascript
function sayHi() {
  console.log(name);
  console.log(age);
  var name = 'Lydia';
  let age = 21;
}

sayHi();
```

- A: `Lydia` dhe `undefined`
- B: `Lydia` dhe `ReferenceError`
- C: `ReferenceError` dhe `21`
- D: `undefined` dhe `ReferenceError`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: D

Brenda funksionit, fillimisht deklarojmÃ« variablÃ«n `name` me fjalÃ«n kyÃ§e `var`. Kjo do tÃ« thotÃ« se variabla ngrihet - hoistohet (hapÃ«sira e memories caktohet gjatÃ« fazÃ«s sÃ« krijimit) me vlerÃ«n e paracaktuar `undefined`, deri sa tÃ« arrijmÃ« nÃ« rreshtin ku e definojmÃ« variablÃ«n. Nuk kemi definuar ende variablÃ«n nÃ« rreshtin ku pÃ«rpiqemi tÃ« shfaqim variablÃ«n `name`, kÃ«shtu qÃ« ajo ende mban vlerÃ«n `undefined`.

Variablat me fjalÃ«n kyÃ§e `let` (dhe `const`) hoistohen, por ndryshe nga `var`, nuk inicializohen. Ato nuk janÃ« tÃ« qasshme para rreshtit ku i deklarojmÃ« (inicializojmÃ«) ato. Kjo quhet "zona e vdekur temporale". Kur pÃ«rpiqemi tÃ« iu qasemi variablave para se ato tÃ« jenÃ« tÃ« deklaruara, JavaScript hedh njÃ« `ReferenceError`.

</p>
</details>

---

###### 2.  Cila Ã«shtÃ« vlera e saj?

```javascript
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 1);
}

for (let i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 1);
}
```

- A: `0 1 2` dhe `0 1 2`
- B: `0 1 2` dhe `3 3 3`
- C: `3 3 3` dhe `0 1 2`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: C

PÃ«r shkak tÃ« ***event queque*** nÃ« JavaScript, funksioni callback `setTimeout` thirret pas ekzekutimit tÃ« unazÃ«s. Pasi qÃ« variabla `i` nÃ« iterimin e parÃ« u deklarua duke pÃ«rdorur fjalÃ«n kyÃ§e `var`, kjo vlerÃ« ishte globale. GjatÃ« unazÃ«s, ne rritÃ«m vlerÃ«n e `i` me `1` Ã§do herÃ«, duke pÃ«rdorur operatorin unar `++`. Deri nÃ« kohÃ«n qÃ« funksioni callback `setTimeout` u thirr, `i` ishte e barabartÃ« me `3` nÃ« unazÃ«n e parÃ«.

NÃ« unazÃ«n e dytÃ«, variabla `i` u deklarua duke pÃ«rdorur fjalÃ«n kyÃ§e `let`: variablat e deklaruara me fjalÃ«n kyÃ§e `let` (dhe `const`) janÃ« tÃ« qasshme nÃ« bllok (njÃ« bllok Ã«shtÃ« Ã§do gjÃ« mes `{ }`). GjatÃ« Ã§do iteracioni, `i` do tÃ« ketÃ« njÃ« vlerÃ« tÃ« re, dhe Ã§do vlerÃ« Ã«shtÃ« e qasshme brenda unazÃ«s.

</p>
</details>

---

###### 3. Cila Ã«shtÃ« vlera e saj?

```javascript
const shape = {
  radius: 10,
  diameter() {
    return this.radius * 2;
  },
  perimeter: () => 2 * Math.PI * this.radius,
};

console.log(shape.diameter());
console.log(shape.perimeter());
```

- A: `20` and `62.83185307179586`
- B: `20` and `NaN`
- C: `20` and `63`
- D: `NaN` and `63`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: B

Vini re se vlera e `diameter` Ã«shtÃ« njÃ« funksion i zakonshÃ«m, ndÃ«rsa vlera e `perimeter` Ã«shtÃ« njÃ« funksion shigjete (arrow function).

NÃ« funksionet shigjeta, fjala kyÃ§e `this` referohet nÃ« qasjen nÃ« rrethinÃ«n aktuale pÃ«rreth saj, ndryshe nga funksionet e zakonshme! Kjo do tÃ« thotÃ« se kur ne e thÃ«rrasim `perimeter`, ajo nuk referohet tek objekti shape, por tek rrethina e saj (pÃ«r shembull "window").

`radius` nuk ka ndonjÃ« vlerÃ« tÃ« caktuar nÃ« atÃ« objekt, prandaj do tÃ« kemi si rezultat `NaN`.

</p>
</details>

---

###### 4. Cila Ã«shtÃ« vlera e saj?

```javascript
+true;
!'Lydia';
```

- A: `1` and `false`
- B: `false` and `NaN`
- C: `false` and `false`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: A

Operatori unar `+` provon tÃ« e konvertojÃ« operandin nÃ« numÃ«r. `true` Ã«shtÃ« `1`, dhe `false` Ã«shtÃ« `0`.

Vargu i karaktereve (stringu) `'Lydia'` konsiderohet si vlerÃ« `true`. Ã‡farÃ« ne realisht po pyesim Ã«shtÃ« "a Ã«shtÃ« kjo vlerÃ« e vÃ«rtetÃ« e pavÃ«rtetÃ«?". Kjo do tÃ« kthejÃ« vlerÃ«n `false`.

</p>
</details>

---

###### 5. Cila pÃ«rgjigje Ã«shtÃ« e saktÃ«?

```javascript
const bird = {
  size: 'small',
};

const mouse = {
  name: 'Mickey',
  small: true,
};
```

- A: `mouse.bird.size` nuk Ã«shtÃ« sintaksÃ« valide
- B: `mouse[bird.size]` nuk Ã«shtÃ« sintaksÃ« valide
- C: `mouse[bird["size"]]` nuk Ã«shtÃ« sintaksÃ« valide
- D: TÃ« gjitha sintaksat janÃ« valide

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: A

NÃ« JavaScript, tÃ« gjithÃ« Ã§elÃ«sat (keys) e objektit janÃ« stringje (pÃ«rveÃ§ nÃ«se Ã«shtÃ« Symbol). Edhe nÃ«se nuk i _shkruajmÃ«_ si stringje, ato gjithmonÃ« konvertohen nÃ« stringje nÃ« prapavijÃ«.

JavaScript interpreton deklarimet. Kur pÃ«rdorim notacionin e kllapave, ai shikon kllapÃ«n e parÃ« hapÃ«se `[` dhe vazhdon derisa tÃ« gjejÃ« kllapÃ«n mbyllÃ«se `]`. VetÃ«m atÃ«herÃ« do tÃ« vlerÃ«sohet deklarata (kthehet vlera e caktuar pÃ«r atÃ« deklarim).

`mouse[bird.size]`: Fillimisht gjendet vlera e `bird.size`, e cila Ã«shtÃ« `"small"`. `mouse["small"]` kthen `true`

MegjithatÃ«, me notacionin pikÃ«, kjo nuk ndodh. `mouse` nuk ka njÃ« Ã§elÃ«s tÃ« quajtur `bird`, qÃ« do tÃ« thotÃ« se `mouse.bird` Ã«shtÃ« `undefined`. Pastaj, ne kÃ«rkojmÃ« "size" duke pÃ«rdorur notacionin pikÃ«: "mouse.bird.size". MeqenÃ«se `mouse.bird` Ã«shtÃ« `undefined`, ne nÃ« fakt po pyesim 'undefined.size'. Kjo nuk Ã«shtÃ« valide dhe do tÃ« marrim njÃ« gabim tÃ« ngjashÃ«m me `Cannot read property "size" of undefined`.

</p>
</details>

---

###### 6. Cila Ã«shtÃ« vlera e saj?

```javascript
let c = { greeting: 'Hey!' };
let d;

d = c;
c.greeting = 'Hello';
console.log(d.greeting);
```

- A: `Hello`
- B: `Hey!`
- C: `undefined`
- D: `ReferenceError`
- E: `TypeError`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: A

NÃ« JavaScript, tÃ« gjitha objektet ndÃ«rveprojnÃ« me _referencÃ«_ kur i vendosin me vlera tÃ« barabarta me njÃ«ri-tjetrin.

Fillimisht, variabla `c` mbanÃ« vlerÃ«n pÃ«r njÃ« objekt. MÃ« vonÃ«, ne e caktojmÃ« `d` me tÃ« njejtÃ«n reference tÃ« cilÃ«n `c` ka tek objekti.

<img src="https://i.imgur.com/ko5k0fs.png" width="200">

Kur e ndryshoni njÃ« objekt, i ndryshoni tÃ« gjitha objektet.

</p>
</details>

---

###### 7. Cila Ã«shtÃ« vlera e saj?

```javascript
let a = 3;
let b = new Number(3);
let c = 3;

console.log(a == b);
console.log(a === b);
console.log(b === c);
```

- A: `true` `false` `true`
- B: `false` `false` `true`
- C: `true` `false` `false`
- D: `false` `true` `true`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: C

`new Number()` Ã«shtÃ« konstruktor i integruar (built-in function). Edhe pse duket si njÃ« numÃ«r, nuk Ã«shtÃ« nÃ« tÃ« vÃ«rtetÃ« njÃ« numÃ«r: ai ka njÃ« mori karakteristikash shtesÃ« dhe si rrjedhojÃ« Ã«shtÃ« njÃ« objekt.

Kur pÃ«rdorim operatorin `==` (operatorin i barazimit), ai kontrollon vetÃ«m nÃ«se ka tÃ« njÃ«jtÃ«n _vlerÃ«_. TÃ« dy kanÃ« vlerÃ«n `3`, kÃ«shtu qÃ« kthen `true`.

MegjithatÃ«, kur pÃ«rdorim operatorin `===` (operatori i barazisÃ« strikte), tÃ« dy vlerat dhe tipi i tyre duhet tÃ« jenÃ« tÃ« njÃ«jta. Nuk Ã«shtÃ«: `new Number()` nuk Ã«shtÃ« njÃ« numÃ«r, Ã«shtÃ« njÃ« __objekt__. TÃ« dy kthejnÃ« `false`.

</p>
</details>

---

###### 8. Cila Ã«shtÃ« vlera e saj?

```javascript
class Chameleon {
  static colorChange(newColor) {
    this.newColor = newColor;
    return this.newColor;
  }

  constructor({ newColor = 'green' } = {}) {
    this.newColor = newColor;
  }
}

const freddie = new Chameleon({ newColor: 'purple' });
console.log(freddie.colorChange('orange'));
```

- A: `orange`
- B: `purple`
- C: `green`
- D: `TypeError`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: D

Funksioni `colorChange` Ã«shtÃ« statik. Metodat statike janÃ« krijuar pÃ«r tÃ« "jetuar" vetÃ«m nÃ« konstruktorin nÃ« tÃ« cilin janÃ« krijuar dhe nuk mund t'i kalohen asnjÃ« fÃ«mije ose tÃ« thirren nÃ« instancat e klasÃ«s. MeqenÃ«se `freddie` Ã«shtÃ« njÃ« instancÃ« e klasÃ«s Chameleon, funksioni nuk mund tÃ« thirret. NÃ« kÃ«tÃ« rast do tÃ« kthehet `TypeError`.

</p>
</details>

---

###### 9. Cila Ã«shtÃ« vlera e saj?

```javascript
let greeting;
greetign = {}; // Typo - gabim drejtÃ«shkrimor!
console.log(greetign);
```

- A: `{}`
- B: `ReferenceError: greetign is not defined`
- C: `undefined`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: A

Do tÃ« printojÃ« objekt, sepse ne sapo krijuam njÃ« objekt bosh nÃ« objektin global! Kur e shkruajtÃ«m gabim `greeting` si `greetign`, interpretuesi i JS nÃ« fakt e pa kÃ«tÃ« si:

1. `global.greetign = {}` nÃ« Node.js
2. `window.greetign = {}`, `frames.greetign = {}` dhe `self.greetign` nÃ« shfletues (browser).
3. `self.greetign` nÃ« web workers.
4. `globalThis.greetign` nÃ« tÃ« gjitha mjediset.

PÃ«r tÃ« shmangur kÃ«tÃ«, ne mund tÃ« pÃ«rdorim `"use strict"`. Kjo siguron qÃ« ju tÃ« keni deklaruar njÃ« variabÃ«l pÃ«rpara se ta vendosni atÃ« tÃ« barabartÃ« (inicializoni ndonjÃ« variabÃ«l tjetÃ«r me vlerÃ«n e saj) me ndonjÃ« gjÃ«.

</p>
</details>

---

###### 10. Ã‡farÃ« do tÃ« ndodh kur e bÃ«jmÃ« kÃ«tÃ« veprim?

```javascript
function bark() {
  console.log('Woof!');
}

bark.animal = 'dog';
```

- A: AsgjÃ«, gjithÃ§ka Ã«shtÃ« nÃ« rregull!
- B: `SyntaxError`. Nuk mund tÃ« shtoni veti te njÃ« funksion nÃ« kÃ«tÃ« mÃ«nyrÃ«.
- C: `"Woof"` do tÃ« printohet.
- D: `ReferenceError`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: A

Kjo Ã«shtÃ« e mundshme nÃ« JavaScript, spese funksionet janÃ« objekte! (GjithÃ§ka, pÃ«rveÃ§ tipeve primitive janÃ« objekte)

NjÃ« funksion Ã«shtÃ« njÃ« lloj i veÃ§antÃ« objekti. Kodi qÃ« shkruani vetÃ« nuk Ã«shtÃ« funksioni aktual. Funksioni Ã«shtÃ« njÃ« objekt me veti. Kjo veti Ã«shtÃ« e pavokueshme.

</p>
</details>

---

###### 11. Cila Ã«shtÃ« vlera e saj?

```javascript
function Person(firstName, lastName) {
  this.firstName = firstName;
  this.lastName = lastName;
}

const member = new Person('Lydia', 'Hallie');
Person.getFullName = function() {
  return `${this.firstName} ${this.lastName}`;
};

console.log(member.getFullName());
```

- A: `TypeError`
- B: `SyntaxError`
- C: `Lydia Hallie`
- D: `undefined` `undefined`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: A

NÃ« JavaScript, funksionet janÃ« objekte dhe pÃ«r kÃ«tÃ« arsye metoda `getFullName` i shtohet vetÃ« objektit tÃ« funksionit tÃ« konstruktorit. PÃ«r kÃ«tÃ« arsye, ne mund tÃ« thÃ«rrasim `Person.getFullName()`, por `member.getFullName` do tÃ« kthejÃ« `TypeError`.

NÃ«se dÃ«shironi qÃ« njÃ« metodÃ« tÃ« jetÃ« e qasshme pÃ«r tÃ« gjitha instancat e objektit, duhet ta shtoni atÃ« nÃ« vetinÃ« e quajtur "prototype":

```js
Person.prototype.getFullName = function() {
  return `${this.firstName} ${this.lastName}`;
};
```

</p>
</details>

---

###### 12. Cila Ã«shtÃ« vlera e saj?

```javascript
function Person(firstName, lastName) {
  this.firstName = firstName;
  this.lastName = lastName;
}

const lydia = new Person('Lydia', 'Hallie');
const sarah = Person('Sarah', 'Smith');

console.log(lydia);
console.log(sarah);
```

- A: `Person {firstName: "Lydia", lastName: "Hallie"}` and `undefined`
- B: `Person {firstName: "Lydia", lastName: "Hallie"}` and `Person {firstName: "Sarah", lastName: "Smith"}`
- C: `Person {firstName: "Lydia", lastName: "Hallie"}` and `{}`
- D: `Person {firstName: "Lydia", lastName: "Hallie"}` and `ReferenceError`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: A

PÃ«r `sarah`, ne nuk pÃ«rdorÃ«m fjalÃ«n kyÃ§e `new`. Kur pÃ«rdorim `new`, `this` i referohet objektit tÃ« ri bosh qÃ« krijojmÃ«. MegjithatÃ«, nÃ«se nuk shtoni `new`, `this` i referohet **objektit global**!

E cekÃ«m se `this.firstName` Ã«shtÃ« `"Sarah"` dhe `this.lastName` Ã«shtÃ« `"Smith"`. Ã‡farÃ« bÃ«mÃ« realisht Ã«shtÃ« se ne e definuam `global.firstName = 'Sarah'` dhe `global.lastName = 'Smith'`. `sarah` vetÃ« mbetet `undefined`, pasi ne nuk kthejmÃ« ndonjÃ« vlerÃ« nga funksioni `Person`.

</p>
</details>

---

###### 13. Cilat janÃ« tri fazat e "event propagation"?

- A: Target > Capturing > Bubbling
- B: Bubbling > Target > Capturing
- C: Target > Bubbling > Capturing
- D: Capturing > Target > Bubbling

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: D

GjatÃ« fazÃ«s **capturing** (kapjes), eventi kalon nÃ«pÃ«r elementet paraardhÃ«se deri te elementi i synuar. MÃ« pas arrin nÃ« elementin **target** (e synuar) dhe fillon **bubbling**.

<img src="https://i.imgur.com/N18oRgd.png" width="200">

</p>
</details>

---

###### 14. TÃ« gjitha objektet kanÃ« prototipe.

- A: e vÃ«rtetÃ«
- B: e pavÃ«rtetÃ«

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: B

TÃ« gjitha objektet kanÃ« prototipe, me pÃ«rjashtim tÃ« **objektit bazÃ«**. Objekti bazÃ« Ã«shtÃ« objekti i krijuar nga pÃ«rdoruesi, ose njÃ« objekt qÃ« krijohet duke pÃ«rdorur fjalÃ«n kyÃ§e "new". Objekti bazÃ« ka qasje nÃ« disa metoda dhe veti, tÃ« tilla si `.toString`. Kjo Ã«shtÃ« arsyeja pse ju mund tÃ« pÃ«rdorni metoda tÃ« integruara tÃ« JavaScript! TÃ« gjitha kÃ«to metoda janÃ« tÃ« disponueshme nÃ« prototip. MegjithÃ«se JavaScript nuk mund ta gjejÃ« atÃ« drejtpÃ«rdrejt nÃ« objektin tuaj, ai zbret nÃ« zinxhirin e prototipit dhe e gjen atje, gjÃ« qÃ« e bÃ«n atÃ« tÃ« qasshÃ«m pÃ«r ju.

</p>
</details>

---

###### 15. Cila Ã«shtÃ« vlera e saj?

```javascript
function sum(a, b) {
  return a + b;
}

sum(1, '2');
```

- A: `NaN`
- B: `TypeError`
- C: `"12"`
- D: `3`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: C

JavaScript Ã«shtÃ« gjuhÃ« e shkruar nÃ« mÃ«nyrÃ« dinamike __dynamically typed language__: ne nuk specifikojmÃ« se Ã§farÃ« tipe janÃ« variablat e caktuara. Vlerat mund tÃ« konvertohen automatikisht nÃ« njÃ« tip tjetÃ«r pa e ditur ju dhe ky proces quhet _implicit type coercion_ (shndÃ«rrimi i tipit nÃ« mÃ«nyrÃ« tÃ« nÃ«nkuptuar). __Coercion__ Ã«shtÃ« shndÃ«rrimi nga njÃ« tip nÃ« njÃ« tjetÃ«r.

NÃ« kÃ«tÃ« shembull, JavaScript konverton numrin `1` nÃ« string, nÃ« mÃ«nyrÃ« qÃ« pÃ«r funksionin tÃ« ketÃ« kuptim dhe tÃ« kthejÃ« njÃ« vlerÃ«. PÃ«rgjatÃ« mbledhjes tÃ« njÃ« tipi number (`1`) dhe njÃ« tipi string (`'2'`), numri trajtohet si string. Ne mund ti bashkojmÃ« stringjet si `"Hello" + "World"`, kÃ«shtu qÃ« ajo qÃ« po ndodh kÃ«tu Ã«shtÃ« `"1" + "2"` e cila kthen "12"`.

</p>
</details>

---

###### 16. Cila Ã«shtÃ« vlera e saj?

```javascript
let number = 0;
console.log(number++);
console.log(++number);
console.log(number);
```

- A: `1` `1` `2`
- B: `1` `2` `2`
- C: `0` `2` `2`
- D: `0` `1` `2`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: C

**postfiks** operatori unar `++`:

1. Kthen vlerÃ«n (kthen `0`)
2. Rrit vleren (numri tani Ã«shtÃ« `1`)

**prefiks** operatori unar `++`:

1. Rrit vlerÃ«n (numri tani Ã«shtÃ« `2`)
2. Kthen vlerÃ«n (kthen `2`)

Prandaj rezultati qÃ« kthehet Ã«shtÃ« `0 2 2`.

</p>
</details>

---

###### 17. Cila Ã«shtÃ« vlera e saj?

```javascript
function getPersonInfo(one, two, three) {
  console.log(one);
  console.log(two);
  console.log(three);
}

const person = 'Lydia';
const age = 21;

getPersonInfo`${person} is ${age} years old`;
```

- A: `"Lydia"` `21` `["", " is ", " years old"]`
- B: `["", " is ", " years old"]` `"Lydia"` `21`
- C: `"Lydia"` `["", " is ", " years old"]` `21`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: B

NÃ«se pÃ«rdorni literale tÃ« shabllonit (template literals) tÃ« etiketuar, vlera e argumentit tÃ« parÃ« Ã«shtÃ« gjithmonÃ« njÃ« array vlerash stringu. Argumentet e mbetura marrin vlerat e shprehjeve tÃ« vendosura nÃ« variablat e dhÃ«na!

</p>
</details>

---

###### 18. Cila Ã«shtÃ« vlera e saj?

```javascript
function checkAge(data) {
  if (data === { age: 18 }) {
    console.log('You are an adult!');
  } else if (data == { age: 18 }) {
    console.log('You are still an adult.');
  } else {
    console.log(`Hmm.. You don't have an age I guess`);
  }
}

checkAge({ age: 18 });
```

- A: `You are an adult!`
- B: `You are still an adult.`
- C: `Hmm.. You don't have an age I guess`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: C

Kur testojmÃ« barazinÃ«, primitivet krahasohen me _vlerÃ«n_ e tyre, ndÃ«rsa objektet krahasohen me _referencÃ«n_ e tyre. JavaScript kontrollon nÃ«se objektet kanÃ« njÃ« referencÃ« nÃ« tÃ« njÃ«jtin vend nÃ« memorie.

Dy objektet qÃ« po krahasojmÃ« nuk e kanÃ« kÃ«tÃ«: objekti qÃ« kemi vendosur si parametÃ«r i referohet njÃ« vendndodhjeje tÃ« ndryshme nÃ« memorie nga objekti qÃ« kemi pÃ«rdorur pÃ«r tÃ« kontrolluar barazinÃ«.

Kjo tregon pse tÃ« dyja: `{ age: 18 } === { age: 18 }` dhe `{ age: 18 } == { age: 18 }` kthen `false`.

</p>
</details>

---

###### 19. Cila Ã«shtÃ« vlera e saj?

```javascript
function getAge(...args) {
  console.log(typeof args);
}

getAge(21);
```

- A: `"number"`
- B: `"array"`
- C: `"object"`
- D: `"NaN"`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: C

Parametri "rest" (`...args`) na lejon tÃ« "mbledhim" tÃ« gjitha argumentet e mbetura nÃ« njÃ« array. NjÃ« array Ã«shtÃ« njÃ« objekt, kÃ«shtu qÃ« `typeof args` kthen `â€œobjektâ€`

</p>
</details>

---

###### 20. Cila Ã«shtÃ« vlera e saj?

```javascript
function getAge() {
  'use strict';
  age = 21;
  console.log(age);
}

getAge();
```

- A: `21`
- B: `undefined`
- C: `ReferenceError`
- D: `TypeError`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: C

Me `"use strict"`, mund tÃ« siguroheni se nuk do tÃ« deklaroni variabla globale pa qÃ«llim. Ne asnjÃ«herÃ« nuk e kemi deklaruar variablen `age`, dhe pasi ne e pÃ«rdorim `"use strict"`, do tÃ« na kthehet njÃ« error reference. NÃ« qoftesÃ« nuk pÃ«rdorim `"use strict"`, do tÃ« kishte funksionuar pasi vetia `age` do tÃ« ishte shtuar nÃ« objektin global.

</p>
</details>

---

###### 21. Sa do tÃ« jetÃ« vlera e `sum`?

```javascript
const sum = eval('10*10+5');
```

- A: `105`
- B: `"105"`
- C: `TypeError`
- D: `"10*10+5"`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: A

`eval` vlerÃ«son kodet qÃ« i pasohen si string. NÃ«se Ã«shtÃ« njÃ« shprehje, si nÃ« kÃ«tÃ« rast, ajo vlerÃ«son shprehjen. Shprehja Ã«shtÃ« `10 * 10 + 5`. Kjo kthen numrin '105'.

</p>
</details>

---

###### 22. Sa kohÃ« Ã«shtÃ« e qasshme cool_secret?

```javascript
sessionStorage.setItem('cool_secret', 123);
```

- A: PÃ«rgjithmonÃ«, e dhÃ«na nuk humb.
- B: Kur pÃ«rdoruesi mbyll dritaren.
- C: Kur pÃ«rdoruesi mbyll browser-in nÃ« tÃ«rÃ«si, jo vetÃ«m dritaren.
- D: Kur pÃ«rdoruesi ndal kompjuterin e tyre.

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: B

TÃ« dhÃ«nat e ruajtura nÃ« `sessionStorage` largohen pasi tÃ« mbyllet _dritarja_.

NÃ«se keni pÃ«rdorur 'localStorage', tÃ« dhÃ«nat do tÃ« kishin mbetur aty pÃ«rgjithmonÃ«, pÃ«rveÃ§ nÃ«se pÃ«r shembull thirret 'localStorage.clear()'.

</p>
</details>

---

###### 23. Cila Ã«shtÃ« vlera e saj?

```javascript
var num = 8;
var num = 10;

console.log(num);
```

- A: `8`
- B: `10`
- C: `SyntaxError`
- D: `ReferenceError`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: B

Me fjalÃ«n kyÃ§e `var`, mund tÃ« deklaroni shumÃ« variabla me tÃ« njÃ«jtin emÃ«r. MÃ« pas variabla do tÃ« mbajÃ« vlerÃ«n e fundit tÃ« inicializuar nÃ« tÃ«.

Ju nuk mund ta bÃ«ni kÃ«tÃ« me 'let' ose 'const' pasi ato kanÃ« qasje nÃ« bllok (block-scoped).

</p>
</details>

---

###### 24. Cila Ã«shtÃ« vlera e saj?

```javascript
const obj = { 1: 'a', 2: 'b', 3: 'c' };
const set = new Set([1, 2, 3, 4, 5]);

obj.hasOwnProperty('1');
obj.hasOwnProperty(1);
set.has('1');
set.has(1);
```

- A: `false` `true` `false` `true`
- B: `false` `true` `true` `true`
- C: `true` `true` `false` `true`
- D: `true` `true` `true` `true`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: C

TÃ« gjitha Ã§elÃ«sat e objektit (pÃ«rjashto Simbolet) janÃ« stringje nÃ« prapavijÃ«, edhe nÃ«se ju vetÃ« nuk e shkruani atÃ« si string. Kjo Ã«shtÃ« arsyeja pse `obj.hasOwnProperty('1')` gjithashtu kthen vlerÃ«n true.

Nuk funksionon nÃ« kÃ«tÃ« mÃ«nyrÃ« pÃ«r njÃ« "set". Nuk ka asnjÃ« `'1'` nÃ« set-in tonÃ«: `set.has('1')` kthen `false`. NÃ«se ka tipin numÃ«r `1`, `set.has(1)` kthen `true`.

</p>
</details>

---

###### 25. Cila Ã«shtÃ« vlera e saj?

```javascript
const obj = { a: 'one', b: 'two', a: 'three' };
console.log(obj);
```

- A: `{ a: "one", b: "two" }`
- B: `{ b: "two", a: "three" }`
- C: `{ a: "three", b: "two" }`
- D: `SyntaxError`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: C

NÃ«se keni dy Ã§elÃ«sa me tÃ« njÃ«jtin emÃ«r, Ã§elÃ«si do tÃ« zÃ«vendÃ«sohet. Do tÃ« jetÃ« ende nÃ« pozitÃ«n e parÃ«, por me vlerÃ«n e fundit tÃ« specifikuar.

</p>
</details>

---

###### 26. Konteksti global i ekzekutimit nÃ« JavaScript krijon dy gjÃ«ra pÃ«r ju: objektin global, dhe fjalÃ«n kyÃ§e "this".

- A: e vÃ«rtetÃ«
- B: e pavÃ«rtetÃ«
- C: varet

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: A

Konteksti bazÃ« i ekzekutimit Ã«shtÃ« konteksti global i ekzekutimit: Ã«shtÃ« ajo qÃ« Ã«shtÃ« e qasshme kudo nÃ« kodin tuaj.

</p>
</details>

---

###### 27. Cila Ã«shtÃ« vlera e saj?

```javascript
for (let i = 1; i < 5; i++) {
  if (i === 3) continue;
  console.log(i);
}
```

- A: `1` `2`
- B: `1` `2` `3`
- C: `1` `2` `4`
- D: `1` `3` `4`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: C

Deklarata `continue` kalon njÃ« iterim nÃ«se njÃ« kusht i caktuar kthen `true`.

</p>
</details>

---

###### 28. Cila Ã«shtÃ« vlera e saj?

```javascript
String.prototype.giveLydiaPizza = () => {
  return 'Just give Lydia pizza already!';
};

const name = 'Lydia';

console.log(name.giveLydiaPizza())
```

- A: `"Just give Lydia pizza already!"`
- B: `TypeError: not a function`
- C: `SyntaxError`
- D: `undefined`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: A

`String` Ã«shtÃ« njÃ« konstruktor i integruar, tÃ« cilit mund t'i shtojmÃ« veti. Sapo shtuam njÃ« metodÃ« nÃ« prototipin e saj. Stringjet primitive konvertohen automatikisht nÃ« njÃ« objekt string, tÃ« gjeneruara nga funksioni i prototipit tÃ« stringut. Pra, tÃ« gjitha vargjet (objektet e stringut) kanÃ« qasje nÃ« atÃ« metodÃ«!

</p>
</details>

---

###### 29. Cila Ã«shtÃ« vlera e saj?

```javascript
const a = {};
const b = { key: 'b' };
const c = { key: 'c' };

a[b] = 123;
a[c] = 456;

console.log(a[b]);
```

- A: `123`
- B: `456`
- C: `undefined`
- D: `ReferenceError`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: B

Ã‡elÃ«sat e objekteve konvertohen automatikisht nÃ« stringje. Ne po provojmÃ« tÃ« vendosim njÃ« objekt si Ã§elÃ«s pÃ«r objektin 'a', me vlerÃ«n '123'.

MegjithatÃ«, kur e pÃ«rdorim "stringify" nÃ« njÃ« objekt, ai bÃ«het `"[object Object]"`. Pra, ajo qÃ« po themi kÃ«tu, Ã«shtÃ« se `a["[object Object]"] = 123`. Pastaj, ne mund tÃ« provojmÃ« tÃ« bÃ«jmÃ« tÃ« njÃ«jtÃ«n gjÃ« pÃ«rsÃ«ri. `c` Ã«shtÃ« njÃ« objekt tjetÃ«r qÃ« ne po e "stringify" nÃ« mÃ«nyrÃ« implicite. Pra, atÃ«herÃ«, `a["[object Object]"] = 456`.

Pastaj ne e printojmÃ« `a[b]` e cila Ã«shtÃ« `a["[object Object]"]`. We sapo e vendosÃ«m `456` nÃ« tÃ«, prandaj edhe do tÃ« kthejÃ« `456`

</p>
</details>

---

###### 30. Cila Ã«shtÃ« vlera e saj?

```javascript
const foo = () => console.log('First');
const bar = () => setTimeout(() => console.log('Second'));
const baz = () => console.log('Third');

bar();
foo();
baz();
```

- A: `First` `Second` `Third`
- B: `First` `Third` `Second`
- C: `Second` `First` `Third`
- D: `Second` `Third` `First`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: B

Ne kemi njÃ« funksion "setTimeout" tÃ« cilin e thirrÃ«m sÃ« pari. MegjithatÃ«, ai u printua i fundit.

Kjo Ã«shtÃ« pÃ«r shkak se nÃ« browser-a, ne nuk kemi vetÃ«m "runtime" funksionalitet, ne gjithashtu kemi diÃ§ka qÃ« quhet `WebAPI`. `WebAPI` na jep funksionin `setTimeout` dhe poashtu pÃ«r shembull DOM.

Pasi _callback_ tÃ« vendoset nÃ« WebAPI, vetÃ« funksioni "setTimeout" (por jo callback!) del nga pirgu (stack).

<img src="https://i.imgur.com/X5wsHOg.png" width="200">

Tani `foo` thirret dhe `"First"` do tÃ« printohet.

<img src="https://i.imgur.com/Pvc0dGq.png" width="200">

`foo` del nga stack, dhe `baz` thirret. `"Third"` do tÃ« printohet.

<img src="https://i.imgur.com/WhA2bCP.png" width="200">

WebAPI nuk mund tÃ« shtojÃ« gjÃ«ra nÃ« stack sa herÃ« qÃ« Ã«shtÃ« gati. NÃ« vend tÃ« kÃ«saj, ai vendos callback nÃ« diÃ§ka qÃ« quhet _queue_.

<img src="https://i.imgur.com/NSnDZmU.png" width="200">

KÃ«tu fillon tÃ« funksionojÃ« event loop. NjÃ« **event loop** shikon "stack" dhe "task queue". NÃ«se "stack" Ã«shtÃ« bosh, ai merr gjÃ«nÃ« e parÃ« nÃ« radhÃ« dhe e vendos atÃ« nÃ« stack.

<img src="https://i.imgur.com/uyiScAI.png" width="200">

`bar` thirret, `"Second"` do tÃ« printohet dhe do tÃ« largohet nga stack.

</p>
</details>

---

###### 31. Ã‡farÃ« do tÃ« jetÃ« event.target kur e klikojmÃ« butonin?

```html
<div onclick="console.log('first div')">
  <div onclick="console.log('second div')">
    <button onclick="console.log('button')">
      Click!
    </button>
  </div>
</div>
```

- A: `div` i jashtÃ«m
- B: `div` i brendshÃ«m
- C: `button`
- D: NjÃ« array i elementeve tÃ« ndÃ«rthurura.

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: C

Elementi mÃ« thellÃ« i mbivendosur qÃ« shkaktoi ngjarjen Ã«shtÃ« objektivi i ngjarjes. Ju mund tÃ« ndaloni bubbling me "event.stopPropagation".

</p>
</details>

---

###### 32. Kur klikoni paragrafin, Ã§farÃ« do tÃ« printohet nÃ« dalje?

```html
<div onclick="console.log('div')">
  <p onclick="console.log('p')">
    Click here!
  </p>
</div>
```

- A: `p` `div`
- B: `div` `p`
- C: `p`
- D: `div`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: A

NÃ«se klikojmÃ« `p`, shohim dy dalje: `p` dhe `div`. GjatÃ« "event propagation", ekzistojnÃ« 3 faza: kapja, objektivi dhe flluska. Si parazgjedhje, mbajtÃ«sit e ngjarjeve (event handlers) ekzekutohen nÃ« fazÃ«n e flluskimit (pÃ«rveÃ§ nÃ«se e vendosni "useCapture" nÃ« "true"). Ai shkon nga elementi mÃ« i thellÃ« i mbivendosur jashtÃ«.

</p>
</details>

---

###### 33. Cila Ã«shtÃ« vlera e saj?

```javascript
const person = { name: 'Lydia' };

function sayHi(age) {
  return `${this.name} is ${age}`;
}

console.log(sayHi.call(person, 21));
console.log(sayHi.bind(person, 21));
```

- A: `undefined is 21` `Lydia is 21`
- B: `function` `function`
- C: `Lydia is 21` `Lydia is 21`
- D: `Lydia is 21` `function`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: D

NÃ« tÃ« dy rastet, ne mund tÃ« e vendosim objektin si argument varÃ«sisht nÃ« cilin funksion dÃ«shirojmÃ« tÃ« referohemi me fjalÃ«n kyÃ§e `this`. MegjithatÃ«, `.call` gjithashtu ekzekutohet menjÃ«herÃ«!

`.bind.` kthen njÃ« _kopje_ tÃ« funksionit, por me njÃ« kontekst tÃ« lidhur! Nuk ekzekutohet menjÃ«herÃ«.

</p>
</details>

---

###### 34. Cila Ã«shtÃ« vlera e saj?

```javascript
function sayHi() {
  return (() => 0)();
}

console.log(typeof sayHi());
```

- A: `"object"`
- B: `"number"`
- C: `"function"`
- D: `"undefined"`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: B

Funksioni `sayHi` kthen vlerÃ«n e kthyer tÃ« shprehjes sÃ« funksionit tÃ« thirrur menjÃ«herÃ« (IIFE). Ky funksion ktheu `0`, qÃ« Ã«shtÃ« i tipit `â€œnumÃ«râ€`.

FYI: `typeof` mund tÃ« kthejÃ« listÃ«n e mÃ«poshtme tÃ« vlerave: `undefined`, `boolean`, `number`, `bigint`, `string`, `symbol`, `function` dhe `object`. Vini re se `typeof null` kthen `â€œobjectâ€`.

</p>
</details>

---

###### 35. Cilat nga kÃ«to vlera janÃ« false?

```javascript
0;
new Number(0);
('');
(' ');
new Boolean(false);
undefined;
```

- A: `0`, `''`, `undefined`
- B: `0`, `new Number(0)`, `''`, `new Boolean(false)`, `undefined`
- C: `0`, `''`, `new Boolean(false)`, `undefined`
- D: TÃ« gjitha paraqesin vlerÃ« false

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: A

EkzistojnÃ« kÃ«to 8 vlera tÃ« cilat paraqesin false:

- `undefined`
- `null`
- `NaN`
- `false`
- `''` (string i zbrazÃ«t)
- `0`
- `-0`
- `0n` (BigInt(0))

KonstruktorÃ«t e funksioneve, si `new Number` dhe `new Boolean` kthejnÃ« vlerÃ« tÃ« vÃ«rtetÃ« (truthy).

</p>
</details>

---

###### 36. Cila Ã«shtÃ« vlera e saj?

```javascript
console.log(typeof typeof 1);
```

- A: `"number"`
- B: `"string"`
- C: `"object"`
- D: `"undefined"`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: B

`typeof 1` kthen `"number"`.
`typeof "number"` kthen `"string"`

</p>
</details>

---

###### 37. Cila Ã«shtÃ« vlera e saj?

```javascript
const numbers = [1, 2, 3];
numbers[10] = 11;
console.log(numbers);
```

- A: `[1, 2, 3, null x 7, 11]`
- B: `[1, 2, 3, 11]`
- C: `[1, 2, 3, empty x 7, 11]`
- D: `SyntaxError`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: C

Kur inicializoni njÃ« vlerÃ« pÃ«r njÃ« element tÃ« vargut (array) i cili e kalon gjatÃ«sinÃ« e tij, Javascript-i krijon diÃ§ka qÃ« quhet "empty slots (vende tÃ« zbrazÃ«ta)". KÃ«to realisht e kanÃ« vlerÃ«n `undefined`, por ju do tÃ« shihni diÃ§ka si:

`[1, 2, 3, empty x 7, 11]`

varÃ«sisht ku e ekzekutoni kodin tuaj (dallon pÃ«r Ã§do browser, node, etj.)

</p>
</details>

---

###### 38. Cila Ã«shtÃ« vlera e saj?

```javascript
(() => {
  let x, y;
  try {
    throw new Error();
  } catch (x) {
    (x = 1), (y = 2);
    console.log(x);
  }
  console.log(x);
  console.log(y);
})();
```

- A: `1` `undefined` `2`
- B: `undefined` `undefined` `undefined`
- C: `1` `1` `2`
- D: `1` `undefined` `undefined`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: A

Blloku `catch` merr argumentin `x`. Kjo nuk Ã«shtÃ« e njÃ«jta `x` si variabla kur ne japim argumente. Variabla `x` (nÃ« bllokun `catch`) ka shtrirje blloku (Ã«shtÃ« block-scoped).

MÃ« vonÃ«, ne e inicializojmÃ« kÃ«tÃ« variabÃ«l me shtrirje blloku tÃ« barabartÃ« me `1` dhe inicializojmÃ« vlerÃ«n e ndryshores `y`. Tani, ne printojmÃ« ndryshoren me shtrirje blloku `x`, e cila Ã«shtÃ« e barabartÃ« me `1`.

JashtÃ« bllokut `catch`, `x` Ã«shtÃ« ende `undefined`, dhe `y` Ã«shtÃ« `2`. Kur dÃ«shirojmÃ« tÃ« bÃ«jmÃ« `console.log(x)` jashtÃ« bllokut `catch`, do tÃ« kthejÃ« `undefined`, dhe `y` kthen `2`.

</p>
</details>

---

###### 39. Ã‡do gjÃ« nÃ« JavaScript Ã«shtÃ« ose...

- A: primitive ose objekt
- B: funksion ose objekt
- C: pyetje me trik! vetÃ«m objekt
- D: numÃ«r ose objekt

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: A

JavaScript ka vetÃ«m tipe primitive dhe objekte.

Tipet primitive janÃ« `boolean`, `null`, `undefined`, `bigint`, `number`, `string`, dhe `symbol`.

Ajo qÃ« e dallon njÃ« tip primitiv nga njÃ« objekt Ã«shtÃ« se primitivÃ«t nuk kanÃ« asnjÃ« veti ose metodÃ«; megjithatÃ«, do tÃ« vini re se `foo.toUpperCase()` vlerÃ«sohet nÃ« `'FOO'` dhe nuk rezulton nÃ« `TypeError`. Kjo ndodh sepse kur pÃ«rpiqeni tÃ« qasni njÃ« veÃ§ori ose metodÃ« nÃ« njÃ« primitive si njÃ« string, JavaScript do tÃ« mbÃ«shtjellÃ« nÃ« mÃ«nyrÃ« implicite tipin primitiv duke pÃ«rdorur njÃ« nga klasat e mbÃ«shtjellÃ«sit, d.m.th. `String`, dhe mÃ« pas do ta heqÃ« menjÃ«herÃ« mbÃ«shtjellÃ«sin pasi tÃ« vlerÃ«sohet shprehja. TÃ« gjithÃ« primitivÃ«t pÃ«rveÃ§ `null` dhe `undefined` e shfaqin kÃ«tÃ« sjellje.

</p>
</details>

---

###### 40. Cila Ã«shtÃ« vlera e saj?

```javascript
[[0, 1], [2, 3]].reduce(
  (acc, cur) => {
    return acc.concat(cur);
  },
  [1, 2],
);
```

- A: `[0, 1, 2, 3, 1, 2]`
- B: `[6, 1, 2]`
- C: `[1, 2, 0, 1, 2, 3]`
- D: `[1, 2, 6]`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: C

`[1, 2]` Ã«shtÃ« vlera jonÃ« fillestare. Kjo Ã«shtÃ« vlera me tÃ« cilÃ«n fillojmÃ«, dhe vlera e parÃ« e `acc`. GjatÃ« iterimit tÃ« parÃ«, `acc` Ã«shtÃ« `[1,2]`, dhe `cur` Ã«shtÃ« `[0, 1]`. Ne i bashkojmÃ« ato dhe kjo rezulton nÃ« `[1, 2, 0, 1]`.

Pastaj, `[1, 2, 0, 1]` Ã«shtÃ« `acc` dhe `[2, 3]` Ã«shtÃ« `cur`. I bashkojmÃ« ato dhe marrim `[1, 2, 0, 1, 2, 3]`

</p>
</details>

---

###### 41. Cila Ã«shtÃ« vlera e saj?

```javascript
!!null;
!!'';
!!1;
```

- A: `false` `true` `false`
- B: `false` `false` `true`
- C: `false` `true` `true`
- D: `true` `true` `false`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: B

`null` Ã«shtÃ« false. `!null` kthen `true`. `!true` kthen `false`.

`""` Ã«shtÃ« false. `!""` kthen `true`. `!true` kthen `false`.

`1` Ã«shtÃ« e vÃ«rtetÃ« (truthy). `!1` kthen `false`. `!false` kthen `true`.

</p>
</details>

---

###### 42. Ã‡farÃ« do tÃ« kthejÃ« nÃ« browser funksioni `setInterval`?

```javascript
setInterval(() => console.log('Hi'), 1000);
```

- A: njÃ« id unike
- B: numrin e milisekondave tÃ« specifikuara
- C: funksionin tÃ« cilin e kemi kaluar si argument
- D: `undefined`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: A

Kthen njÃ« id unike. Kjo id mund tÃ« pÃ«rdoret pÃ«r tÃ« pastruar intervalin me funksionin `clearInterval()`.

</p>
</details>

---

###### 43. Ã‡farÃ« do tÃ« kthehet si rezultat?

```javascript
[...'Lydia'];
```

- A: `["L", "y", "d", "i", "a"]`
- B: `["Lydia"]`
- C: `[[], "Lydia"]`
- D: `[["L", "y", "d", "i", "a"]]`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: A

Stringu Ã«shtÃ« i iterueshÃ«m. Operatori i pÃ«rhapjes (spread operator) iteron Ã§do karakter tÃ« njÃ« elementi tÃ« iterueshÃ«m nÃ« njÃ« element (nÃ« kÃ«tÃ« rast array []).

</p>
</details>

---

###### 44.  Cila Ã«shtÃ« vlera e saj?

```javascript
function* generator(i) {
  yield i;
  yield i * 2;
}

const gen = generator(10);

console.log(gen.next().value);
console.log(gen.next().value);
```

- A: `[0, 10], [10, 20]`
- B: `20, 20`
- C: `10, 20`
- D: `0, 10 and 10, 20`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: C

Funksionet e rregullta nuk mund tÃ« ndalen nÃ« mes tÃ« ekzekutimit pas thirrjes. SidoqoftÃ«, funksioni i gjeneratorit (generator function) mund tÃ« "ndalohet" nÃ« mes tÃ« rrugÃ«s dhe mÃ« vonÃ« tÃ« vazhdojÃ« nga vendi ku ndaloi. Sa herÃ« qÃ« njÃ« funksion gjenerues ndeshet me fjalÃ«n kyÃ§e `yield`, funksioni jep vlerÃ«n e specifikuar pas saj. Vini re se funksioni i gjeneratorit nÃ« atÃ« rast nuk e _kthen_ (return) vlerÃ«n, por e _jep_ (yield) vlerÃ«n.

SÃ« pari, ne inicializojmÃ« funksionin e gjeneratorit me `i` tÃ« barabartÃ« me `10`. Ne thÃ«rrasim funksionin e gjeneratorit duke pÃ«rdorur metodÃ«n `next()`. HerÃ«n e parÃ« qÃ« thÃ«rrasim funksionin e gjeneratorit, `i` Ã«shtÃ« i barabartÃ« me `10`. Ai ndeshet me fjalÃ«n kyÃ§e tÃ« parÃ« `yield`: jep vlerÃ«n e `i`. Gjeneratori tani Ã«shtÃ« `nÃ« pauzÃ«` dhe `10` regjistrohet.

Pastaj, ne e thirrim funksionin pÃ«rsÃ«ri me metodÃ«n `next()`. Fillon dhe vazhdon aty ku ka ndaluar mÃ« parÃ«, ende me `i` tÃ« barabartÃ« me `10`. Tani, ai ndeshet me fjalÃ«n kyÃ§e tjetÃ«r "yield" dhe jep `i * 2`. `i` Ã«shtÃ« e barabartÃ« me `10`, kÃ«shtu qÃ« kthen `10 * 2`, qÃ« Ã«shtÃ« `20`. Kjo rezulton nÃ« `10, 20`.

</p>
</details>

---

###### 45. Ã‡farÃ« do tÃ« kthehet si rezultat?

```javascript
const firstPromise = new Promise((res, rej) => {
  setTimeout(res, 500, 'one');
});

const secondPromise = new Promise((res, rej) => {
  setTimeout(res, 100, 'two');
});

Promise.race([firstPromise, secondPromise]).then(res => console.log(res));
```

- A: `"one"`
- B: `"two"`
- C: `"two" "one"`
- D: `"one" "two"`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: B

Kur i kalojmÃ« premtime (promises) tÃ« shumta metodÃ«s `Promise.race`, ajo zgjidh/refuzon premtimin _e parÃ«_ qÃ« do tÃ« zgjidhet/refuzohet. Me metodÃ«n `setTimeout`, kalojmÃ« njÃ« kohÃ«matÃ«s: 500 ms pÃ«r premtimin e parÃ« (`firstPromise`) dhe 100 ms pÃ«r premtimin e dytÃ« (`secondPromise`). Kjo do tÃ« thotÃ« se `secondPromise`zgjidhet fillimisht me vlerÃ«n `'two'`. `res` tani mban vlerÃ«n e `'two'`, e cila printohet.

</p>
</details>

---

###### 46. Cila Ã«shtÃ« vlera e saj?

```javascript
let person = { name: 'Lydia' };
const members = [person];
person = null;

console.log(members);
```

- A: `null`
- B: `[null]`
- C: `[{}]`
- D: `[{ name: "Lydia" }]`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: D

SÃ« pari, deklarojmÃ« variablÃ«n `person` me vlerÃ«n e objektit i cili e ka vetinÃ« `name`.

<img src="https://i.imgur.com/TML1MbS.png" width="200">

MÃ« pas, ne deklarojmÃ« njÃ« variabÃ«l tÃ« quajtur `members`. E caktojmÃ« elementin e parÃ« tÃ« atij array tÃ« barabartÃ« me vlerÃ«n e variablÃ«s `person`. Objektet ndÃ«rveprojnÃ« me _referencÃ«_ kur i vendosin tÃ« barabartÃ« me njÃ«ri-tjetrin. Kur caktoni njÃ« referencÃ« nga njÃ« ndryshore nÃ« tjetrÃ«n, ju bÃ«ni njÃ« _kopje_ tÃ« asaj reference. (vini re se ato nuk kanÃ« tÃ« njÃ«jtÃ«n referencÃ«!)

<img src="https://i.imgur.com/FSG5K3F.png" width="300">

Pastaj e ri-inicializojmÃ« variablÃ«n `person` tÃ« barabartÃ« me `null`

<img src="https://i.imgur.com/sYjcsMT.png" width="300">

Ne po e modifikojmÃ« vetÃ«m vlerÃ«n e variblÃ«s `person`, dhe jo tÃ« elementit tÃ« parÃ« ne array, meqenÃ«se ai element ka njÃ« referencÃ« tÃ« ndryshme (tÃ« kopjuar) pÃ«r objektin. Elementi i parÃ« nÃ« `members` ende mban referencÃ«n e tij ndaj objektit origjinal. Kur printojmÃ« array `members`, elementi i parÃ« ende mban vlerÃ«n e objektit, i cili printohet.

</p>
</details>

---

###### 47. Cila Ã«shtÃ« vlera e saj?

```javascript
const person = {
  name: 'Lydia',
  age: 21,
};

for (const item in person) {
  console.log(item);
}
```

- A: `{ name: "Lydia" }, { age: 21 }`
- B: `"name", "age"`
- C: `"Lydia", 21`
- D: `["name", "Lydia"], ["age", 21]`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: B

Me unazÃ«n `for-in`, ne mund tÃ« iterojmÃ« pÃ«rgjatÃ« Ã§elÃ«save tÃ« objektit, nÃ« kÃ«tÃ« rast `name` dhe `age`. NÃ« prapavijÃ«, Ã§elÃ«sat e objektit janÃ« stringje (nÃ« qoftesÃ« nuk janÃ« Symbol). NÃ« Ã§do unazÃ«, ne vendosim vlerÃ«n e `item` tÃ« barabartÃ« me Ã§elÃ«sin aktual nÃ« tÃ« cilin po iterohet. SÃ« pari, `item` Ã«shtÃ« i barabartÃ« me `name`, dhe printohet. Pastaj, `item` Ã«shtÃ« e barabartÃ« me `age` dhe printohet.

</p>
</details>

---

###### 48. Cila Ã«shtÃ« vlera e saj?

```javascript
console.log(3 + 4 + '5');
```

- A: `"345"`
- B: `"75"`
- C: `12`
- D: `"12"`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: B

Radha e veprimeve matematikore tÃ« operatorit Ã«shtÃ« rendi nÃ« tÃ« cilin pÃ«rpiluesi (kompajleri) vlerÃ«son shprehjet, qoftÃ« nga e majta nÃ« tÃ« djathtÃ« ose nga e djathta nÃ« tÃ« majtÃ«. Kjo ndodh vetÃ«m nÃ«se tÃ« gjithÃ« operatorÃ«t kanÃ« pÃ«rparÃ«sinÃ« _tÃ« njejtÃ«_. Ne kemi vetÃ«m njÃ« lloj operatori: `+`. PÃ«r mÃ« tepÃ«r, radha e veprimeve matematikore Ã«shtÃ« nga e majta nÃ« tÃ« djathtÃ«.

`3 + 4` llogaritet sÃ« pari. Kjo rezulton nÃ« numrin `7`.

`7 + '5'` rezulton nÃ« `"75"` pÃ«r shkak tÃ« shndÃ«rrimit tÃ« tipit (coercion). JavaScript-i e konverton numrin `7` ne njÃ« string, shiko pyetjen 15. Ne mund tÃ« i bashkojmÃ« dy stringje duke e pÃ«rdorur operatorin `+`. `"7"` + `"5"` rezulton nÃ« `"75"`

</p>
</details>

---

###### 49. What's the value of `num`?

```javascript
const num = parseInt('7*6', 10);
```

- A: `42`
- B: `"42"`
- C: `7`
- D: `NaN`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: C

Kthehen vetÃ«m numrat e parÃ« nÃ« string. Bazuar nÃ« _radix (bazÃ«)_ (argumenti i dytÃ« pÃ«r tÃ« specifikuar se nÃ« Ã§farÃ« tipi duam ta parsojmÃ« atÃ«: bazÃ«n 10, heksadecimal, oktal, binar, etj.), `parseInt` kontrollon nÃ«se karakteret nÃ« string janÃ« tÃ« vlefshme. Pasi tÃ« ndeshet me njÃ« karakter qÃ« nuk Ã«shtÃ« njÃ« numÃ«r i vlefshÃ«m nÃ« bazÃ«, ai ndalon parsimin dhe injoron karakteret e ardhshme.

`*` nuk Ã«shtÃ« numÃ«r valid. Parson vetÃ«m `"7"` nÃ« decimal `7`. `num` tani mban vlerÃ«n `7`.

</p>
</details>

---

###### 50. Cila Ã«shtÃ« vlera e saj?

```javascript
[1, 2, 3].map(num => {
  if (typeof num === 'number') return;
  return num * 2;
});
```

- A: `[]`
- B: `[null, null, null]`
- C: `[undefined, undefined, undefined]`
- D: `[ 3 x empty ]`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: C

Kur iterojmÃ« (map-ojmÃ«) njÃ« array, vlera e `num` Ã«shtÃ« e barabartÃ« me elementin qÃ« Ã«shtÃ« duke u iteruar aktualisht. NÃ« kÃ«tÃ« rast, elementet janÃ« numra, kÃ«shtu qÃ« kushti i deklaratÃ«s if `typeof num === "number"` kthen `true`. Funksioni map krijon njÃ« grup tÃ« ri dhe fut vlerat e kthyera nga funksioni.

MegjithatÃ«, ne nuk kthejmÃ« njÃ« vlerÃ«. Kur nuk kthejmÃ« njÃ« vlerÃ« nga funksioni, funksioni kthen `undefined`. PÃ«r Ã§do element nÃ« array, blloku i funksionit thirret, kÃ«shtu qÃ« pÃ«r secilin element ne kthejmÃ« `undefined`.

</p>
</details>

---

###### 51. Cila Ã«shtÃ« vlera e saj?

```javascript
function getInfo(member, year) {
  member.name = 'Lydia';
  year = '1998';
}

const person = { name: 'Sarah' };
const birthYear = '1997';

getInfo(person, birthYear);

console.log(person, birthYear);
```

- A: `{ name: "Lydia" }, "1997"`
- B: `{ name: "Sarah" }, "1998"`
- C: `{ name: "Lydia" }, "1998"`
- D: `{ name: "Sarah" }, "1997"`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: A

Argumentet kalohen si _vlerÃ«_, pÃ«rveÃ§ nÃ«se vlera e tyre Ã«shtÃ« njÃ« objekt, atÃ«herÃ« ato kalohen si _referencÃ«_. `birthYear` kalohet sipas vlerÃ«s, pasi Ã«shtÃ« njÃ« string, jo njÃ« objekt. Kur kalojmÃ« argumente sipas vlerÃ«s, krijohet njÃ« _kopje_ e asaj vlere (shih pyetjen 46).

Variabla `birthYear` ka referencÃ« nÃ« vlerÃ«n `â€œ1997â€`. Argumenti `year` gjithashtu ka referencÃ« nÃ« vlerÃ«n `"1997"`, por nuk Ã«shtÃ« e njÃ«jta vlerÃ« si `birthYear`. Kur pÃ«rditÃ«sojmÃ« vlerÃ«n e `year` duke vendosur `year` tÃ« barabartÃ« me `"1998"`, ne po pÃ«rditÃ«sojmÃ« vetÃ«m vlerÃ«n e `year`. `birthYear` Ã«shtÃ« ende i barabartÃ« me `"1997"`.

Vlera e `person` Ã«shtÃ« objekt. Argumenti `member` ka referencÃ« (tÃ« kopjuar) pÃ«r objektin e njejtÃ«. Kur modifikojmÃ« njÃ« veti tÃ« objektit qÃ« `member` ka njÃ« referencÃ«, vlera e `person` gjithashtu do tÃ« modifikohet, pasi tÃ« dy kanÃ« njÃ« referencÃ« pÃ«r tÃ« njÃ«jtin objekt. Vetia `name` e `person` tani Ã«shtÃ« e barabartÃ« me vlerÃ«n `"Lydia"`.

</p>
</details>

---

###### 52. Cila Ã«shtÃ« vlera e saj?

```javascript
function greeting() {
  throw 'Hello world!';
}

function sayHi() {
  try {
    const data = greeting();
    console.log('It worked!', data);
  } catch (e) {
    console.log('Oh no an error:', e);
  }
}

sayHi();
```

- A: `It worked! Hello world!`
- B: `Oh no an error: undefined`
- C: `SyntaxError: can only throw Error objects`
- D: `Oh no an error: Hello world!`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: D

Me deklaratÃ«n `throw`, ne mund tÃ« krijojmÃ« gabime (error) tÃ« personalizuara. Me kÃ«tÃ« deklaratÃ«, ju mund tÃ« bÃ«ni pÃ«rjashtime. NjÃ« pÃ«rjashtim mund tÃ« jetÃ« njÃ« string, njÃ« numÃ«r, njÃ« boolean ose njÃ« objekt. NÃ« kÃ«tÃ« rast, pÃ«rjashtimi ynÃ« Ã«shtÃ« stringy `'Hello world!'`.

Me deklaratÃ«n `catch`, ne mund tÃ« specifikojmÃ« se Ã§farÃ« tÃ« bÃ«jmÃ« nÃ«se njÃ« pÃ«rjashtim hidhet nÃ« bllokun `try`. BÃ«het njÃ« pÃ«rjashtim: stringu `'Hello world!'`. `e` tani Ã«shtÃ« e barabartÃ« me atÃ« string, tÃ« cilin e regjistrojmÃ«. Kjo rezulton nÃ« `'Oh an error: Hello world!'`.

</p>
</details>

---

###### 53. Cila Ã«shtÃ« vlera e saj?

```javascript
function Car() {
  this.make = 'Lamborghini';
  return { make: 'Maserati' };
}

const myCar = new Car();
console.log(myCar.make);
```

- A: `"Lamborghini"`
- B: `"Maserati"`
- C: `ReferenceError`
- D: `TypeError`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: B

Kur njÃ« konstruktor thirret me fjalÃ«n kyÃ§e `new`, ai krijon njÃ« objekt dhe vendos fjalÃ«n kyÃ§e `this` pÃ«r t'iu referuar atij objekti. Si parazgjedhje, nÃ«se konstruktori nuk kthen asgjÃ« nÃ« mÃ«nyrÃ« tÃ« qartÃ«, ai do tÃ« kthejÃ« objektin e krijuar sÃ« fundi.

NÃ« kÃ«tÃ« rast, konstruktori `Car` kthen nÃ« mÃ«nyrÃ« eksplicite njÃ« objekt tÃ« ri me `make` tÃ« vendosur nÃ« `"Maserati"`, i cili mbishkruan sjelljen e paracaktuar. Prandaj, kur thirret `New Car()`, objekti i kthyer i caktohet `myCar`, duke rezultuar nÃ« daljen `â€œMaseratiâ€` kur qaset `myCar.make`.

</p>
</details>

---

###### 54. Cila Ã«shtÃ« vlera e saj?

```javascript
(() => {
  let x = (y = 10);
})();

console.log(typeof x);
console.log(typeof y);
```

- A: `"undefined", "number"`
- B: `"number", "number"`
- C: `"object", "number"`
- D: `"number", "undefined"`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: A

`let x = (y = 10);` Ã«shtÃ« shkurtesÃ« pÃ«r:

```javascript
y = 10;
let x = y;
```

Kur e vendosim `y` tÃ« barabartÃ« me `10`, ne nÃ« tÃ« vÃ«rtetÃ« e shtojmÃ« vetinÃ« `y` nÃ« objektin global (`window` nÃ« browser, `global` nÃ« Node). NÃ« browser, `window.y` Ã«shtÃ« tani e barabartÃ« me `10`.

MÃ« pas, ne deklarojmÃ« variablÃ«n `x` me vlerÃ«n `y`, e cila Ã«shtÃ« `10`. Variablat e deklaruara me fjalÃ«n kyÃ§e 'let' janÃ« _block scoped_, ato pÃ«rcaktohen vetÃ«m brenda bllokut ku janÃ« deklaruar; shprehja e funksionit tÃ« thirrur menjÃ«herÃ« (IIFE) nÃ« kÃ«tÃ« rast. Kur pÃ«rdorim operatorin `typeof`, operandi `x` nuk Ã«shtÃ« i pÃ«rcaktuar: ne po pÃ«rpiqemi tÃ« qasim `x` jashtÃ« bllokut ku ai Ã«shtÃ« deklaruar. Kjo do tÃ« thotÃ« se `x` nuk Ã«shtÃ« pÃ«rcaktuar. Vlerat e tÃ« cilave nuk u Ã«shtÃ« caktuar njÃ« vlerÃ« ose nuk janÃ« deklaruar janÃ« tÃ« tipit `"undefined"`. `console.log(typeof x)` kthen `"undefined"`.

MegjithatÃ«, ne krijuam njÃ« variabÃ«l globale `y` kur vendosÃ«m `y` tÃ« barabartÃ« me `10`. Kjo vlerÃ« Ã«shtÃ« e qasshme kudo nÃ« kodin tonÃ«. `y` Ã«shtÃ« pÃ«rcaktuar dhe mban vlerÃ«n e tipit `"number"`. `console.log(typeof y)` kthen `"number"`.

</p>
</details>

---

###### 55. Cila Ã«shtÃ« vlera e saj?

```javascript
class Dog {
  constructor(name) {
    this.name = name;
  }
}

Dog.prototype.bark = function() {
  console.log(`Woof I am ${this.name}`);
};

const pet = new Dog('Mara');

pet.bark();

delete Dog.prototype.bark;

pet.bark();
```

- A: `"Woof I am Mara"`, `TypeError`
- B: `"Woof I am Mara"`, `"Woof I am Mara"`
- C: `"Woof I am Mara"`, `undefined`
- D: `TypeError`, `TypeError`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: A

Ne mund tÃ« fshijmÃ« veti nga objektet duke pÃ«rdorur fjalÃ«n kyÃ§e `delete`, gjithashtu nÃ« prototip. Duke fshirÃ« njÃ« veti nÃ« prototip, ajo nuk Ã«shtÃ« mÃ« e qasshme nÃ« zinxhirin e prototipit. NÃ« kÃ«tÃ« rast, funksioni `bark` nuk Ã«shtÃ« mÃ« i qasshÃ«m nÃ« prototip pas `delete Dog.prototype.bark`, por ne ende provojmÃ« tÃ« i qasemi.

Kur pÃ«rpiqemi tÃ« thÃ«rrasim diÃ§ka qÃ« nuk Ã«shtÃ« funksion, hidhet njÃ« 'TypeError'. NÃ« kÃ«tÃ« rast `TypeError: pet.bark is not a function`, pasi `pet.bark` Ã«shtÃ« `undefined`.

</p>
</details>

---

###### 56. Cila Ã«shtÃ« vlera e saj?

```javascript
const set = new Set([1, 1, 2, 3, 4]);

console.log(set);
```

- A: `[1, 1, 2, 3, 4]`
- B: `[1, 2, 3, 4]`
- C: `{1, 1, 2, 3, 4}`
- D: `{1, 2, 3, 4}`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: D

Objekti `Set` Ã«shtÃ« njÃ« koleksion vlerash _unike_: njÃ« vlerÃ« mund tÃ« paraqitet vetÃ«m njÃ« herÃ« nÃ« njÃ« grup (set).

VendosÃ«m `[1, 1, 2, 3, 4]` me njÃ« vlerÃ« dublikate `1`. MeqenÃ«se nuk mund tÃ« kemi dy vlera tÃ« njÃ«jta nÃ« njÃ« "set", njÃ«ra prej tyre largohet. Kjo rezulton nÃ« `{1, 2, 3, 4}`.

</p>
</details>

---

###### 57. Cila Ã«shtÃ« vlera e saj?

```javascript
// counter.js
let counter = 10;
export default counter;
```

```javascript
// index.js
import myCounter from './counter';

myCounter += 1;

console.log(myCounter);
```

- A: `10`
- B: `11`
- C: `Error`
- D: `NaN`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: C

NjÃ« modul i importuar mund vetÃ«m tÃ« i lexohet vlera (_read-only_): nuk mund tÃ« modifikohet. VetÃ«m moduli i cili i importon ato mund tÃ« ndÃ«rrojÃ« atÃ« vlerÃ«.

Kur tentojmÃ« tÃ« rrisim vlerÃ«n e `myCounter`, do tÃ« marrim njÃ« error: `myCounter` mundet vetÃ«m tÃ« lexohet dhe nuk mund tÃ« modifikohet.

</p>
</details>

---

###### 58. Cila Ã«shtÃ« vlera e saj?

```javascript
const name = 'Lydia';
age = 21;

console.log(delete name);
console.log(delete age);
```

- A: `false`, `true`
- B: `"Lydia"`, `21`
- C: `true`, `true`
- D: `undefined`, `undefined`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: A

Operatori "delete" kthen njÃ« vlerÃ« booleane: `true` nÃ« fshirje tÃ« suksesshme, pÃ«rndryshe do tÃ« kthejÃ« `false`. MegjithatÃ«, variablat e deklaruara me fjalÃ«n kyÃ§e `var`, `const` ose `let` nuk mund tÃ« fshihen duke pÃ«rdorur operatorin  `delete`.

Variabla `name` u deklarua me fjalÃ«n kyÃ§e `const`, kÃ«shtu qÃ« fshirja e saj nuk ishte e suksesshme: u kthye `false`. Kur vendosÃ«m `age` tÃ« barabartÃ« me `21`, ne nÃ« fakt shtuam njÃ« veti tÃ« quajtur `age` nÃ« objektin global. Ju mund tÃ« fshini me sukses vetitÃ« nga objektet nÃ« kÃ«tÃ« mÃ«nyrÃ«, gjithashtu edhe objektin global, kÃ«shtu qÃ« `delete age` kthen `true`.

</p>
</details>

---

###### 59. Cila Ã«shtÃ« vlera e saj?

```javascript
const numbers = [1, 2, 3, 4, 5];
const [y] = numbers;

console.log(y);
```

- A: `[[1, 2, 3, 4, 5]]`
- B: `[1, 2, 3, 4, 5]`
- C: `1`
- D: `[1]`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: C

Ne mund tÃ« targetojmÃ« vlerat nga vargjet ose vetitÃ« nga objektet pÃ«rmes destrukturimit. PÃ«r shembull:

```javascript
[a, b] = [1, 2];
```

<img src="https://i.imgur.com/ADFpVop.png" width="200">

Vlera `a` tani Ã«shtÃ« `1`, dhe vlera `b` tani Ã«shtÃ« `2`. Ã‡farÃ« ne bÃ«mÃ« nÃ« tÃ« vÃ«rtetÃ« nÃ« pyetje, Ã«shtÃ«:

```javascript
[y] = [1, 2, 3, 4, 5];
```

<img src="https://i.imgur.com/NzGkMNk.png" width="200">

Kjo do tÃ« thotÃ« se vlera e `y` Ã«shtÃ« e barabartÃ« me vlerÃ«n e parÃ« nÃ« array, qÃ« Ã«shtÃ« numri `1`. Kur printojmÃ« `y`, do tÃ« kthehet `1`.

</p>
</details>

---

###### 60. Cila Ã«shtÃ« vlera e saj?

```javascript
const user = { name: 'Lydia', age: 21 };
const admin = { admin: true, ...user };

console.log(admin);
```

- A: `{ admin: true, user: { name: "Lydia", age: 21 } }`
- B: `{ admin: true, name: "Lydia", age: 21 }`
- C: `{ admin: true, user: ["Lydia", 21] }`
- D: `{ admin: true }`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: B

Ã‹shtÃ« e mundur tÃ« kombinohen objektet duke pÃ«rdorur operatorin e pÃ«rhapjes (spread) `...`. Kjo ju lejon tÃ« krijoni kopje tÃ« Ã§ifteve Ã§elÃ«s/vlerÃ« tÃ« njÃ« objekti dhe t'i shtoni ato nÃ« njÃ« objekt tjetÃ«r. NÃ« kÃ«tÃ« rast, ne krijojmÃ« kopje tÃ« objektit `user` dhe i shtojmÃ« ato nÃ« objektin `admin`. Objekti `admin` tani pÃ«rmban Ã§iftet e kopjuara tÃ« Ã§elÃ«sit/vlerÃ«s, qÃ« rezulton nÃ« `{ admin: true, emri: "Lydia", mosha: 21 }`.

</p>
</details>

---

###### 61. Cila Ã«shtÃ« vlera e saj?

```javascript
const person = { name: 'Lydia' };

Object.defineProperty(person, 'age', { value: 21 });

console.log(person);
console.log(Object.keys(person));
```

- A: `{ name: "Lydia", age: 21 }`, `["name", "age"]`
- B: `{ name: "Lydia", age: 21 }`, `["name"]`
- C: `{ name: "Lydia"}`, `["name", "age"]`
- D: `{ name: "Lydia"}`, `["age"]`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: B

Me metodÃ«n `defineProperty`, ne mund tÃ« shtojmÃ« veti tÃ« reja nÃ« njÃ« objekt, ose tÃ« modifikojmÃ« ato ekzistuese. Kur shtojmÃ« njÃ« veti nÃ« njÃ« objekt duke pÃ«rdorur metodÃ«n `defineProperty`, ato janÃ« si parazgjedhje _not enumerable_. Metoda `Object.keys` kthen tÃ« gjithÃ« emrat e vetive _numerable_ nga njÃ« objekt, nÃ« kÃ«tÃ« rast vetÃ«m `"name"`.

VetitÃ« e shtuara duke pÃ«rdorur metodÃ«n `defineProperty` janÃ« tÃ« pandryshueshme si parazgjedhje. Ju mund ta mbishkruani kÃ«tÃ« sjellje duke pÃ«rdorur veÃ§oritÃ« `writable`, `configurable` dhe `enumerable`. NÃ« kÃ«tÃ« mÃ«nyrÃ«, metoda `defineProperty` ju jep shumÃ« mÃ« tepÃ«r kontroll mbi vetitÃ« qÃ« po i shtoni njÃ« objekti.

</p>
</details>

---

###### 62. Cila Ã«shtÃ« vlera e saj?

```javascript
const settings = {
  username: 'lydiahallie',
  level: 19,
  health: 90,
};

const data = JSON.stringify(settings, ['level', 'health']);
console.log(data);
```

- A: `"{"level":19, "health":90}"`
- B: `"{"username": "lydiahallie"}"`
- C: `"["level", "health"]"`
- D: `"{"username": "lydiahallie", "level":19, "health":90}"`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: A

Argumenti i dytÃ« i "JSON.stringify" Ã«shtÃ« _zÃ«vendÃ«suesi_. ZÃ«vendÃ«suesi mund tÃ« jetÃ« ose njÃ« funksion ose njÃ« array, dhe ju lejon tÃ« kontrolloni se Ã§farÃ« dhe si duhet tÃ« konvertohet njÃ« vlerÃ« e JavaScript nÃ« JSON string.

NÃ«se zÃ«vendÃ«suesi Ã«shtÃ« njÃ« _array_, vetÃ«m emrat e vetive tÃ« pÃ«rfshira nÃ« array do tÃ« shtohen nÃ« stringun JSON. NÃ« kÃ«tÃ« rast, pÃ«rfshihen vetÃ«m vetitÃ« me emrat `"level"` dhe `"health"`, pÃ«rjashtohet `"username"`. `data` tani Ã«shtÃ« e barabartÃ« me `"{"level":19, "health":90}"`.

NÃ«se zÃ«vendÃ«suesi Ã«shtÃ« njÃ« _funksion_, ky funksion thirret nÃ« Ã§do veti nÃ« objektin qÃ« po e pÃ«rdorni metodÃ«n 'stringify'. Vlera e kthyer nga ky funksion do tÃ« jetÃ« vlera e vetive kur tÃ« shtohet nÃ« vargun JSON. NÃ«se vlera Ã«shtÃ« `undefined`, kjo veti pÃ«rjashtohet nga vargu JSON.

</p>
</details>

---

###### 63. Cila Ã«shtÃ« vlera e saj?

```javascript
let num = 10;

const increaseNumber = () => num++;
const increasePassedNumber = number => number++;

const num1 = increaseNumber();
const num2 = increasePassedNumber(num1);

console.log(num1);
console.log(num2);
```

- A: `10`, `10`
- B: `10`, `11`
- C: `11`, `11`
- D: `11`, `12`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: A

Operatori unar `++` fillimisht kthen vlerÃ«n e operandit, pastaj e rrit vlerÃ«n e tij. Vlera e `num1` Ã«shtÃ« `10`, meqenÃ«se funksioni `increaseNumber` fillimisht kthen vlerÃ«n e `num`, e cila Ã«shtÃ« `10`, dhe vetÃ«m pastaj e rrit vlerÃ«n e `num`.

`num2` Ã«shtÃ« `10`, pasi ne e kaluam `num1` si argument tek `increasePassedNumber`. `number` Ã«shtÃ« i barabartÃ« me `10`(vlera e  `num1`). PÃ«rsÃ«ri, operatori unar `++` _sÃ« pari kthen_ vlerÃ«n e operandit, dhe pastaj rrit vlerÃ«n e tij. Vlera e `number` Ã«shtÃ« `10`, kÃ«shtu qÃ« `num2` Ã«shtÃ« e barabartÃ« me `10`.

</p>
</details>

---

###### 64. Cila Ã«shtÃ« vlera e saj?

```javascript
const value = { number: 10 };

const multiply = (x = { ...value }) => {
  console.log((x.number *= 2));
};

multiply();
multiply();
multiply(value);
multiply(value);
```

- A: `20`, `40`, `80`, `160`
- B: `20`, `40`, `20`, `40`
- C: `20`, `20`, `20`, `40`
- D: `NaN`, `NaN`, `20`, `40`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: C

NÃ« ES6, ne mund tÃ« inicializojmÃ« parametrat me njÃ« vlerÃ« tÃ« paracaktuar (default). Vlera e parametrit do tÃ« jetÃ« vlera e paracaktuar, nÃ«se asnjÃ« vlerÃ« tjetÃ«r nuk i Ã«shtÃ« kaluar funksionit, ose nÃ«se vlera e parametrit Ã«shtÃ« `"undefined"`. NÃ« kÃ«tÃ« rast, ne i shpÃ«rndajmÃ« vetitÃ« e objektit `value` nÃ« njÃ« objekt tÃ« ri, kÃ«shtu qÃ« `x` ka vlerÃ«n e paracaktuar tÃ« `{ number: 10 }`.

Argumenti i paracaktuar vlerÃ«sohet (llogaritet) nÃ« _kohÃ«n e thirrjes_! Sa herÃ« qÃ« thÃ«rrasim funksionin, krijohet njÃ« objekt i ri. Ne e thÃ«rrasim funksionin `multiply` dy herÃ«t e para pa kaluar vlerÃ«n: `x` ka vlerÃ«n e paracaktuar tÃ« `{ number: 10 }`. MÃ« pas printojmÃ« vlerÃ«n e shumÃ«zuar tÃ« atij numri, qÃ« Ã«shtÃ« `20`.

HerÃ«n e tretÃ« qÃ« thÃ«rrasim funksionin `multiply`, kalojmÃ« njÃ« argument: objektin e quajtur `value`. Operatori `*=` Ã«shtÃ« nÃ« fakt shkurtesÃ« pÃ«r `x.number = x.number * 2`: ne e modifikojmÃ« vlerÃ«n e `x.number` dhe printojmÃ« vlerÃ«n e shumÃ«zuar `20`.

HerÃ«n e katÃ«rt, ne e kalojmÃ« pÃ«rsÃ«ri objektin `value`. `x.number` Ã«shtÃ« modifikuar mÃ« parÃ« nÃ« `20`, kÃ«shtu qÃ« `x.number *= 2` printon `40`.

</p>
</details>

---

###### 65. Cila Ã«shtÃ« vlera e saj?

```javascript
[1, 2, 3, 4].reduce((x, y) => console.log(x, y));
```

- A: `1` `2` dhe `3` `3` dhe `6` `4`
- B: `1` `2` dhe `2` `3` dhe `3` `4`
- C: `1` `undefined` dhe `2` `undefined` dhe `3` `undefined` dhe `4` `undefined`
- D: `1` `2` dhe `undefined` `3` dhe `undefined` `4`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: D

Argumenti i parÃ« qÃ« merr metoda `reduce` Ã«shtÃ« _akumulatori_, nÃ« kÃ«tÃ« rast `x`. Argumenti i dytÃ« Ã«shtÃ« _vlera aktuale_, `y`. Me metodÃ«n e reduktimit, ne ekzekutojmÃ« njÃ« funksion tÃ« kthimit (callback) nÃ« Ã§do element nÃ« array, i cili pÃ«rfundimisht mund tÃ« rezultojÃ« nÃ« njÃ« vlerÃ« tÃ« vetme.

NÃ« kÃ«tÃ« shembull, ne nuk jemi duke kthyer ndonjÃ« vlerÃ«, jemi vetÃ«m duke printuar vlerat e akumulatorit dhe vlerÃ«n aktuale.

Vlera e akumulatorit Ã«shtÃ« e barabartÃ« me vlerÃ«n e kthyer mÃ« parÃ« tÃ« funksionit tÃ« kthimit (callback). NÃ«se nuk e kaloni argumentin opsional `initialValue` nÃ« metodÃ«n `reduce`, akumuluesi Ã«shtÃ« i barabartÃ« me elementin e parÃ« nÃ« thirrjen e parÃ«.

NÃ« thirrjen e parÃ«, akumuluesi (`x`) Ã«shtÃ« `1`, dhe vlera aktuale (`y`) Ã«shtÃ« `2`. Ne nuk kthehemi nga callback, ne printojmÃ« akumuluesin dhe vlerÃ«n aktuale: `1` dhe `2` printohen.

NÃ«se nuk ktheni njÃ« vlerÃ« nga njÃ« funksion, ai kthen `undefined`. NÃ« thirrjen tjetÃ«r, akumuluesi Ã«shtÃ« `undefined` dhe vlera aktuale Ã«shtÃ« `3`. `undefined` dhe `3` printohet.

NÃ« thirrjen e katÃ«rt, ne pÃ«rsÃ«ri nuk kthehemi nga callback. Akumulatori Ã«shtÃ« pÃ«rsÃ«ri `undefined` dhe vlera aktuale Ã«shtÃ« `4`. `undefined` dhe `4` printohen.

</p>
</details>

---

###### 66. Me cilin konstruktor mund tÃ« zgjerojmÃ« me sukses klasÃ«n 'Dog'?

```javascript
class Dog {
  constructor(name) {
    this.name = name;
  }
};

class Labrador extends Dog {
  // 1
  constructor(name, size) {
    this.size = size;
  }
  // 2
  constructor(name, size) {
    super(name);
    this.size = size;
  }
  // 3
  constructor(size) {
    super(name);
    this.size = size;
  }
  // 4
  constructor(name, size) {
    this.name = name;
    this.size = size;
  }

};
```

- A: 1
- B: 2
- C: 3
- D: 4

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: B

NÃ« njÃ« klasÃ« tÃ« derivuar, ju nuk mund tÃ« pÃ«rdorni fjalÃ«n kyÃ§e `this` pÃ«rpara se tÃ« e thirrni `super`. NÃ«se provoni ta bÃ«ni kÃ«tÃ«, do tÃ« jap `ReferenceError`: 1 dhe 4 do tÃ« hedhin njÃ« gabim referimi.

Me fjalÃ«n kyÃ§e `super`, ne e thÃ«rrasim konstruktorin e asaj klase mÃ«mÃ« me argumentet e dhÃ«na. Konstruktori i prindit merr argumentin `name`, kÃ«shtu qÃ« ne duhet tÃ« kalojmÃ« `name` nÃ« `super`.

Klasa `Labrador` merr dy argumente, `name` meqenÃ«se trashÃ«gon klasÃ«n 'Dog', dhe `size` si njÃ« veti shtesÃ« nÃ« klasÃ«n `Labrador`. Ata tÃ« dy duhet t'i kalojnÃ« konstruktorit nÃ« `Labrador`, i cili implementohet saktÃ« duke pÃ«rdorur konstruktorin 2.

</p>
</details>

---

###### 67. Cila Ã«shtÃ« vlera e saj?

```javascript
// index.js
console.log('running index.js');
import { sum } from './sum.js';
console.log(sum(1, 2));

// sum.js
console.log('running sum.js');
export const sum = (a, b) => a + b;
```

- A: `running index.js`, `running sum.js`, `3`
- B: `running sum.js`, `running index.js`, `3`
- C: `running sum.js`, `3`, `running index.js`
- D: `running index.js`, `undefined`, `running sum.js`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: B

Me fjalÃ«n kyÃ§e `import`, tÃ« gjitha modulet e importuara parsohen fillimisht (_para-parsed_). Kjo do tÃ« thotÃ« qÃ« modulet e importuara ekzekutohen _tÃ« parat_, kodi nÃ« file qÃ« importon modulin ekzekutohet _mÃ« pas_.

Ky Ã«shtÃ« njÃ« dallimi nÃ« mes `require()` nÃ« CommonJS dhe `import`! Me `require()`, mund tÃ« ngarkoni varÃ«sitÃ« sipas kÃ«rkesÃ«s gjatÃ« ekzekutimit tÃ« kodit. NÃ«se do tÃ« kishim pÃ«rdorur `require` nÃ« vend tÃ« `import`, `running index.js`, `running sum.js`, `3` do tÃ« ishte printuar nÃ« tastierÃ«.

</p>
</details>

---

###### 68. Cila Ã«shtÃ« vlera e saj?

```javascript
console.log(Number(2) === Number(2));
console.log(Boolean(false) === Boolean(false));
console.log(Symbol('foo') === Symbol('foo'));
```

- A: `true`, `true`, `false`
- B: `false`, `true`, `false`
- C: `true`, `false`, `true`
- D: `true`, `true`, `true`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: A

Ã‡do Symbol Ã«shtÃ« tÃ«rÃ«sisht unik. Arsyeja e jepjes tÃ« argumentit nÃ« Symbol Ã«shtÃ« tÃ« i jap pÃ«rshkrim Symbol. Vlera e Symbol nuk Ã«shtÃ« e varur nga argumenti i cili i ipet. MeqenÃ«se po testojmÃ« barazueshmÃ«rinÃ«, ne jemi duke krijuar dy Symbol tÃ«rÃ«sisht tÃ« reja: `Symbol('foo')` i parÃ« dhe `Symbol('foo)` i dytÃ«. TÃ« dy janÃ« vlera unike dhe jo tÃ« barabarta me njÃ«ra tjetrÃ«n, `Symbol('foo') === Symbol('foo')` kthen `false`.

</p>
</details>

---

###### 69. Cila Ã«shtÃ« vlera e saj?

```javascript
const name = 'Lydia Hallie';
console.log(name.padStart(13));
console.log(name.padStart(2));
```

- A: `"Lydia Hallie"`, `"Lydia Hallie"`
- B: `" Lydia Hallie"`, `" Lydia Hallie"` (`"[13x whitespace]Lydia Hallie"`, `"[2x whitespace]Lydia Hallie"`)
- C: `" Lydia Hallie"`, `"Lydia Hallie"` (`"[1x whitespace]Lydia Hallie"`, `"Lydia Hallie"`)
- D: `"Lydia Hallie"`, `"Lyd"`,

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: C

Me metodÃ«n `padStart`, mund tÃ« shtojmÃ« mbushje (padding) nÃ« fillim tÃ« njÃ« stringu. Vlera e kaluar nÃ« kÃ«tÃ« metodÃ« Ã«shtÃ« gjatÃ«sia totale e stringut sÃ« bashku me mbushjen. Vargu "Lydia Hallie" ka njÃ« gjatÃ«si prej `12` karakteresh. `name.padStart(13)` vendos 1 hapÃ«sirÃ« nÃ« fillim tÃ« vargut, sepse 12 + 1 Ã«shtÃ« 13.

NÃ«se argumenti i kaluar nÃ« metodÃ«n `padStart` Ã«shtÃ« mÃ« i vogÃ«l se gjatÃ«sia e array, nuk do tÃ« shtohet asnjÃ« mbushje.

</p>
</details>

---

###### 70. Cila Ã«shtÃ« vlera e saj?

```javascript
console.log('ğŸ¥‘' + 'ğŸ’»');
```

- A: `"ğŸ¥‘ğŸ’»"`
- B: `257548`
- C: NjÃ« varg qÃ« pÃ«rmban kodin pÃ«r t'i shfaqur kÃ«to simbole
- D: Error

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: A

Me operatorin `+`, ju mund tÃ« bashkoni vargjet. NÃ« kÃ«tÃ« rast, ne po bashkojmÃ« stringun `"ğŸ¥‘"` me stringun `"ğŸ’»"`, duke rezultuar nÃ« `"ğŸ¥‘ğŸ’»"`.

</p>
</details>

---

###### 71. How can we log the values that are commented out after the console.log statement?

```javascript
function* startGame() {
  const PÃ«rgjigja = yield 'Do you love JavaScript?';
  if (PÃ«rgjigja !== 'Yes') {
    return "Oh wow... Guess we're done here";
  }
  return 'JavaScript loves you back â¤ï¸';
}

const game = startGame();
console.log(/* 1 */); // Do you love JavaScript?
console.log(/* 2 */); // JavaScript loves you back â¤ï¸
```

- A: `game.next("Yes").value` dhe `game.next().value`
- B: `game.next.value("Yes")` dhe `game.next.value()`
- C: `game.next().value` dhe `game.next("Yes").value`
- D: `game.next.value()` dhe `game.next.value("Yes")`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: C

NjÃ« funksion gjenerues (generator function) "pauzon" ekzekutimin e tij kur sheh fjalÃ«n kyÃ§e `yield`. SÃ« pari, duhet ta lÃ«mÃ« funksionin tÃ« japÃ« vargun "A ju pÃ«lqen JavaScript?", i cili mund tÃ« bÃ«het duke thirrur `game.next().value`.

Ã‡do rresht ekzekutohet derisa tÃ« gjejÃ« fjalÃ«n kyÃ§e tÃ« parÃ« "yield". Ekziston njÃ« fjalÃ« kyÃ§e `yield` nÃ« rreshtin e parÃ« brenda funksionit: ekzekutimi ndalon me yield-in e parÃ«! _Kjo do tÃ« thotÃ« se variabla `PÃ«rgjigja` nuk Ã«shtÃ« pÃ«rcaktuar ende!_

Kur e thÃ«rrasim `game.next("Po").value`, `yield` i mÃ«parshÃ«m zÃ«vendÃ«sohet me vlerÃ«n e parametrave tÃ« kaluar nÃ« funksionin `next()`, `"Yes"` nÃ« kÃ«tÃ« rast. Vlera e ndryshores `PÃ«rgjigja` tani Ã«shtÃ« e barabartÃ« me `"Yes"`. Kushti i deklaratÃ«s if kthehet `false`, dhe `JavaScript loves you back â¤ï¸` printohet.

</p>
</details>

---

###### 72. Cila Ã«shtÃ« vlera e saj?

```javascript
console.log(String.raw`Hello\nworld`);
```

- A: `Hello world!`
- B: `Hello` &nbsp; &nbsp; &nbsp;`world`
- C: `Hello\nworld`
- D: `Hello\n`  &nbsp; &nbsp; &nbsp;`world`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: C

`String.raw` kthen njÃ« varg ku karakteret speciale (`\n`, `\v`, `\t` etj.) injorohen! Vizat e pasme mund tÃ« jenÃ« njÃ« problem pasi mund tÃ« pÃ«rfundoni me diÃ§ka si:

`const path = `C:\Documents\Projects\table.html``

E cila do tÃ« rezultonte nÃ«:

`"C:DocumentsProjects able.html"`

Me `String.raw`, vetÃ«m do e injoronte karakterin special dhe do tÃ« printonte:

`C:\Documents\Projects\table.html`

NÃ« kÃ«tÃ« rast, `Hello\nworld` do tÃ« printohet.

</p>
</details>

---

###### 73. Cila Ã«shtÃ« vlera e saj?

```javascript
async function getData() {
  return await Promise.resolve('I made it!');
}

const data = getData();
console.log(data);
```

- A: `"I made it!"`
- B: `Promise {<resolved>: "I made it!"}`
- C: `Promise {<pending>}`
- D: `undefined`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: C

NjÃ« funksion asinkron gjithmonÃ« kthen njÃ« "promise". `await` duhet tÃ« pres pÃ«r funksionin "promise" te zgjidhjet: njÃ« "promise" nÃ« pritje do tÃ« kthehet kur e thirrim `getData()` nÃ« mÃ«nyrÃ« qÃ« tÃ« vendosim `data` nÃ« tÃ«.

NÃ«se do tÃ« dÃ«shironim tÃ« kemi qasje nÃ« vlerÃ«n e zgjidhur `"I made it"` do tÃ« kishim pÃ«rdorur metodÃ«n `.then()` nÃ« `data`:

`data.then(res => console.log(res))`

Kjo do tÃ« printonte `"I made it!"`

</p>
</details>

---

###### 74. Cila Ã«shtÃ« vlera e saj?

```javascript
function addToList(item, list) {
  return list.push(item);
}

const result = addToList('apple', ['banana']);
console.log(result);
```

- A: `['apple', 'banana']`
- B: `2`
- C: `true`
- D: `undefined`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: B

Metoda `.push()` kthen _gjatÃ«sinÃ«_ e vargut "array" tÃ« ri! MÃ« parÃ«, array pÃ«rmbante njÃ« element (stringun `"banana"`) dhe kishte gjatÃ«sinÃ« `1`. Pasi shtuam stringun `"apple"` nÃ« array, ai do tÃ« pÃ«rmbajÃ« dy elemente dhe do tÃ« ketÃ« gjatÃ«sinÃ« `2`. Kjo kthehet nga funksioni `addToList`.

Metoda `push` modifikon array origjinal. NÃ« qoftÃ«se ju dÃ«shironi tÃ« ktheni _array_ nga funksioni nÃ« vend tÃ« _gjatÃ«sisÃ« sÃ« vargut_, ateherÃ« ju duhet tÃ« ktheni `list` pasi e vendosni `item` nÃ« tÃ«.

</p>
</details>

---

###### 75. Cila Ã«shtÃ« vlera e saj?

```javascript
const box = { x: 10, y: 20 };

Object.freeze(box);

const shape = box;
shape.x = 100;

console.log(shape);
```

- A: `{ x: 100, y: 20 }`
- B: `{ x: 10, y: 20 }`
- C: `{ x: 100 }`
- D: `ReferenceError`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: B

`Object.freeze` e bÃ«n tÃ« pamundur shtimin, largimin ose modifikimin e vetive nÃ« njÃ« objekt (pÃ«rveÃ§ nÃ«se vlera e njÃ« vetie Ã«shtÃ« njÃ« objekt tjetÃ«r).

Kur krijojmÃ« ndryshoren `shape` dhe e vendosim tÃ« barabartÃ« me objektin e ngrirÃ« `box`, `shape` i referohet gjithashtu njÃ« objekti tÃ« ngrirÃ«. Ju mund tÃ« kontrolloni nÃ«se njÃ« objekt Ã«shtÃ« i ngrirÃ« duke pÃ«rdorur `Object.isFrozen`. NÃ« kÃ«tÃ« rast, `Object.isFrozen(shape)` do tÃ« kthehej e vÃ«rtetÃ«, pasi variabla `shape` ka njÃ« referencÃ« pÃ«r njÃ« objekt tÃ« ngrirÃ«.

MeqenÃ«se `shape` Ã«shtÃ« e ngrirÃ« dhe meqenÃ«se vlera e `x` nuk Ã«shtÃ« njÃ« objekt, ne nuk mund tÃ« modifikojmÃ« vetinÃ« `x`. `x` Ã«shtÃ« ende e barabartÃ« me `10` dhe `{ x: 10, y: 20 }` do tÃ« printohet.

</p>
</details>

---

###### 76. Cila Ã«shtÃ« vlera e saj?

```javascript
const { firstName: myName } = { firstName: 'Lydia' };

console.log(firstName);
```

- A: `"Lydia"`
- B: `"myName"`
- C: `undefined`
- D: `ReferenceError`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: D

Duke pÃ«rdorur [sintaksen e funksioneve destruktuese](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment) ne mund tÃ« targetojmÃ« vlerat nga vargjet, ose vetitÃ« nga objektet, nÃ« variabla tÃ« veÃ§anta:

```javascript
const { firstName } = { firstName: 'Lydia' };
// versioni i ES5:
// var firstName = { firstName: 'Lydia' }.firstName;

console.log(firstName); // "Lydia"
```

Gjithashtu, njÃ« veti mund tÃ« targetohet nga njÃ« objekt dhe t'i caktohet njÃ« variableje me njÃ« emÃ«r tÃ« ndryshÃ«m nga vetia e objektit:

```javascript
const { firstName: myName } = { firstName: 'Lydia' };
// versioni i ES5:
// var myName = { firstName: 'Lydia' }.firstName;

console.log(myName); // "Lydia"
console.log(firstName); // Uncaught ReferenceError: firstName is not defined
```

Prandaj, `firstName` nuk ekziston si variabÃ«l, kÃ«shtu qÃ« tentimi pÃ«r tÃ« qasur vlerÃ«n e saj do tÃ« ngrejÃ« njÃ« `ReferenceError`.

**ShÃ«nim:** Kujdes nga vetitÃ« e  `global scope`:

```javascript
const { name: myName } = { name: 'Lydia' };

console.log(myName); // "lydia"
console.log(name); // "" ----- Browser psh. Chrome
console.log(name); // ReferenceError: name is not defined  ----- NodeJS

```

Kurdo qÃ« JavaScript nuk mundet tÃ« gjejÃ« njÃ« varibÃ«l nÃ« _current scope_, ngrihet nÃ« [Scope chain](https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/scope-closures/ch3.md) dhe kÃ«rkon pÃ«r tÃ« dhe nÃ« qoftÃ«se e arrin nivelin mÃ« tÃ« lartÃ« tÃ« shtrirjes (the top-level scope), tÃ« quajtur  __Global scope__, dhe ende nuk e gjen do tÃ« ngrejÃ« `ReferenceError`.

- NÃ« __Browsers__ si _Chrome_, `name` Ã«shtÃ« _vetia e shtrirjes globale e vjetÃ«ruar_. NÃ« kÃ«tÃ« shembull, kodi funksionon brenda _global scope_ dhe nuk ka asnjÃ« variabÃ«l lokale tÃ« pÃ«rcaktuar nga pÃ«rdoruesi pÃ«r `name`, prandaj ai kÃ«rkon _variables/properties_ tÃ« paracaktuara nÃ« shtrirjen globale, nÃ« kÃ«tÃ« rast shfletuesve, ai kÃ«rkon pÃ«rmes objektit `window`, dhe do tÃ« nxjerrÃ« vlerÃ«n [window.name](https://developer.mozilla.org/en-US/docs/Web/API/Window/name) e cila Ã«shtÃ« e barabartÃ« me njÃ« varg __bosh__.
- NÃ« __NodeJS__, nuk ka njÃ« veÃ§ori tÃ« tillÃ« nÃ« objektin `global`, kÃ«shtu qÃ« pÃ«rpjekja pÃ«r tÃ« iu qasur njÃ« variable joekzistente do tÃ« ngrejÃ« njÃ« [ReferenceError](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Not_defined).

</p>
</details>

---

###### 77. A Ã«shtÃ« ky njÃ« funksion i pastÃ«r?

```javascript
function sum(a, b) {
  return a + b;
}
```

- A: Po
- B: Jo

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: A

NjÃ« funksion Ã«shtÃ« gjithmonÃ« funksion i pastÃ«r nÃ«se sa herÃ« qÃ« i kalojmÃ« argumente tÃ« njÃ«jta gjithmonÃ« kthen rezultatin e njÃ«jtÃ«.

Funksioni `sum` _gjithmonÃ«_ kthen tÃ« njÃ«jtin rezultat. NÃ«se i kalojmÃ« `1` dhe `2`, gjithmonÃ« do tÃ« kthejÃ« `3` pa ndonjÃ« efekt anÃ«sorÃ«. NÃ«se i kalojmÃ« `5` dhe `10`, gjithmonÃ« do tÃ« kthejÃ« `15`, e kÃ«shtu me radhÃ«. Ky Ã«shtÃ« definicioni i njÃ« funksioni tÃ« pastÃ«r.

</p>
</details>

---

###### 78.  Cila Ã«shtÃ« vlera e saj?

```javascript
const add = () => {
  const cache = {};
  return num => {
    if (num in cache) {
      return `From cache! ${cache[num]}`;
    } else {
      const result = num + 10;
      cache[num] = result;
      return `Calculated! ${result}`;
    }
  };
};

const addFunction = add();
console.log(addFunction(10));
console.log(addFunction(10));
console.log(addFunction(5 * 2));
```

- A: `Calculated! 20` `Calculated! 20` `Calculated! 20`
- B: `Calculated! 20` `From cache! 20` `Calculated! 20`
- C: `Calculated! 20` `From cache! 20` `From cache! 20`
- D: `Calculated! 20` `From cache! 20` `Error`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: C

Funksioni `add` Ã«shtÃ« njÃ« funksion _memoized_. Me memoizim, ne mund tÃ« ruajmÃ« rezultatet e njÃ« funksioni nÃ« mÃ«nyrÃ« qÃ« tÃ« pÃ«rshpejtojmÃ« ekzekutimin e tij. NÃ« kÃ«tÃ« rast, ne krijojmÃ« njÃ« objekt `cache` qÃ« ruan vlerat e kthyera mÃ« parÃ«.

NÃ«se e thirrim sÃ«rish funksionin `addFunction` me tÃ« njÃ«jtin argument, ai fillimisht kontrollon nÃ«se e ka marrÃ« tashmÃ« atÃ« vlerÃ« nÃ« cache-in e tij. NÃ«se Ã«shtÃ« kÃ«shtu, vlera e caches do tÃ« kthehet, e cila kursen kohÃ«n e ekzekutimit. PÃ«rndryshe, nÃ«se nuk Ã«shtÃ« i ruajtur nÃ« memorie, ai do tÃ« llogarisÃ« vlerÃ«n dhe do ta ruajÃ« atÃ« mÃ« pas.

Ne e thirrim funksionin `addFunction` tre herÃ« me tÃ« njÃ«jtÃ«n vlerÃ«: nÃ« thirrjen e parÃ«, vlera e funksionit kur `num`" Ã«shtÃ« e barabartÃ« me `10` nuk Ã«shtÃ« ruajtur ende nÃ« memorie. KushtÃ«zimi if `num in cache` kthen `false`, dhe blloku else ekzekutohet: `Calculated! 20` printohet dhe vlera e rezultatit i shtohet objektit tÃ« cache-it. `cache` tani duket si `{ 10: 20 }`.

HerÃ«n e dytÃ«, objekti `cache` pÃ«rmban vlerÃ«n qÃ« kthehet pÃ«r `10`. KushtÃ«zimi if `num in cache` kthen `true`, dhe `'From cache! 20'` printohet.

HerÃ«n e tretÃ«, ne kalojmÃ« `5 * 2` te funksioni i cili llogaritet si `10`. Objekti `cache` pÃ«rmban vlerÃ«n qÃ« kthehet pÃ«r `10`. KushtÃ«zimi if `num in cache` kthen `true`, dhe `'From cache! 20' printohet.

</p>
</details>

---

###### 79.  Cila Ã«shtÃ« vlera e saj?

```javascript
const myLifeSummedUp = ['â˜•', 'ğŸ’»', 'ğŸ·', 'ğŸ«'];

for (let item in myLifeSummedUp) {
  console.log(item);
}

for (let item of myLifeSummedUp) {
  console.log(item);
}
```

- A: `0` `1` `2` `3` dhe `"â˜•"` `"ğŸ’»"` `"ğŸ·"` `"ğŸ«"`
- B: `"â˜•"` `"ğŸ’»"` `"ğŸ·"` `"ğŸ«"` dhe `"â˜•"` `"ğŸ’»"` `"ğŸ·"` `"ğŸ«"`
- C: `"â˜•"` `"ğŸ’»"` `"ğŸ·"` `"ğŸ«"` dhe `0` `1` `2` `3`
- D: `0` `1` `2` `3` dhe `{0: "â˜•", 1: "ğŸ’»", 2: "ğŸ·", 3: "ğŸ«"}`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: A

Me unazÃ«n _for-in_, ne mund tÃ« iterojmÃ« nÃ« vetitÃ« _e numÃ«rueshme_. NÃ« njÃ« array, vetitÃ« e numÃ«rueshmÃ« janÃ« "Ã§elÃ«sat" e elementeve tÃ« array, tÃ« cilÃ«t janÃ« nÃ« tÃ« vÃ«rtetÃ« indekset e tij. Mund tÃ« shikoni array si:

`{0: "â˜•", 1: "ğŸ’»", 2: "ğŸ·", 3: "ğŸ«"}`

Ku Ã§elÃ«sat janÃ« vetitÃ« e numÃ«rueshme. `0` `1` `2` `3` printohet.

Me unazÃ«n _for-of_, ne mund tÃ« iterojmÃ« mbi __iterables__. NjÃ« array Ã«shtÃ« njÃ« "iterable". Kur iterojmÃ« mbi array, variabla "item" Ã«shtÃ« e barabartÃ« me elementin mbi tÃ« cilin po iterojmÃ« aktualisht, "â˜•"` `"ğŸ’»"` `"ğŸ·"` `"ğŸ«"` printohet.

</p>
</details>

---

###### 80.  Cila Ã«shtÃ« vlera e saj?

```javascript
const list = [1 + 2, 1 * 2, 1 / 2];
console.log(list);
```

- A: `["1 + 2", "1 * 2", "1 / 2"]`
- B: `["12", 2, 0.5]`
- C: `[3, 2, 0.5]`
- D: `[1, 1, 1]`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: C

Elementet e array mund tÃ« mbajnÃ« Ã§farÃ« vlere. Numra, stringje, objekte, array tÃ« tjerÃ«, null, vlera boolean-e, undefined, dhe shprehje tÃ« tjera si data, funksione dhe kalkulime.

Elementi do tÃ« jetÃ« i barabartÃ« me vlerÃ«n e kthyer. `1 + 2` kthen `3`, `1 * 2` kthen `2` dhe `1 / 2` kthen `0.5`.

</p>
</details>

---

###### 81.  Cila Ã«shtÃ« vlera e saj?

```javascript
function sayHi(name) {
  return `Hi there, ${name}`;
}

console.log(sayHi());
```

- A: `Hi there,`
- B: `Hi there, undefined`
- C: `Hi there, null`
- D: `ReferenceError`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: B

Paraprakisht, argumentet kane vlerÃ«n `undefined`, pÃ«rveÃ§ nÃ« qoftÃ«se ndonjÃ« vlerÃ« i kalohet nÃ« funksion. NÃ« kÃ«tÃ« rast, ne nuk e kaluam ndonjÃ« vlerÃ« pÃ«r argumentin `name`. `name` Ã«shtÃ« e barabartÃ« me `undefined` e cila edhe printohet.

NÃ« ES6, ne mund tÃ« mbishkruajmÃ« kÃ«tÃ« vlerÃ« paraprake `undefined` me parametÃ«r tÃ« definuar paraprakisht. PÃ«r shembull:

`function sayHi(name = "Lydia") { ... }`

NÃ« kÃ«tÃ« rast, nÃ«se ne nuk kalojmÃ« ndonjÃ« vlerÃ« ose e kalojmÃ« `undefined`, `name` do tÃ« ishte gjithmonÃ« i barabartÃ« me stringun `Lydia`.

</p>
</details>

---

###### 82.  Cila Ã«shtÃ« vlera e saj?

```javascript
var status = 'ğŸ˜';

setTimeout(() => {
  const status = 'ğŸ˜';

  const data = {
    status: 'ğŸ¥‘',
    getStatus() {
      return this.status;
    },
  };

  console.log(data.getStatus());
  console.log(data.getStatus.call(this));
}, 0);
```

- A: `"ğŸ¥‘"` and `"ğŸ˜"`
- B: `"ğŸ¥‘"` and `"ğŸ˜"`
- C: `"ğŸ˜"` and `"ğŸ˜"`
- D: `"ğŸ˜"` and `"ğŸ˜"`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: B

Vlera e fjalÃ«s kyÃ§e `this` varet nga vendi ku e pÃ«rdorni. NÃ« njÃ« __metodÃ«__, si metoda `getStatus`, fjala kyÃ§e `this` i referohet _objektit qÃ« i pÃ«rket metoda_. Metoda i pÃ«rket objektit `data`, kÃ«shtu qÃ« `this` i referohet objektit `data`. Kur printojmÃ« `this.status`, vetia `status` nÃ« objektin `data` printohet, qÃ« Ã«shtÃ« `"ğŸ¥‘"`.

Me metodÃ«n `call`, ne mund tÃ« ndryshojmÃ« objektin tÃ« cilit i referohet fjala kyÃ§e `this`. NÃ« __funksione__, fjala kyÃ§e `this` i referohet _objektit tÃ« cilit i pÃ«rket funksioni_. Ne deklaruam funksionin `setTimeout` nÃ« objektin _global_, kÃ«shtu qÃ« brenda funksionit `setTimeout`, fjala kyÃ§e `this` i referohet objektit _global_. NÃ« objektin global, ekziston njÃ« variabÃ«l e quajtur _status_ me vlerÃ«n `"ğŸ˜"`. Kur printoni `this.status`, `"ğŸ˜"` printohet.

</p>
</details>

---

###### 83.  Cila Ã«shtÃ« vlera e saj?

```javascript
const person = {
  name: 'Lydia',
  age: 21,
};

let city = person.city;
city = 'Amsterdam';

console.log(person);
```

- A: `{ name: "Lydia", age: 21 }`
- B: `{ name: "Lydia", age: 21, city: "Amsterdam" }`
- C: `{ name: "Lydia", age: 21, city: undefined }`
- D: `"Amsterdam"`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: A

0VendosÃ«m variablÃ«n `city` tÃ« barabartÃ« me vlerÃ«n e vetisÃ« tÃ« quajtur `city` nÃ« objektin `person.`. NÃ« objekt nuk ka ndonjÃ« veti e cila quhet `city`, kÃ«shtu qÃ« variabla `city` ka vlerÃ«n `undefined`.

Vini re, ne _nuk_ jemi duke iu referuar objektit `person`! Ne vetÃ«m e vendosÃ«m variablÃ«n `city` tÃ« barabartÃ« me vlerÃ«n aktuale tÃ« vetisÃ« `city` nÃ« objektin `person`.

Pastaj, ne vendosÃ«m `city` tÃ« barabartÃ« me stringun `"Amsterdam"`. Kjo nuk e ndryshon objektin person: nuk ka ndonjÃ« referencÃ« tek ai objekt.

Kur printojmÃ« objektin `person`. objekti i pamodifikuar kthehet.

</p>
</details>

---

###### 84.  Cila Ã«shtÃ« vlera e saj?

```javascript
function checkAge(age) {
  if (age < 18) {
    const message = "Sorry, you're too young.";
  } else {
    const message = "Yay! You're old enough!";
  }

  return message;
}

console.log(checkAge(21));
```

- A: `"Sorry, you're too young."`
- B: `"Yay! You're old enough!"`
- C: `ReferenceError`
- D: `undefined`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: C

Variablat e deklaruara me fjalÃ«t kyÃ§e `const` dhe `let` janÃ« tÃ« qasshme vetÃ«m nÃ« bllokun ku shtrihen (_block-scoped_). NjÃ« bllok quhet gjithÃ§ka qÃ« gjendet brenda kllapave gjarpÃ«rore (`{ }`). NÃ« kÃ«tÃ« rast, kllapat gjarpÃ«rore e deklarimeve if/else. Nuk mund tÃ« i referencohemi njÃ« variable jashtÃ« bllokut ku Ã«shtÃ« deklaruar, sepse do tÃ« ngrihet ReferenceError.

</p>
</details>

---

###### 85. Ã‡farÃ« lloj informacioni do tÃ« printohet?

```javascript
fetch('https://www.website.com/api/user/1')
  .then(res => res.json())
  .then(res => console.log(res));
```

- A: Rezultati i metodÃ«s `fetch`.
- B: Rezultati i thirrjes sÃ« dytÃ« sÃ« metodÃ«s `fetch`.
- C: Rezultati i callback paraprak `.then()`
- D: Do tÃ« jetÃ« gjithmonÃ« undefined.

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: C

Vlera e `res` nÃ« `.then` tÃ« dytÃ« do tÃ« jetÃ« e barabartÃ« me vlerÃ«n e kthyer nÃ« `.then` paraprak. You mund tÃ« bÃ«ni `.then`-Ã« tÃ« tjerÃ« si nÃ« shembull, ku vlera do tÃ« kalohet nÃ« trajtuesin tjetÃ«r.

</p>
</details>

---

###### 86. Cili opsion do tÃ« mundÃ«sojÃ« qÃ« tÃ« vendosim `hasName` tÃ« barabartÃ« me `true`, nuk mund tÃ« kaloni si argument vlerÃ«n `true`?

```javascript
function getName(name) {
  const hasName = //
}
```

- A: `!!name`
- B: `name`
- C: `new Boolean(name)`
- D: `name.length`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: A

Me `!!name`, ne vendosim nÃ« qoftÃ«se vlera e `name` Ã«shtÃ« e vÃ«rtetÃ« osÃ« false. NÃ«se "name" Ã«shtÃ« e vÃ«rtetÃ«, pÃ«r tÃ« cilÃ«n duam tÃ« testojmÃ«, `!name` kthen `false`. `!false` (e cila Ã«shtÃ« vlera tÃ« cilÃ«n `!!name` ka) kthen `true`.

Kur vendosim `hasName` tÃ« barabartÃ« me `name`, ju vendosni `hasName` tÃ« barabartÃ« me Ã§do vlerÃ« tÃ« cilÃ«n e kaloni si arguemnt tek funksioni `getName`, jo vlera boolean-e `true`.

`new Boolean(true)` kthen njÃ« mbÃ«shtjellÃ«s sÃ« objektit, jo vetÃ« vlerÃ«n boolean-e.

`name.length` kthen gjatÃ«sinÃ« e argumentit tÃ« kaluar, jo nÃ« qoftÃ«se Ã«shtÃ« `true` ose jo.

</p>
</details>

---

###### 87. Cila Ã«shtÃ« vlera e saj?

```javascript
console.log('I want pizza'[0]);
```

- A: `"""`
- B: `"I"`
- C: `SyntaxError`
- D: `undefined`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: B

NÃ« mÃ«nyrÃ« qÃ« tÃ« marrim karakterin nÃ« njÃ« indeks specifik nÃ« string, mund tÃ« pÃ«rdorimin notacionin e kllapave tÃ« mÃ«dha "[]". Karakteri i parÃ« nÃ« string ka indeksin 0, dhe kÃ«shtu me rradhÃ«. NÃ« kÃ«tÃ« rast, ne duam tÃ« marrim elementin me indeks 0, karakterin `"I"`, i cili printohet.

Vini re se kjo metodÃ« nuk suportohet nÃ« IE7 e mÃ« poshtÃ«. NÃ« kÃ«tÃ« rast pÃ«rdorni `.charAt()`.

</p>
</details>

---

###### 88. Cila Ã«shtÃ« vlera e saj?

```javascript
function sum(num1, num2 = num1) {
  console.log(num1 + num2);
}

sum(10);
```

- A: `NaN`
- B: `20`
- C: `ReferenceError`
- D: `undefined`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: B

Ne mund tÃ« pÃ«rcaktojmÃ« njÃ« vlerÃ« paraprakisht tÃ« barabartÃ« me ndonjÃ« parametÃ«r tjetÃ«r tÃ« funksionit, pÃ«rderisa ato janÃ« tÃ« deinuara pÃ«rpara vlerÃ«s sÃ« paradefinuar. Ne e kalojmÃ« vlerÃ«n `10` tek funksioni `sum`. NÃ«se funksioni `sum` pranon vetÃ«m njÃ« argument, do tÃ« thotÃ« se vlera pÃ«r `num2` nuk Ã«shtÃ« kaluar, dhe vlera e `num1` Ã«shtÃ« e barabartÃ« me vlerÃ«n `10` e cila ka kaluar si argument nÃ« kÃ«tÃ« rast. Vlera e paradefinuar e `num2` Ã«shtÃ« vlera e `num1`, e cila Ã«shtÃ« `10`. `num1 + num2` kthen `20`.

NÃ« qoftÃ«se provoni tÃ« vendosni njÃ« vlerÃ« tÃ« paradefinuar tÃ« barabartÃ« me njÃ« parametÃ«r i cili definohet _pastaj_ (nÃ« tÃ« djathÃ«), vlera e parametrit nuk do tÃ« jetÃ« e inicializuar ende, e cila do tÃ« kthejÃ« njÃ« error.

</p>
</details>

---

###### 89. Cila Ã«shtÃ« vlera e saj?

```javascript
// module.js
export default () => 'Hello world';
export const name = 'Lydia';

// index.js
import * as data from './module';

console.log(data);
```

- A: `{ default: function default(), name: "Lydia" }`
- B: `{ default: function default() }`
- C: `{ default: "Hello world", name: "Lydia" }`
- D: Global object of `module.js`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: A

Me sintaksÃ«n `import * as name`, ne importojmÃ« _tÃ« gjithÃ« eksportet_ nga fajlli `module.js` nÃ« `index.js` si njÃ« objekt i ri i cili quhet `data` i cili krijohet. NÃ« `module.js`, gjenden dy eksporta: eksporti i paracaktuar dhe njÃ« eksport i emÃ«rtuar. Eksporti i paracaktuar Ã«shtÃ« funksion i cili kthen stringun `Hello World`, dhe esksporti i emÃ«ruar Ã«shtÃ« variabla e quajtur `name` e cila ka vlerÃ«n e stringut `"Lydia"`.

Objekti `data` ka njÃ« veti `default` pÃ«r eksportin e paracaktuar, vetitÃ« e tjera kanÃ« emrat e eksporteve tÃ« emÃ«ruara dhe vlerat e tyre korrespoduese.

</p>
</details>

---

###### 90. Cila Ã«shtÃ« vlera e saj?

```javascript
class Person {
  constructor(name) {
    this.name = name;
  }
}

const member = new Person('John');
console.log(typeof member);
```

- A: `"class"`
- B: `"function"`
- C: `"object"`
- D: `"string"`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: C

Klasat janÃ« si sintaksÃ« qÃ« Ã«shtÃ« krijuar pÃ«r t'i bÃ«rÃ« gjÃ«rat mÃ« tÃ« lehta pÃ«r t'u lexuar ose pÃ«r t'u shprehur pÃ«r funksionet e konstruktorÃ«ve. Ekuivante e klasÃ«s `Person` si funksion kontruktorÃ« do tÃ« ishte:

```javascript
function Person(name) {
  this.name = name;
}
```

Thirrja e njÃ« konstruktori me `new` rezulton nÃ« krijimin e njÃ« instance tÃ« `Person`, `typeof` do tÃ« kthejÃ« `"object"` pÃ«r njÃ« instancÃ«. `typeof member` kthen `"object"`.

</p>
</details>

---

###### 91. Cila Ã«shtÃ« vlera e saj?

```javascript
let newList = [1, 2, 3].push(4);

console.log(newList.push(5));
```

- A: `[1, 2, 3, 4, 5]`
- B: `[1, 2, 3, 5]`
- C: `[1, 2, 3, 4]`
- D: `Error`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: D

Metoda `.push` kthen _gjatÃ«sinÃ« e re_ tÃ« array, jo vetÃ« array! Duke vendosur `newList` tÃ« barabartÃ« me `[1, 2, 3].push(4)`, e vendosim `newList` tÃ« barabartÃ« me gjatÃ«sinÃ« e re tÃ« array: `4`.

Pastaj, ne provojmÃ« tÃ« pÃ«rdorim metodÃ«n `.push`  nÃ« `newList`. MeqenÃ«se `newList` Ã«shtÃ« vlera numerike e `4` ne nuk mund tÃ« pÃ«rdorim metodÃ«n `.push`: do tÃ« ngrihet TypeError.

</p>
</details>

---

###### 92. Cila Ã«shtÃ« vlera e saj?

```javascript
function giveLydiaPizza() {
  return 'Here is pizza!';
}

const giveLydiaChocolate = () =>
  "Here's chocolate... now go hit the gym already.";

console.log(giveLydiaPizza.prototype);
console.log(giveLydiaChocolate.prototype);
```

- A: `{ constructor: ...}` `{ constructor: ...}`
- B: `{}` `{ constructor: ...}`
- C: `{ constructor: ...}` `{}`
- D: `{ constructor: ...}` `undefined`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: D

Funskionet e rregullta, tÃ« tillÃ« si funksioni `giveLydiaPizza`, kanÃ« vetinÃ« `prototype`, e cila Ã«shtÃ« njÃ« objekt (veti e objektit) me veti `constructor`. Funksionet shigjetÃ« (arrow functions) sidoqoftÃ«, tÃ« tilla si funskioni `giveLydiaChocolate`, nuk e kanÃ« kÃ«tÃ« veti `prototype`. Kur tentojmÃ« tÃ« i qasemi vetisÃ« `prototype` duke pÃ«dorur `giveLydiaChocolate.prototype` do tÃ« na kthehet `undefined`.

</p>
</details>

---

###### 93. Cila Ã«shtÃ« vlera e saj?

```javascript
const person = {
  name: 'Lydia',
  age: 21,
};

for (const [x, y] of Object.entries(person)) {
  console.log(x, y);
}
```

- A: `name` `Lydia` and `age` `21`
- B: `["name", "Lydia"]` and `["age", 21]`
- C: `["name", "age"]` and `undefined`
- D: `Error`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: A

`Object.entries(person)` kthen njÃ« array me array tÃ« ndÃ«rthurur, i cili pÃ«rmban Ã§elÃ«sat dhe objektet:

`[ [ 'name', 'Lydia' ], [ 'age', 21 ] ]`

PÃ«rdorimi i unazÃ«s `for-of`, na mundÃ«son iterimin nÃ« secilin element nÃ« array, dhe nÃ«n array nÃ« kÃ«tÃ« rast. Ne mund tÃ« destrukturojmÃ« nÃ«n array menjÃ«herÃ« nÃ« unazÃ«n for-of, duke pÃ«rdorur `const [x, y]`. `x` Ã«shtÃ« e barabartÃ« me elementin e parÃ« nÃ« nÃ«n array, `y` Ã«shtÃ« e barabartÃ« me elementin e dytÃ« nÃ« nÃ«n array.

NÃ«n array i parÃ« Ã«shtÃ« `["name", "Lydia"]`, me `x` tÃ« barabartÃ« me `"name"`, dhe `y` tÃ« barabartÃ« me `"Lydia"`, e cila printohet. NÃ«n array i dytÃ« Ã«shtÃ« `["age", 21 ]`, me `x` tÃ« barabartÃ« me `"age"`, dhe `y` tÃ« barabartÃ« me `21`, e cila printohet.

</p>
</details>

---

###### 94. Cila Ã«shtÃ« vlera e saj?

```javascript
function getItems(fruitList, ...args, favoriteFruit) {
  return [...fruitList, ...args, favoriteFruit]
}

getItems(["banana", "apple"], "pear", "orange")
```

- A: `["banana", "apple", "pear", "orange"]`
- B: `[["banana", "apple"], "pear", "orange"]`
- C: `["banana", "apple", ["pear"], "orange"]`
- D: `SyntaxError`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: D

`...args` Ã«shtÃ« "rest" parametÃ«r. Vlera e "rest" parametrit Ã«shtÃ« njÃ« array i cili pÃ«rmban tÃ« gjitha argumentet e mbetura, **dhe mund tÃ« jetÃ« vetÃ«m parametri i fundit**! NÃ« kÃ«tÃ« shembull, "rest" parametri ishte parametri i dytÃ«. Kjo nuk Ã«shtÃ« e mundur, dhe do tÃ« ngrisÃ« gabim sintaksorÃ«.

```javascript
function getItems(fruitList, favoriteFruit, ...args) {
  return [...fruitList, ...args, favoriteFruit];
}

getItems(['banana', 'apple'], 'pear', 'orange');
```

Shembulli i mÃ«sipÃ«rm funskionon. Do tÃ« kthejÃ« array `[ 'banana', 'apple', 'orange', 'pear' ]`

</p>
</details>

---

###### 95. Cila Ã«shtÃ« vlera e saj?

```javascript
function nums(a, b) {
  if (a > b) console.log('a is bigger');
  else console.log('b is bigger');
  return
  a + b;
}

console.log(nums(4, 2));
console.log(nums(1, 2));
```

- A: `a is bigger`, `6` dhe `b is bigger`, `3`
- B: `a is bigger`, `undefined` dhe `b is bigger`, `undefined`
- C: `undefined` dhe `undefined`
- D: `SyntaxError`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: B

NÃ« JavaScript, nuk e duhet tÃ« e shkruajmÃ« pikÃ«presjen `;` nÃ« mÃ«nyrÃ« eksplicite, sidoqoftÃ« makina e JavaScript prapÃ« i vendos ato pas deklarimeve. Kjo quhet __Automatic Semicolon Insertion__ (vendosja e pikÃ«presjes automatikisht). NjÃ« deklaratÃ« pÃ«r shembull mund tÃ« jetÃ« variabla, ose fjalÃ«t kyÃ§e si `throw`, `return`, `break` etj.

NÃ« kÃ«tÃ« rast, ne shkruajtÃ«m deklaratÃ«n `return`, dhe vlerÃ«n tjetÃ«r `a + b` nÃ« rresht tÃ« ri. SidoqoftÃ«, meqenÃ«se Ã«shtÃ« rresht i ri, makina nuk e di se nÃ« tÃ« vÃ«rtetÃ« ajo Ã«shtÃ« vlera qÃ« ne po dÃ«shirojmÃ« tÃ« kthejmÃ«. NÃ« vend se tÃ« e llogarisÃ« nÃ« atÃ« mÃ«nyrÃ«, nÃ« mÃ«nyrÃ« automatike vendoset `return`. Kjo mund tÃ« shikohet edhe si kjo sintaksÃ«:

```javascript
return;
a + b;
```

Kjo do tÃ« thotÃ« se `a + b` nuk arrihet asnjÃ«herÃ«, meqenÃ«se funksioni ndalon ekzekutimin pas fjalÃ«s kyÃ§e `return`. NÃ«se asnjÃ« vlerÃ« nuk kthehet si nÃ« kÃ«tÃ« rast, funksioni kthen `undefined`. Vini re se nuk ka ndonjÃ« pÃ«rfshirje automatike pas deklarimit `if/else`

</p>
</details>

---

###### 96. Cila Ã«shtÃ« vlera e saj?

```javascript
class Person {
  constructor() {
    this.name = 'Lydia';
  }
}

Person = class AnotherPerson {
  constructor() {
    this.name = 'Sarah';
  }
};

const member = new Person();
console.log(member.name);
```

- A: `"Lydia"`
- B: `"Sarah"`
- C: `Error: cannot redeclare Person`
- D: `SyntaxError`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: B

Ne mund tÃ« iu shoqÃ«rojmÃ« klasave konstruktorÃ«t e tjerÃ« tÃ« klasave/funksioneve. NÃ« kÃ«tÃ« rast, ne vendosim `Person` tÃ« barabartÃ« me `AnotherPerson`. Emri nÃ« kÃ«tÃ« konstruktor Ã«shtÃ« `Sarah`, kÃ«shtu qÃ« vetia e emrit nÃ« instancÃ«n e re `Person`, `member` Ã«shtÃ« `â€œSarahâ€`.

</p>
</details>

---

###### 97. Cila Ã«shtÃ« vlera e saj?

```javascript
const info = {
  [Symbol('a')]: 'b',
};

console.log(info);
console.log(Object.keys(info));
```

- A: `{Symbol('a'): 'b'}` dhe `["{Symbol('a')"]`
- B: `{}` dhe `[]`
- C: `{ a: "b" }` dhe `["a"]`
- D: `{Symbol('a'): 'b'}` dhe `[]`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: D

NjÃ« Symbol nuk Ã«shtÃ« i _numÃ«rueshÃ«m_. Metoda Object.keys kthen tÃ« gjithÃ« Ã§elÃ«sat e _numÃ«rueshÃ«m nÃ« njÃ« objekt. Symbol nuk do tÃ« jetÃ« i dukshÃ«m, dhe njÃ« array i zbrazÃ«t do tÃ« kthehet. Kur e printojmÃ« objektin nÃ« tÃ«rÃ«si, tÃ« gjitha vetitÃ« janÃ« tÃ« dukshme, edhe ato tÃ« cilat nuk janÃ« te numÃ«rueshme.

Kjo Ã«shtÃ« vetÃ«m njÃ« nga shumÃ« vetitÃ« e symbol, pÃ«rveÃ§ pÃ«rfaqÃ«simit tÃ« njÃ« vlere krejtÃ«sisht unike (e cila parandalon konflikt  nÃ« emÃ«rtim tÃ« objekteve, pÃ«r shembull kur punoni me 2 librari qÃ« duan tÃ« shtojnÃ« vetitÃ« nÃ« tÃ« njÃ«jtin objekt), ju gjithashtu mund tÃ« "fshehni" vetitÃ« e objekteve nÃ« kÃ«tÃ« mÃ«nyrÃ« (edhe pse jo plotÃ«sisht. Ju mund t'i qaseni simboleve duke pÃ«rdorur metodÃ«n `Object.getOwnPropertySymbols()`).

</p>
</details>

---

###### 98. Cila Ã«shtÃ« vlera e saj?

```javascript
const getList = ([x, ...y]) => [x, y]
const getUser = user => { name: user.name, age: user.age }

const list = [1, 2, 3, 4]
const user = { name: "Lydia", age: 21 }

console.log(getList(list))
console.log(getUser(user))
```

- A: `[1, [2, 3, 4]]` and `SyntaxError`
- B: `[1, [2, 3, 4]]` and `{ name: "Lydia", age: 21 }`
- C: `[1, 2, 3, 4]` and `{ name: "Lydia", age: 21 }`
- D: `Error` and `{ name: "Lydia", age: 21 }`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: A

Funksioni `getList` merr njÃ« array si argument. Brenda kllapave tÃ« funksionit `getList`, ne e destrukturojmÃ« ketÃ« array nÃ« mÃ«nyrÃ«n e duhur. Kjo mund tÃ« shihet edhe si:

`[x, ...y] = [1, 2, 3, 4]`

Me "rest" parametrin `...y`, ne i vendosim argumentet "e mbetura" nÃ« njÃ« array. Argumentet e mbetura janÃ« `2`, `3` dhe `4` nÃ« kÃ«tÃ« rast. Vlera e `y` Ã«shtÃ« njÃ« array, i cili i pÃ«rmban tÃ« gjithÃ« parametrat e mbetur. Vlera e `x` Ã«shtÃ« e barabartÃ« me `1` nÃ« kÃ«tÃ« rast kur e printojmÃ« `[x, y]`, printohet `[1, [2, 3, 4]]`.

Funskioni `getUser` merr njÃ« objekt. Me funksionet shigjetÃ« (arrow function), ne nuk kemi nevojÃ« tÃ« shkruajmÃ« kllapat gjarpÃ«rore nÃ«se vetÃ«m dÃ«shirojmÃ« tÃ« kthejmÃ« njÃ« vlerÃ«. SidoqoftÃ«, nÃ«se dÃ«shironi qÃ« nÃ« mÃ«nyrÃ« instante tÃ« ktheni njÃ« objekt nga njÃ« arrow funksion, mund tÃ« e shkruani brenda kllapave tÃ« vogla "()", pÃ«rndryshe Ã§do gjÃ« mes dy kllapave do tÃ« interpretohet si njÃ« deklaratÃ« blloku. NÃ« kÃ«tÃ« rast kodi nÃ« mes tÃ« kllapave nuk Ã«shtÃ« kod valid i JavaScript, kÃ«shtu qÃ« do tÃ« ngrihet `SyntaxError`.

Funskioni i meposhtÃ«m do tÃ« kthente njÃ« objekt:

`const getUser = user => ({ name: user.name, age: user.age })`

</p>
</details>

---

###### 99. Cila Ã«shtÃ« vlera e saj?

```javascript
const name = 'Lydia';

console.log(name());
```

- A: `SyntaxError`
- B: `ReferenceError`
- C: `TypeError`
- D: `undefined`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: C

Variabla `name` mban vlerÃ«n e njÃ« stringu, i cili nuk Ã«shtÃ« funksion, prandaj nuk mund tÃ« thirret si i tillÃ«.

TypeErrors do tÃ« ngrihen kur njÃ« vlerÃ« nuk Ã«shtÃ« e tipit qÃ« pritet. JavaScript pret qÃ« `name` tÃ« jetÃ« njÃ« funksion meqenÃ«se po provojmÃ« tÃ« e thirrim atÃ«. SidoqoftÃ« Ã«shtÃ« njÃ« string, prandaj do tÃ« marrim TypeError: "name" nuk Ã«shtÃ« njÃ« funksion.

SyntaxErrors do tÃ« ngrihen kur ne shÃ«nojmÃ« diÃ§ka e cila nuk Ã«shtÃ« valide nÃ« JavaScript, pÃ«r shembull kur e shÃ«nojmÃ« fjalÃ«n `return` si `retrun`.
ReferenceErrors ngrihen kur Javascript-i nuk Ã«shtÃ« nÃ« gjendje tÃ« gjejÃ« referencÃ« tek njÃ« vlerÃ« tÃ« cilÃ«n ne provojmÃ« tÃ« i qasemi.

</p>
</details>

---

###### 100. Cila Ã«shtÃ« vlera nÃ« dalje?

```javascript
// ğŸ‰âœ¨ Kjo Ã«shtÃ« pytja jonÃ« e 100! âœ¨ğŸ‰

const output = `${[] && 'Im'}possible!
You should${'' && `n't`} see a therapist after so much JavaScript lol`;
```

- A: `possible! You should see a therapist after so much JavaScript lol`
- B: `Impossible! You should see a therapist after so much JavaScript lol`
- C: `possible! You shouldn't see a therapist after so much JavaScript lol`
- D: `Impossible! You shouldn't see a therapist after so much JavaScript lol`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: B

`[]` Ã«shtÃ« vlerÃ« "truthy". Me operatorin `&&`, vlera nÃ« anÃ«n e djathtÃ« do tÃ« kthehet nÃ«se vlera nÃ« anÃ«n e majtÃ« Ã«shtÃ« vlerÃ« "truthy". NÃ« kÃ«tÃ« rast, vlera nÃ« anÃ«n e majtÃ« `[]` Ã«shtÃ« vlerÃ« "truthy" prandaj `"Im"` do tÃ« kthehet.

`""` Ã«shtÃ« vlerÃ« "falsy". NÃ«sÃ« ana e majtÃ« Ã«shtÃ« falsy, asgjÃ« nuk kthehet. `n't` nuk do tÃ« kthehet.

</p>
</details>

---

###### 101. Cila Ã«shtÃ« vlera nÃ« dalje?

```javascript
const one = false || {} || null;
const two = null || false || '';
const three = [] || 0 || true;

console.log(one, two, three);
```

- A: `false` `null` `[]`
- B: `null` `""` `true`
- C: `{}` `""` `[]`
- D: `null` `null` `true`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: C

Me operatorin `||`, ne mund tÃ« kthejmÃ« vlerÃ«n e parÃ« "truthy" tÃ« operandit. NÃ«se tÃ« gjitha vlerat janÃ« "falsy", operandi i fundit do tÃ« kthehet.

`(false || {} || null)`: objekti i zbrazÃ«t `{}` Ã«shtÃ« vlerÃ« "truthy". Ky Ã«shtÃ« i pari dhe i vetmi vlerÃ« "truthy", i cili kthehet. `one` Ã«shtÃ« i barabartÃ« me `{}`.

`(null || false || "")`: tÃ« gjithÃ« operandÃ«t janÃ« vlera "falsy". Kjo do tÃ« thotÃ« se operandi i fundit, `""` do tÃ« kthehet. `two` Ã«shtÃ« i barabartÃ« me `""`.

`([] || 0 || "")`: array i zbrazÃ«t `[]` Ã«shtÃ« vlerÃ« "truthy". Kjo Ã«shtÃ« vlera e parÃ« "truthy" e cila kthehet. `three` Ã«shtÃ« e barabartÃ« me `[]`.

</p>
</details>

---

###### 102. Cila Ã«shtÃ« vlera nÃ« dalje?

```javascript
const myPromise = () => Promise.resolve('I have resolved!');

function firstFunction() {
  myPromise().then(res => console.log(res));
  console.log('second');
}

async function secondFunction() {
  console.log(await myPromise());
  console.log('second');
}

firstFunction();
secondFunction();
```

- A: `I have resolved!`, `second` and `I have resolved!`, `second`
- B: `second`, `I have resolved!` and `second`, `I have resolved!`
- C: `I have resolved!`, `second` and `second`, `I have resolved!`
- D: `second`, `I have resolved!` and `I have resolved!`, `second`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: D

Me njÃ« premtim, nÃ« thelb themi _DÃ«shiroj ta ekzekutoj kÃ«tÃ« funksion, por do tÃ« e lÃ« mÃ«njanÃ« pÃ«r momentin ndÃ«rsa Ã«shtÃ« duke u ekzekutuar pasi kjo mund tÃ« marrÃ« pak kohÃ«. VetÃ«m kur njÃ« vlerÃ« e caktuar zgjidhet (ose refuzohet) dhe kur "call stack" Ã«shtÃ« bosh, unÃ« dua ta pÃ«rdor kÃ«tÃ« vlerÃ«._

Ne mund tÃ« marrim kÃ«tÃ« rezultat me tÃ« dy: `.then` dhe fjalÃ«n kyÃ§e `await` nÃ« `async` funksione. Edhe pse mund tÃ« marrim vlerÃ«n e 'promise' me tÃ« dy `.then` dhe `await` ato funksionojnÃ« pak mÃ« ndryshe.

NÃ« funksionin e parÃ« `firstFunction`, nÃ« njÃ« mÃ«nyrÃ« e vendosim funksionin 'myPromise' mÃ«njanÃ« pÃ«rgjatÃ« ekzekutimit, por ne e vazhdojmÃ« ekzekutimin e kodit tjetÃ«r, i cili nÃ« kÃ«tÃ« rast Ã«shtÃ« `console.log('second')`. Pastaj, funksioni zgjidhet me stringun `I have resolved`, i cili pastaj printohet pasi qÃ« e sheh se call stack Ã«shtÃ« i zbrazÃ«t.

Me fjalÃ«n kyÃ§e `secondFunction`, nÃ« tÃ« vÃ«rtetÃ« e pauzojmÃ« ekzekutimin e funksionit async derisa vlera tÃ« zgjidhet pÃ«rpara se tÃ« vazhdojmÃ« tek rreshti tjetÃ«r.

Kjo do tÃ« thotÃ« se pret pÃ«r `myPromise` tÃ« zgjidhet me vlerÃ«n `I have resolved`, dhe pasi ajo tÃ« ndodhÃ« ne vazhdojmÃ« ne rreshtin e ardhshÃ«m: `second` do tÃ« printohet.

</p>
</details>

---

###### 103. Cila Ã«shtÃ« vlera nÃ« dalje?

```javascript
const set = new Set();

set.add(1);
set.add('Lydia');
set.add({ name: 'Lydia' });

for (let item of set) {
  console.log(item + 2);
}
```

- A: `3`, `NaN`, `NaN`
- B: `3`, `7`, `NaN`
- C: `3`, `Lydia2`, `[object Object]2`
- D: `"12"`, `Lydia2`, `[object Object]2`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: C

Operatori `+` nuk pÃ«rdoret vetÃ«m vetÃ«m pÃ«r tÃ« mbledhur vlerat numberike, por mund tÃ« e pÃ«rdorim pÃ«r bashkimin e stringjeve. Sa herÃ« qÃ« makina e JavaScript e vÃ«ren se njÃ« ose mÃ« shumÃ« vlera nuk janÃ« numra, e shndÃ«rron numrin nÃ« string.

Ne fillim Ã«shtÃ« `1` i cili Ã«shtÃ« vlerÃ« numerike. `1 + 2` kthen numrin 3.

MegjithatÃ«, vlera e dytÃ« Ã«shtÃ« string `"Lydia"`. `"Lydia"` Ã«shtÃ« string dhe `2` Ã«shtÃ« numÃ«r: `2` shndÃ«rrohet nÃ« string. `"Lydia"` dhe `"2"` bashkohen, dhe kjo rezulton nÃ« stringun `"Lydia2"`.

`{ name: "Lydia"}` Ã«shtÃ« objekt. Nuk Ã«shtÃ« as numÃ«r as objekt Ã«shtÃ« string, prandaj i konsideron si stringje tÃ« dyja. Sa herÃ« qÃ« i konsiderojmÃ« si stringje objektet e zakonshme, behet `"[object Object"]`.`"[object Object"]` bashkohet me `"2"` dhe bÃ«het `"[object Object]2"`.

</p>
</details>

---

###### 104. Cila Ã«shtÃ« vlera e saj?

```javascript
Promise.resolve(5);
```

- A: `5`
- B: `Promise {<pending>: 5}`
- C: `PromiseÂ {<fulfilled>: 5}`
- D: `Error`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: C

Ne mund tÃ« kalojmÃ« qfarÃ«do vlere qÃ« duam te `Promise.resolve`, 'promise' ose 'jo-promise'. Metoda vetÃ« kthen njÃ« 'promise' e cila zgjidhet me vlerÃ«n (`fulfilled`). NÃ«se i kaloni njÃ« funksion tÃ« zakonshÃ«m, do tÃ« zgjidhet njÃ« promise me njÃ« vlerÃ« tÃ« zakonshme. NÃ«se i kaloni njÃ« 'promise' si argument, do tÃ« zgjidhjet njÃ« promise me vlerÃ«n e zgjidhur me vlerÃ«n qÃ« i kalohet si promise.

NÃ« kÃ«tÃ« rast, ne vetÃ«m i kaluam si argument vlerÃ«n numerike `5`. Kthen promise tÃ« zgjidhur me vlerÃ« `5`.

</p>
</details>

---

###### 105. Cila Ã«shtÃ« vlera e saj?

```javascript
function compareMembers(person1, person2 = person) {
  if (person1 !== person2) {
    console.log('Not the same!');
  } else {
    console.log('They are the same!');
  }
}

const person = { name: 'Lydia' };

compareMembers(person);
```

- A: `Not the same!`
- B: `They are the same!`
- C: `ReferenceError`
- D: `SyntaxError`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: B

Objektet vendosen si argumente nÃ« bazÃ« tÃ« referencÃ«s sÃ« tyre. Kur i kontrollojmÃ« objektet me operatorin pÃ«r barazim strikt (`===`), ne po kontorllojmÃ« referencÃ«n e tyre.

Ne e paracaktuam vlerÃ«n e  `person2` tÃ« barabartÃ« me objektin `person`, dhe e kaluam objektin `person` si vlerÃ« tÃ« `person1`.

Kjo do tÃ« thotÃ« qÃ« tÃ« dy vlerat kanÃ« referencÃ« tÃ« e njejta hapÃ«sirÃ« memorike, dhe kÃ«shtu ato janÃ« tÃ« barabarta.

Blloku i kodit nÃ« deklarimin `else` ekzekutohet dhe `They are the same!` printohet.

</p>
</details>

---

###### 106. Cila Ã«shtÃ« vlera e saj?

```javascript
const colorConfig = {
  red: true,
  blue: false,
  green: true,
  black: true,
  yellow: false,
};

const colors = ['pink', 'red', 'blue'];

console.log(colorConfig.colors[1]);
```

- A: `true`
- B: `false`
- C: `undefined`
- D: `TypeError`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: D

NÃ« JavaScript, kemi dy mÃ«nyra pÃ«r tÃ« iu qasur vetive tÃ« njÃ« objekti: notacioni me kllapa tÃ« mÃ«dha "[]" ose notacioni me pikÃ« ".". NÃ« kÃ«tÃ« shembull ne po e perdorim notacionin (`colorConfig.colors`) nÃ« vend tÃ« notacionit me kllapÃ« (`colorConfig["colors"]`).

Me notacionin me pikÃ«, JavaScript provon tÃ« gjejÃ« veti nÃ« objekt me saktÃ«sisht tÃ« njejtin emÃ«r. NÃ« kÃ«tÃ« shembull, JavaScript provon tÃ« gjejÃ« njÃ« veti e cila quhet `colors` nÃ« objektin `colorConfig`. Nuk ka ndonjÃ« veti tÃ« quajtur `colors`, prandaj kjo do tÃ« kthejÃ« `undefined`. Pastaj ne provojmÃ« tÃ« i qasemi vlerÃ«s sÃ« elementit tÃ« parÃ« ne array duke pÃ«rdorur `[1]`. Nuk mund tÃ« e bÃ«jmÃ« kÃ«tÃ« nÃ« vlerÃ«n e cila Ã«shtÃ« `undefined`, prandaj do tÃ« ngrihet `TypeError`: `Cannot read property '1' of undefined`.

JavaScript i interpreton deklarimet. Kur pÃ«rdorim notacionin me kllapa tÃ« mÃ«dha, e sheh kllapÃ«n hapÃ«se `[` dhe vazhdon kÃ«rkon derisa tÃ« gjen kllapÃ«n mbyllÃ«se `]`. VetÃ«m atÃ«herÃ«, e llogarit deklarimin. NÃ«se do tÃ« pÃ«rdornim `colorConfig[colors[1]]`, do tÃ« kishte kthyer vlerÃ«n e vetisÃ« `red` nÃ« objektin `colorConfig`.

</p>
</details>

---

###### 107. Cila Ã«shtÃ« vlera e saj?

```javascript
console.log('â¤ï¸' === 'â¤ï¸');
```

- A: `true`
- B: `false`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: A

NÃ« prapavijÃ«, emoji-t janÃ« kode tÃ« veÃ§anta. Unikodet pÃ«r emoji-t e zemrÃ«s janÃ« `"U+2764 U+FE0F"`. KÃ«to janÃ« gjithmonÃ« tÃ« njÃ«jta pÃ«r tÃ« njÃ«jtat emoji, kÃ«shtu qÃ« ne po krahasojmÃ« dy stringje tÃ« barabarta me njÃ«ri-tjetrin, gjÃ« qÃ« ktheh 'e vÃ«rtetÃ«'.

</p>
</details>

---

###### 108. Cila nga kÃ«to metoda e modifikon array origjinal?

```javascript
const emojis = ['âœ¨', 'ğŸ¥‘', 'ğŸ˜'];

emojis.map(x => x + 'âœ¨');
emojis.filter(x => x !== 'ğŸ¥‘');
emojis.find(x => x !== 'ğŸ¥‘');
emojis.reduce((acc, cur) => acc + 'âœ¨');
emojis.slice(1, 2, 'âœ¨');
emojis.splice(1, 2, 'âœ¨');
```

- A: `All of them`
- B: `map` `reduce` `slice` `splice`
- C: `map` `slice` `splice`
- D: `splice`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: D

Me motodÃ«n `splice`, ne modifikojmÃ« array origjinal duke fshirÃ«, zÃ«vendÃ«suar ose shtuar elemente. NÃ« kÃ«tÃ« rast, ne larguam 2 gjÃ«ra duke filluar nga indeksi 1 ( larguam `'ğŸ¥‘'` dhe `'ğŸ˜'`) dhe shtuam âœ¨ nÃ« vend tÃ« tyre.

`map`, `filter` dhe `slide` kthen array tÃ« ri, `find` kthen njÃ« element dhe `reduce` kthen njÃ« vlerÃ« tÃ« reduktuar.

</p>
</details>

---

###### 109. Cila Ã«shtÃ« vlera e saj?

```javascript
const food = ['ğŸ•', 'ğŸ«', 'ğŸ¥‘', 'ğŸ”'];
const info = { favoriteFood: food[0] };

info.favoriteFood = 'ğŸ';

console.log(food);
```

- A: `['ğŸ•', 'ğŸ«', 'ğŸ¥‘', 'ğŸ”']`
- B: `['ğŸ', 'ğŸ«', 'ğŸ¥‘', 'ğŸ”']`
- C: `['ğŸ', 'ğŸ•', 'ğŸ«', 'ğŸ¥‘', 'ğŸ”']`
- D: `ReferenceError`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: A

Ne vendosÃ«m vlerÃ«n e vetisÃ« `favoriteFood` nÃ« objektin `info` tÃ« barabartÃ« me stringun me emoji-n e picÃ«s, `'ğŸ•'`. NjÃ« string Ã«shtÃ« njÃ« tip i tÃ« dhÃ«nave primitive. NÃ« JavaScript, tipet primitive tÃ« tÃ« dhÃ«nave nuk ndÃ«rveprojnÃ« me referencÃ«.

NÃ« JavaScript, tipet primitive tÃ« tÃ« dhÃ«nave (gjithÃ§ka qÃ« nuk Ã«shtÃ« objekt) ndÃ«rveprojnÃ« me _vlerÃ«_. NÃ« kÃ«tÃ« rast, ne vendosim vlerÃ«n e vetisÃ« `favoriteFood` nÃ« objektin `info` tÃ« barabartÃ« me vlerÃ«n e elementit tÃ« parÃ« nÃ« array `food`, stringu me emoji-n e picÃ«s nÃ« kÃ«tÃ« rast (`'ğŸ•'`). NjÃ« string Ã«shtÃ« njÃ« tip i tÃ« dhÃ«nave primitive dhe ndÃ«rvepron sipas vlerÃ«s (shikoni [blogpost](https://www.theavocoder.com/complete-javascript/2018/12/21/by-value-vs-by-reference) nÃ«se jeni tÃ« interesuar tÃ« mÃ«soni mÃ« shumÃ«)

MÃ« pas, ne ndryshojmÃ« vlerÃ«n e vetisÃ« `favoriteFood` nÃ« objektin `info`. Vargu `food` nuk ka ndryshuar, pasi vlera e `favoriteFood` ishte thjesht njÃ« _kopje_ e vlerÃ«s sÃ« elementit tÃ« parÃ« nÃ« grup dhe nuk ka njÃ« referencÃ« pÃ«r tÃ« njÃ«jtin vend nÃ« memorie si elementi nÃ« `food[0]`. Kur printojmÃ« 'food', Ã«shtÃ« ende array origjinal, "['ğŸ•", "ğŸ«", "ğŸ¥‘", "ğŸ”"]".

</p>
</details>

---

###### 110. Ã‡farÃ« bÃ«n kjo metodÃ«?

```javascript
JSON.parse();
```

- A: Parson JSON nÃ« njÃ« vlerÃ« tÃ« JavaScript.
- B: Parson njÃ« objekt tÃ« JavaScript nÃ« JSON.
- C: Parson Ã§farÃ«do vlere tÃ« JavaScript nÃ« JSON.
- D: Parson JSON vetÃ«m nÃ« objekt tÃ« JavaScript

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: A

Me metodÃ«n `JSON.parse()`, ne mund tÃ« parsojmÃ« JSON stringun nÃ« njÃ« vlerÃ« JavaScript-i.

```javascript
// Stringifimi i njÃ« numri nÃ« njÃ« JSON valid, pastaj parsimi i nje4 stringu nÃ« vlerÃ« tÃ« JavaScript:
const jsonNumber = JSON.stringify(4); // '4'
JSON.parse(jsonNumber); // 4

// Stringifimi i njÃ« array nÃ« JSON valid, pastaj parsimi i JSON stringut ne njÃ« vlerÃ« tÃ« JavaScript:
const jsonArray = JSON.stringify([1, 2, 3]); // '[1, 2, 3]'
JSON.parse(jsonArray); // [1, 2, 3]

// Stringifimi i njÃ« objekti nÃ« JSON valid, pastaj parsimi i JSON stringut nÃ« njÃ« vlerÃ« tÃ« JavaScript:
const jsonArray = JSON.stringify({ name: 'Lydia' }); // '{"name":"Lydia"}'
JSON.parse(jsonArray); // { name: 'Lydia' }
```

</p>
</details>

---

###### 111. Cila Ã«shtÃ« vlera e saj?

```javascript
let name = 'Lydia';

function getName() {
  console.log(name);
  let name = 'Sarah';
}

getName();
```

- A: Lydia
- B: Sarah
- C: `undefined`
- D: `ReferenceError`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: D

Secili funksion ka _kontekstin e vetÃ« tÃ« ekzekutimit_. Funksioni `getName` sÃ« pari shikon brenda kontekstit tÃ« tij nÃ« qoftÃ«se pÃ«rmban variablÃ«n `name` tÃ« cilÃ«n po provojmÃ« tÃ« i qasemi. NÃ« kÃ«tÃ« rast, funksioni `getName` pÃ«rmban variablÃ«n e tij `name`: e deklaruam variablÃ«n `name` me fjalÃ«n kyÃ§e `let`m dhe i inicializuam vlerÃ«n `'Sarah'`.

Variablat me fjalÃ«n kyÃ§e `let` (dhe `const`) ngriten (hoistoh-en), por pÃ«r dallim nga `var` nuk inicializohen. Ato nuk janÃ« tÃ« qasshme mÃ« herÃ«t se rreshti nÃ« tÃ« cilin janÃ« deklaruar (i kemi deklaruar). Kjo quhet "zona e vdekur e pÃ«rkohshme" (temporal dead zone). Kur tentojmÃ« tÃ« i qasemi variablave pÃ«rpara se ato tÃ« deklarohen, JavaScript hedh `ReferenceError`.

NÃ«se nuk do tÃ« kishim deklaruar `name` brenda funksionit `getName`, makina e JavaScript do tÃ« kishte shikuar poshtÃ« _zingjirit tÃ« shtrirjes_. Fusha e jashtme ka variabÃ«l tÃ« quajtur `name` me vlerÃ« `Lydia`. NÃ« kÃ«tÃ« rast, do tÃ« kishte printuat `Lydia`.

```javascript
let name = 'Lydia';

function getName() {
  console.log(name);
}

getName(); // Lydia
```

</p>
</details>

---

###### 112. Cila Ã«shtÃ« vlera e saj?

```javascript
function* generatorOne() {
  yield ['a', 'b', 'c'];
}

function* generatorTwo() {
  yield* ['a', 'b', 'c'];
}

const one = generatorOne();
const two = generatorTwo();

console.log(one.next().value);
console.log(two.next().value);
```

- A: `a` dhe `a`
- B: `a` dhe `undefined`
- C: `['a', 'b', 'c']` dhe `a`
- D: `a` dhe `['a', 'b', 'c']`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: C

Me fjalÃ«n kyÃ§e `yield`, ne i japim vlerat nÃ« njÃ« funksion gjenerator. Me fjalÃ«n kyÃ§e `yield*`, ne mund tÃ« nxjerrim vlera nga njÃ« funksion tjetÃ«r gjenerues, ose objekt i iterueshÃ«m (pÃ«r shembull njÃ« array).

NÃ« `generatorOne`, ne japim tÃ« gjithÃ« array `['a', 'b', 'c']'` duke pÃ«rdorur fjalÃ«n kyÃ§e `yield`. Vlera e vetisÃ« `value` nÃ« objektin e kthyer me metodÃ«n `next` nÃ« `one` (`one.next().value`) Ã«shtÃ« e barabartÃ« me tÃ« gjithÃ« grupin `['a', 'b', 'c']`.

```javascript
console.log(one.next().value); // ['a', 'b', 'c']
console.log(one.next().value); // undefined
```

NÃ« `generatorTwo`, ne pÃ«rdorim fjalÃ«n kyÃ§e `yield*`. Kjo do tÃ« thotÃ« se vlera e parÃ« e dhÃ«nÃ« e `two`, Ã«shtÃ« e barabartÃ« me vlerÃ«n e dhÃ«nÃ« nÃ« iterimin e parÃ«. Iteratori Ã«shtÃ« grupi `['a', 'b', 'c']`. Vlera e parÃ« e dhÃ«nÃ« Ã«shtÃ« `a`, kÃ«shtu qÃ« herÃ«n e parÃ« qÃ« thÃ«rrasim `two.next().value`, kthehet `a`.

```javascript
console.log(two.next().value); // 'a'
console.log(two.next().value); // 'b'
console.log(two.next().value); // 'c'
console.log(two.next().value); // undefined
```

</p>
</details>

---

###### 113. Cila Ã«shtÃ« vlera e saj?

```javascript
console.log(`${(x => x)('I love')} to program`);
```

- A: `I love to program`
- B: `undefined to program`
- C: `${(x => x)('I love') to program`
- D: `TypeError`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: A

Shprehjet brenda shablloneve literale vlerÃ«sohen sÃ« pari. Kjo do tÃ« thotÃ« qÃ« stringu do tÃ« pÃ«rmbajÃ« vlerÃ«n e kthyer tÃ« shprehjes, funksionin e thirrur menjÃ«herÃ« `(x => x)('I love')` nÃ« kÃ«tÃ« rast. Ne e kalojmÃ« vlerÃ«n `'I love'` si argument nÃ« funksionin e shigjetÃ«s `x => x`. `x` Ã«shtÃ« e barabartÃ« me `'I love'`, e cila kthehet. Kjo rezulton nÃ« `I love to program`.

</p>
</details>

---

###### 114. Ã‡farÃ« do tÃ« ndodhÃ«?

```javascript
let config = {
  alert: setInterval(() => {
    console.log('Alert!');
  }, 1000),
};

config = null;
```

- A: Callback `setInterval` nuk do tÃ« thirret.
- B: Callback `setInterval` do tÃ« thirret njÃ« herÃ«.
- C: Callback `setInterval` do tÃ« thirret Ã§do sekond.
- D: Nuk e kemi thirrur asnjÃ«herÃ« `config.alert()`, config Ã«shtÃ« `null`.

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: C

Zakonisht kur i vendosim objektet tÃ« barabarta me `null`, ato objekte mirren nga _garbage collector_ pasi nuk ka mÃ« referencÃ« pÃ«r ato objekte. MegjithatÃ«, meqenÃ«se funksioni callback brenda `setInterval` Ã«shtÃ« njÃ« funksion me shigjetÃ« (pra i lidhur me objektin `config`), funksioni callback ende mban njÃ« referencÃ« pÃ«r objektin `config`.
PÃ«r sa kohÃ« ka njÃ« referencÃ«, objekti nuk do tÃ« merret nga 'garbage collector' (menaxhuesi i memories pÃ«r tÃ« u larguar).
MeqenÃ«se ky Ã«shtÃ« njÃ« interval, vendosja e `config` nÃ« '`null` ose `delete` `config.alert` nuk do tÃ« mbledhet nga garbage-collector pÃ«r  intervalin, kÃ«shtu qÃ« intervali do tÃ« vazhdojÃ« tÃ« thirret.
PÃ«r ta hequr nga memoria duhet tÃ« e pastrojmÃ« me `clearInterval(config.alert)`.
MeqenÃ«se nuk u fshi, funksioni `setInterval` callback do tÃ« vazhdojÃ« tÃ« thirret Ã§do 1000ms (1s).

</p>
</details>

---

###### 115. Cila metodÃ« do tÃ« kthejÃ« vlerÃ«n `'Hello world!'`?

```javascript
const myMap = new Map();
const myFunc = () => 'greeting';

myMap.set(myFunc, 'Hello world!');

//1
myMap.get('greeting');
//2
myMap.get(myFunc);
//3
myMap.get(() => 'greeting');
```

- A: 1
- B: 2
- C: 2 dhe 3
- D: TÃ« gjitha

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: B

Kur shtoni njÃ« Ã§ift Ã§elÃ«s/vlerÃ« duke pÃ«rdorur metodÃ«n `set`, Ã§elÃ«si do tÃ« jetÃ« vlera e argumentit tÃ« parÃ« qÃ« i kalohet funksionit `set`, dhe vlera do tÃ« jetÃ« argumenti i dytÃ« qÃ« i kalohet funksionit `set`. Ã‡elÃ«si Ã«shtÃ« _functioni_ `() => 'greeting'` nÃ« kÃ«tÃ« rast, dhe vlera `'Hello world'`. `myMap` tani Ã«shtÃ« `{ () => 'greeting' => 'Hello world!' }`.

1 Ã«shtÃ« gabim, pasi Ã§elÃ«si nuk Ã«shtÃ« `'greeting'` por `() => 'greeting'`.
3 Ã«shtÃ« gabim, pasi ne po krijojmÃ« njÃ« funksion tÃ« ri duke e kaluar atÃ« si parametÃ«r nÃ« metodÃ«n `get`. Objekti ndÃ«rvepron me _referencÃ«_. Funksionet janÃ« objekte, prandaj dy funksione nuk janÃ« kurrÃ« rreptÃ«sisht tÃ« barabarta, edhe nÃ«se janÃ« identike: ato kanÃ« njÃ« referencÃ« nÃ« njÃ« vend tÃ« ndryshÃ«m nÃ« memorie.

</p>
</details>

---

###### 116. Cila Ã«shtÃ« vlera e saj?

```javascript
const person = {
  name: 'Lydia',
  age: 21,
};

const changeAge = (x = { ...person }) => (x.age += 1);
const changeAgeAndName = (x = { ...person }) => {
  x.age += 1;
  x.name = 'Sarah';
};

changeAge(person);
changeAgeAndName();

console.log(person);
```

- A: `{name: "Sarah", age: 22}`
- B: `{name: "Sarah", age: 23}`
- C: `{name: "Lydia", age: 22}`
- D: `{name: "Lydia", age: 23}`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: C

TÃ« dy funksionet `changeAge` dhe `changeAgeAndName` kanÃ« njÃ« parametÃ«r tÃ« paracaktuar, pÃ«rkatÃ«sisht njÃ« objekt tÃ« krijuar rishtazi `{...person}`. Ky objekt ka kopje tÃ« tÃ« gjithÃ« Ã§elÃ«save/vlerave nÃ« objektin `person`.

SÃ« pari, e thirrim funksionin `changeAge` dhe e kalojmÃ« objektin `person` si argument. Ky funksion rrit vlerÃ«n e vetisÃ« `age` pÃ«r 1. `person` tani Ã«shtÃ« `{ name: "Lydia", age: 22 }`.

Pastaj, e thirrim funksionin `changeAgeAndName`, sidoqoftÃ« ne nuk e kalojmÃ« njÃ« parametÃ«r. NÃ« vend tÃ« kÃ«saj, vlera e `x` Ã«shtÃ« e barabartÃ« me objektin e ri `{ ...person }`. MeqenÃ«se Ã«shtÃ« njÃ« objekt i ri, nuk do tÃ« afektojÃ« vlerÃ«n e vetive nÃ« objektin `person`. `person` ende Ã«shtÃ« e barabartÃ« me `{ name: "Lydia", age: 22 }`.

</p>
</details>

---

###### 117. Cili nga funksionet e mÃ«poshtme do tÃ« kthejÃ« `6`?

```javascript
function sumValues(x, y, z) {
  return x + y + z;
}
```

- A: `sumValues([...1, 2, 3])`
- B: `sumValues([...[1, 2, 3]])`
- C: `sumValues(...[1, 2, 3])`
- D: `sumValues([1, 2, 3])`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: C

Me operatorin spread `...`, me mund tÃ« _pÃ«rhapim_ iteruesit nÃ« elemente individuale. Funksioni `sumValues` merr tre argumente: `x`, `y` dhe `z`. `...[1, 2, 3]` do tÃ« rezultojÃ« nÃ« `1, 2, 3`, tÃ« cilin ia kalojmÃ« funksionit `sumValues`.

</p>
</details>

---

###### 118. Cila Ã«shtÃ« vlera e saj?

```javascript
let num = 1;
const list = ['ğŸ¥³', 'ğŸ¤ ', 'ğŸ¥°', 'ğŸ¤ª'];

console.log(list[(num += 1)]);
```

- A: `ğŸ¤ `
- B: `ğŸ¥°`
- C: `SyntaxError`
- D: `ReferenceError`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: B

Me operandin `+=`, ne po rrisim vlerÃ«n e `sum` pÃ«r `1`. `num` kishte vlerÃ«n iniciale `1`, kÃ«shtu `1 + 1` Ã«shtÃ« `2`. Elementi nÃ« indeksin e dytÃ« nÃ« `list` Ã«shtÃ« ğŸ¥°, `console.log(list[2])` printon ğŸ¥°.

</p>
</details>

---

###### 119. Cila Ã«shtÃ« vlera e saj?

```javascript
const person = {
  firstName: 'Lydia',
  lastName: 'Hallie',
  pet: {
    name: 'Mara',
    breed: 'Dutch Tulip Hound',
  },
  getFullName() {
    return `${this.firstName} ${this.lastName}`;
  },
};

console.log(person.pet?.name);
console.log(person.pet?.family?.name);
console.log(person.getFullName?.());
console.log(member.getLastName?.());
```

- A: `undefined` `undefined` `undefined` `undefined`
- B: `Mara` `undefined` `Lydia Hallie` `ReferenceError`
- C: `Mara` `null` `Lydia Hallie` `null`
- D: `null` `ReferenceError` `null` `ReferenceError`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: B

Me operatorin opsional tÃ« zinxhirit `?.`, nuk duhet tÃ« kontrollojmÃ« mÃ« nÃ« mÃ«nyrÃ« eksplicite nÃ«se vlerat mÃ« tÃ« thella tÃ« ndÃ«rthurura janÃ« tÃ« vlefshme apo jo. NÃ«se po provojmÃ« ti qasemi njÃ« vetie me njÃ« vlerÃ« `undefined` ose `null` (_nullish_), shprehja lidhet me qark tÃ« shkurtÃ«r dhe kthen `undefined`.

`person.pet?.name`: `person` ka njÃ« veti tÃ« quajtur `pet`: `person.pet` nuk Ã«shtÃ« vlerÃ« null. Ka njÃ« veti tÃ« quajtur `name`, dhe kthen `Mara`.
`person.pet?.family?.name`: `person` ka njÃ« veti tÃ« quajtur `pet`: `person.pet` nuk Ã«shtÃ« vlerÃ« null. `pet` nuk ka njÃ« veti tÃ« quajtur `family`, `person.pet.family` Ã«shtÃ« vlerÃ« null. Shprehja kthen `undefined`.
`person.getFullName?.()`: `person` ka njÃ« veti tÃ« quajtur `getFullName`: `person.getFullName()` nuk Ã«shtÃ« vlerÃ« null dhe mund tÃ« thirret, dhe do tÃ« kthejÃ« `Lydia Hallie`.
`member.getLastName?.()`: variabla `member` nuk ekziston prandaj `ReferenceError` do tÃ« hedhet!

</p>
</details>

---

###### 120. Cila Ã«shtÃ« vlera e saj?

```javascript
const groceries = ['banana', 'apple', 'peanuts'];

if (groceries.indexOf('banana')) {
  console.log('We have to buy bananas!');
} else {
  console.log(`We don't have to buy bananas!`);
}
```

- A: We have to buy bananas!
- B: We don't have to buy bananas
- C: `undefined`
- D: `1`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: B

Ne e kaluam kushtÃ«zimin `groceries.indexOf("banana")` tek deklarimi if. `groceries.indexOf("banana")` kthen `0`, e cila Ã«shtÃ« vlerÃ« false. PÃ«rderisa deklarimi i kushtÃ«zimit if Ã«shtÃ« falsy, kodi nÃ« bllokun `else` ekzekutohet, dhe `We don't have to buy bananas!` do tÃ« printohet.

</p>
</details>

---

###### 121. Cila Ã«shtÃ« vlera e saj?

```javascript
const config = {
  languages: [],
  set language(lang) {
    return this.languages.push(lang);
  },
};

console.log(config.language);
```

- A: `function language(lang) { this.languages.push(lang }`
- B: `0`
- C: `[]`
- D: `undefined`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: D

Metoda `language` Ã«shtÃ« metodÃ« `setter` (vendosÃ«se). VendosÃ«sit nuk mbajÃ« njÃ« vlerÃ« aktuale, qÃªllimi i tyre Ã«shtÃ« tÃ« _modifikojnÃ«_ vetitÃ«. Kur e thirrim metodÃ«n `setter`, do tÃ« kthehet `undefined`.

</p>
</details>

---

###### 122. Cila Ã«shtÃ« vlera e saj?

```javascript
const name = 'Lydia Hallie';

console.log(!typeof name === 'object');
console.log(!typeof name === 'string');
```

- A: `false` `true`
- B: `true` `false`
- C: `false` `false`
- D: `true` `true`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: C

`typeof name` kthen `"string"`. Stringu `"string"` Ã«shtÃ« vlerÃ« truthy, kÃ«shtu qÃ« `!typeof name` kthen vlerÃ«n booleane `false`. `false === "object"` dhe `false === "string"` tÃ« dy kthejnÃ« `false`.

(NÃ«se do tÃ« dÃ«shironim tÃ« shikojmÃ« nÃ« qoftÃ«se tipi ishtÃ« (jo) i barabartÃ« nÃ« njÃ« tip tÃ« caktuar, do tÃ« kishim shkruar `!==` nÃ« vend tÃ« `!typeof`)

</p>
</details>

---

###### 123. Cila Ã«shtÃ« vlera e saj?

```javascript
const add = x => y => z => {
  console.log(x, y, z);
  return x + y + z;
};

add(4)(5)(6);
```

- A: `4` `5` `6`
- B: `6` `5` `4`
- C: `4` `function` `function`
- D: `undefined` `undefined` `6`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: A

Funksioni `add` kthen njÃ« funksion shigjete, i cili kthen njÃ« funksion shigjete, i cili kthen njÃ« funksion shigjete. Funksioni i parÃ« merr njÃ« argument `x` me vlerÃ«n `4`. Ne e thÃ«rrasim funksionin e dytÃ«, i cili merr njÃ« argument `y` me vlerÃ«n `5`. Pastaj thÃ«rrasim funksionin e tretÃ«, i cili merr njÃ« argument `z` me vlerÃ«n `6`. Kur po provojmÃ« tÃ« qasemi nÃ« vlerÃ«n `x`, `y` dhe `z` brenda funksionit tÃ« fundit tÃ« shigjetÃ«s, makina  JS shkon lart nÃ« zinxhirin e shtrirjes pÃ«r tÃ« gjetur vlerat pÃ«r `x` dhe `y` pÃ«rkatÃ«sisht. Kjo kthen `4` `5` `6`.

</p>
</details>

---

###### 124. Cila Ã«shtÃ« vlera e saj?

```javascript
async function* range(start, end) {
  for (let i = start; i <= end; i++) {
    yield Promise.resolve(i);
  }
}

(async () => {
  const gen = range(1, 3);
  for await (const item of gen) {
    console.log(item);
  }
})();
```

- A: `Promise {1}` `Promise {2}` `Promise {3}`
- B: `Promise {<pending>}` `Promise {<pending>}` `Promise {<pending>}`
- C: `1` `2` `3`
- D: `undefined` `undefined` `undefined`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: C

Funksioni gjenerator `range` kthen njÃ« objekt asinkron me premtimet pÃ«r Ã§do elemnt nÃ« rangun qÃ« ne japim: `Promise{1}`, `Promise{2}`, `Promise{3}`. Ne vendosim variablÃ«n `gen` tÃ« jetÃ« e barabartÃ« me objektin asinkron, pas tÃ« cilit ne e iterojmÃ« mbi tÃ« nÃ«pÃ«rmjet unazÃ«s `for await ... of`. Ne vendosim variablÃ«n `item` tÃ« jetÃ« e barabartÃ« me vlerat e kthyera tÃ« Promise: sÃ« pari `Promise{1}`, pastaj `Promise{2}`, pastaj `Promise{3}`. Pasi qÃ« po _presim_ vlerÃ«n e `item`, premtimet e zgjidhura, vlerat e zgjidhura tÃ« premtimit kthehen: `1`, `2`, pastaj `3`.

</p>
</details>

---

###### 125. Cila Ã«shtÃ« vlera e saj?

```javascript
const myFunc = ({ x, y, z }) => {
  console.log(x, y, z);
};

myFunc(1, 2, 3);
```

- A: `1` `2` `3`
- B: `{1: 1}` `{2: 2}` `{3: 3}`
- C: `{ 1: undefined }` `undefined` `undefined`
- D: `undefined` `undefined` `undefined`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: D

`myFunc` pret njÃ« objekt me vetitÃ« `x`, `y` dhe `z` si argumente tÃ« tij. Pasi qÃ« po japim vetÃ«m tre vlera numerike tÃ« ndara (1, 2, 3) nÃ« vend tÃ« njÃ« objekti me vetitÃ« `x`, `y` dhe `z` ({x: 1, y: 2, z: 3}), `x`, `y` dhe `z` kanÃ« vlerÃ«n e tyre tÃ« parazgjedhur si `undefined`.

</p>
</details>

---

###### 126. Cila Ã«shtÃ« vlera e saj?

```javascript
function getFine(speed, amount) {
  const formattedSpeed = new Intl.NumberFormat('en-US', {
    style: 'unit',
    unit: 'mile-per-hour'
  }).format(speed);

  const formattedAmount = new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: 'USD'
  }).format(amount);

  return `The driver drove ${formattedSpeed} and has to pay ${formattedAmount}`;
}

console.log(getFine(130, 300))
```

- A: The driver drove 130 and has to pay 300
- B: The driver drove 130 mph and has to pay \$300.00
- C: The driver drove undefined and has to pay undefined
- D: The driver drove 130.00 and has to pay 300.00

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: B

Me metoden `Intl.NumberFormat`, ne mund tÃ« formatojmÃ« vlerat numerike nÃ« Ã§do vend. Ne formatojmÃ« vlerÃ«n numerike `130` nÃ« vendin `en-US` si njÃ« `unit` nÃ« `mile-per-hour`, qÃ« rezulton nÃ« `130 mph`. Vlera numerike `300` nÃ« vendin `en-US` si njÃ« `currency` nÃ« `USD` rezulton nÃ« `$300.00`.

</p>
</details>

---

###### 127. Cila Ã«shtÃ« vlera e saj?

```javascript
const spookyItems = ['ğŸ‘»', 'ğŸƒ', 'ğŸ•¸'];
({ item: spookyItems[3] } = { item: 'ğŸ’€' });

console.log(spookyItems);
```

- A: `["ğŸ‘»", "ğŸƒ", "ğŸ•¸"]`
- B: `["ğŸ‘»", "ğŸƒ", "ğŸ•¸", "ğŸ’€"]`
- C: `["ğŸ‘»", "ğŸƒ", "ğŸ•¸", { item: "ğŸ’€" }]`
- D: `["ğŸ‘»", "ğŸƒ", "ğŸ•¸", "[object Object]"]`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: B

Duke destrukturuar objektet, ne mund tÃ« targetojmÃ« vlerat nga objekti i djathtÃ«, dhe tÃ« caktojmÃ« vlerÃ«n e targetuar nÃ« vlerÃ«n e emrit tÃ« njÃ«jtÃ« tÃ« vetisÃ« nÃ« objektin nÃ« anÃ«n e majtÃ«. NÃ« kÃ«tÃ« rast, ne po caktojmÃ« vlerÃ«n "ğŸ’€" nÃ« `spookyItems[3]`. Kjo do tÃ« thotÃ« se ne po ndryshojmÃ« vargun `spookyItems`, po i shtojmÃ« "ğŸ’€". Kur printojmÃ« `spookyItems`, `["ğŸ‘»", "ğŸƒ", "ğŸ•¸", "ğŸ’€"]` printohet.

</p>
</details>

---

###### 128. Cila Ã«shtÃ« vlera e saj?

```javascript
const name = 'Lydia Hallie';
const age = 21;

console.log(Number.isNaN(name));
console.log(Number.isNaN(age));

console.log(isNaN(name));
console.log(isNaN(age));
```

- A: `true` `false` `true` `false`
- B: `true` `false` `false` `false`
- C: `false` `false` `true` `false`
- D: `false` `true` `false` `true`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: C

Me metoden `Number.isNaN`, ju mund tÃ« kontrolloni nÃ«se vlera qÃ« ju jepni Ã«shtÃ« njÃ« _vlerÃ« numerike_ dhe e barabartÃ« me `NaN`. `name` nuk Ã«shtÃ« njÃ« vlerÃ« numerike, kÃ«shtu qÃ« `Number.isNaN(name)` kthen `false`. `age` Ã«shtÃ« njÃ« vlerÃ« numerike, por nuk Ã«shtÃ« e barabartÃ« me `NaN`, kÃ«shtu qÃ« `Number.isNaN(age)` kthen `false`.

Me metoden `isNaN`, ju mund tÃ« kontrolloni nÃ«se vlera qÃ« ju jepni nuk Ã«shtÃ« numÃ«r. `name` nuk Ã«shtÃ« numÃ«r, kÃ«shtu qÃ« `isNaN(name)` kthen true. `age` Ã«shtÃ« numÃ«r, kÃ«shtu qÃ« `isNaN(age)` kthen `false`.

</p>
</details>

---

###### 129. Cila Ã«shtÃ« vlera e saj?

```javascript
const randomValue = 21;

function getInfo() {
  console.log(typeof randomValue);
  const randomValue = 'Lydia Hallie';
}

getInfo();
```

- A: `"number"`
- B: `"string"`
- C: `undefined`
- D: `ReferenceError`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: D

Variablat e deklaruara me fjalÃ«n kyÃ§e `const` nuk janÃ« tÃ« referueshme para inicializimit tÃ« tyre: kjo quhet _zona e vdekjes sÃ« pÃ«rkohshme_. NÃ« funksionin `getInfo`, variabla `randomValue` Ã«shtÃ« me shtrirje nÃ« fushÃ«n e funksionit `getInfo`. NÃ« rreshtin ku ne duam tÃ« printojmÃ« vlerÃ«n e `typeof randomValue`, variabla `randomValue` nuk Ã«shtÃ« inicializuar ende: njÃ« `ReferenceError` hidhet! Makina e JS nuk shkoi poshtÃ« nÃ« zinxhirin e fushÃ«s pasi ne deklaruam variablÃ«n `randomValue` nÃ« funksionin `getInfo`.

</p>
</details>

---

###### 130. Cila Ã«shtÃ« vlera e saj?

```javascript
const myPromise = Promise.resolve('Woah some cool data');

(async () => {
  try {
    console.log(await myPromise);
  } catch {
    throw new Error(`Oops didn't work`);
  } finally {
    console.log('Oh finally!');
  }
})();
```

- A: `Woah some cool data`
- B: `Oh finally!`
- C: `Woah some cool data` `Oh finally!`
- D: `Oops didn't work` `Oh finally!`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: C

NÃ« bllokun `try`, ne jemi duke printuar vlerÃ«n e pritur tÃ« variablÃ«s `myPromise`: `"Woah some cool data"`. Pasi qÃ« nuk u hodhÃ«n gabime nÃ« bllokun `try`, kodi nÃ« bllokun `catch` nuk ekzekutohet. Kodi nÃ« bllokun `finally` _gjithmonÃ«_ ekzekutohet, `"Oh finally!"` printohet.

</p>
</details>

---

###### 131. Cila Ã«shtÃ« vlera e saj?

```javascript
const emojis = ['ğŸ¥‘', ['âœ¨', 'âœ¨', ['ğŸ•', 'ğŸ•']]];

console.log(emojis.flat(1));
```

- A: `['ğŸ¥‘', ['âœ¨', 'âœ¨', ['ğŸ•', 'ğŸ•']]]`
- B: `['ğŸ¥‘', 'âœ¨', 'âœ¨', ['ğŸ•', 'ğŸ•']]`
- C: `['ğŸ¥‘', ['âœ¨', 'âœ¨', 'ğŸ•', 'ğŸ•']]`
- D: `['ğŸ¥‘', 'âœ¨', 'âœ¨', 'ğŸ•', 'ğŸ•']`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: B

Me metodÃ«n flat, ne mund tÃ« krijojmÃ« njÃ« varg tÃ« ri, tÃ« rrafshÃ«t. ThellÃ«sia e vargut tÃ« rrafshÃ«t varet nga vlera qÃ« ne japim. NÃ« kÃ«tÃ« rast, ne dhamÃ« vlerÃ«n 1 (e cila nuk ishte e nevojshme, ajo Ã«shtÃ« vlera e paracaktuar), qÃ« do tÃ« thotÃ« se vetÃ«m vargjet nÃ« thellÃ«sinÃ« e parÃ« do tÃ« bashkohen. ['ğŸ¥‘'] dhe ['âœ¨', 'âœ¨', ['ğŸ•', 'ğŸ•']] nÃ« kÃ«tÃ« rast. Bashkimi i kÃ«tyre dy vargjeve rezulton nÃ« ['ğŸ¥‘', 'âœ¨', 'âœ¨', ['ğŸ•', 'ğŸ•']].

</p>
</details>

---

###### 132. Cila Ã«shtÃ« vlera e saj?

```javascript
class Counter {
  constructor() {
    this.count = 0;
  }

  increment() {
    this.count++;
  }
}

const counterOne = new Counter();
counterOne.increment();
counterOne.increment();

const counterTwo = counterOne;
counterTwo.increment();

console.log(counterOne.count);
```

- A: `0`
- B: `1`
- C: `2`
- D: `3`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: D

`counterOne` Ã«shtÃ« njÃ« instancÃ« e klasÃ«s `Counter`. Klasa Counter pÃ«rmban njÃ« veti `count` nÃ« konstruktorin e saj, dhe njÃ« metodÃ« `increment`. SÃ« pari, ne thirrÃ«m metodÃ«n `increment` dy herÃ« duke thirrur `counterOne.increment()`. Aktualisht, `counterOne.count` Ã«shtÃ« `2`.

<img src="https://i.imgur.com/KxLlTm9.png" width="400">

MÃ« pas, ne krijojmÃ« njÃ« variabÃ«l tÃ« re `counterTwo`, dhe e vendosim tÃ« barabartÃ« me `counterOne`. Pasi objektet ndÃ«rveprojnÃ« me referencÃ«, ne thjesht po krijojmÃ« njÃ« referencÃ« tÃ« re pÃ«r tÃ« njÃ«jtin vend nÃ« memorie ku `counterOne` tregon. MeqenÃ«se po tregon nÃ« tÃ« njÃ«jtin vend nÃ« memorie, Ã§do ndryshim i bÃ«rÃ« nÃ« objektin qÃ« `counterTwo` ka njÃ« referencÃ«, gjithashtu vlen edhe pÃ«r `counterOne`. Aktualisht, `counterTwo.count` Ã«shtÃ« `2`.

Ne thÃ«rrasim `counterTwo.increment()`, i cili vendos `count` nÃ« `3`. Pastaj, printojmÃ« numÃ«ruesin `counterOne`, i cili printon `3`.

<img src="https://i.imgur.com/BNBHXmc.png" width="400">

</p>
</details>

---

###### 133. Cila Ã«shtÃ« vlera e saj?

```javascript
const myPromise = Promise.resolve(Promise.resolve('Promise'));

function funcOne() {
  setTimeout(() => console.log('Timeout 1!'), 0);
  myPromise.then(res => res).then(res => console.log(`${res} 1!`));
  console.log('Last line 1!');
}

async function funcTwo() {
  const res = await myPromise;
  console.log(`${res} 2!`)
  setTimeout(() => console.log('Timeout 2!'), 0);
  console.log('Last line 2!');
}

funcOne();
funcTwo();
```

- A: `Promise 1! Last line 1! Promise 2! Last line 2! Timeout 1! Timeout 2!`
- B: `Last line 1! Timeout 1! Promise 1! Last line 2! Promise2! Timeout 2! `
- C: `Last line 1! Promise 2! Last line 2! Promise 1! Timeout 1! Timeout 2!`
- D: `Timeout 1! Promise 1! Last line 1! Promise 2! Timeout 2! Last line 2!`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: C

SÃ« pari, ne thirrim `funcOne`. NÃ« rreshtin e parÃ« tÃ« `funcOne`, ne thirrim funksionin _asinkron_ `setTimeout`, nga i cili callback Ã«shtÃ« dÃ«rguar tek API-ja e Web-it. (shih artikullin tim mbi ciklin e ngjarjeve kÃ«tu.)

Pastaj e thirrim premtimin `myPromise`, e cila Ã«shtÃ« njÃ« operacion _asinkron_.

Edhe premtimi dhe koha e pritjes janÃ« operacione asinkrone, funksioni vazhdon tÃ« ekzekutohet ndÃ«rsa Ã«shtÃ« i zÃ«nÃ« nÃ« plotÃ«simin e premtimeve dhe trajtimin e callback-ut `setTimeout`. Kjo do tÃ« thotÃ« se `Last line 1!` printohet sÃ« pari, pasi kjo nuk Ã«shtÃ« njÃ« operacion asinkron.

MeqenÃ«se callstack nuk Ã«shtÃ« bosh ende, funksioni `setTimeout` dhe premtimi nÃ« `funcOne` nuk mund tÃ« shtohen ende nÃ« callstack.

NÃ« `funcTwo`, variabla `res` merr `Promise` sepse `Promise.resolve(Promise.resolve('Promise'))` Ã«shtÃ« ekuivalente me `Promise.resolve('Promise')` pasi plotÃ«simi i njÃ« premtimi thjesht i plotÃ«son vlerat e tij. `await` nÃ« kÃ«tÃ« rresht ndalon ekzekutimin e funksionit derisa tÃ« marrÃ« zgjidhjen e premtimit dhe pastaj vazhdon tÃ« ekzekutohet sinkronisht deri nÃ« pÃ«rfundim, kÃ«shtu qÃ« `Promise 2!` dhe pastaj `Last line 2!` janÃ« regjistruar dhe `setTimeout` Ã«shtÃ« dÃ«rguar tek API-ja e Web-it.

Pastaj call stack Ã«shtÃ« bosh. Premtimet janÃ« _mikrodetyra_ (microtasks) prandaj ato zgjidhen sÃ« pari kur call stack Ã«shtÃ« bosh, kÃ«shtu qÃ« `Promise 1!` printohet.

Tani, pasi qÃ« `funcTwo` Ã«shtÃ« larguar nga call stack, call stack Ã«shtÃ« bosh. Callback-et qÃ« po presin nÃ« radhÃ« (`() => console.log("Timeout 1!")` nga `funcOne`, dhe `() => console.log("Timeout 2!")` nga `funcTwo`) shtohen nÃ« call stack njÃ« nga njÃ«. Callback-i i parÃ« printon `Timeout 1!`, dhe largohet nga stack. MÃ« pas, callback-i i dytÃ« printon `Timeout 2!`, dhe largohet nga stack.

</p>
</details>

---

###### 134. Si mund tÃ« thÃ«rrasim funksionin `sum` nga `sum.js` nÃ« `index.js`?

```javascript
// sum.js
export default function sum(x) {
  return x + x;
}

// index.js
import * as sum from './sum';
```

- A: `sum(4)`
- B: `sum.sum(4)`
- C: `sum.default(4)`
- D: Eksportimet e paracaktuar nuk importohen me `*`, vetÃ«m eksportimet e emÃ«ruara.

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: C

Me yllin `*`, ne importojmÃ« tÃ« gjitha vlerat e eksportuara nga ai fajll, si ato tÃ« paracaktuara dhe ato tÃ« emÃ«ruara. NÃ«se kemi fajllin e mÃ«poshtÃ«m:

```javascript
// info.js
export const name = 'Lydia';
export const age = 21;
export default 'I love JavaScript';

// index.js
import * as info from './info';
console.log(info);
```

The following would get logged:

```javascript
{
  default: "I love JavaScript",
  name: "Lydia",
  age: 21
}
```

PÃ«r shembullin `sum`, do tÃ« thotÃ« se vlera e importuar e `sum` do tÃ« dukej kÃ«shtu:

```javascript
{ default: function sum(x) { return x + x } }
```

Mund tÃ« e thÃ«rrasim kÃ«tÃ« funksion, duke thirrur `sum.default`

</p>
</details>

---

###### 135. Cila Ã«shtÃ« vlera e saj?

```javascript
const handler = {
  set: () => console.log('Added a new property!'),
  get: () => console.log('Accessed a property!'),
};

const person = new Proxy({}, handler);

person.name = 'Lydia';
person.name;
```

- A: `Added a new property!`
- B: `Accessed a property!`
- C: `Added a new property!` `Accessed a property!`
- D: AsgjÃ« nuk printohet

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: C

Me njÃ« objekt Proxy, ne mund tÃ« shtojmÃ« sjellje tÃ« personalizuara pÃ«r njÃ« objekt tÃ« cilit i kalohet si argumenti i dytÃ«. NÃ« kÃ«tÃ« rast, ne i kalojmÃ« objektin `handler` i cili pÃ«rmban dy veti: `set` dhe `get`. `set` thirret Ã§do herÃ« kur ne _caktojmÃ«_ vlerat e vetisÃ«, `get` thirret Ã§do herÃ« kur ne _marrim_ (i qasemi) vlerave tÃ« vetisÃ«.

Argumenti i parÃ« Ã«shtÃ« njÃ« objekt i zbrazÃ«t `{}`, i cili Ã«shtÃ« vlera e `person`. Tek ky objekt, shtohet sjellja e personalizuar e specifikuar nÃ« objektin `handler`. NÃ«se shtojmÃ« njÃ« veti tek objekti `person`, `set` do tÃ« thirret. NÃ«se i qasemi njÃ« vetie nÃ« objektin `person`, `get` do tÃ« thirret.

SÃ« pari, ne shtuam njÃ« veti tÃ« re `name` tek objekti proxy (`person.name = "Lydia"`). `set` thirret, dhe printon `"Added a new property!"`.

Pastaj, ne i qasemi njÃ« vlerÃ« tÃ« vetisÃ« nÃ« objektin proxy, vetia `get` nÃ« objektin handler thirret. `"Accessed a property!"` printohet.

</p>
</details>

---

###### 136. Cili nga opsionet e mÃ«poshtme do tÃ« modifikojÃ« objektin `person`?

```javascript
const person = { name: 'Lydia Hallie' };

Object.seal(person);
```

- A: `person.name = "Evan Bacon"`
- B: `person.age = 21`
- C: `delete person.name`
- D: `Object.assign(person, { age: 21 })`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: A

Me `Object.seal` ne mund tÃ« parandalojmÃ« shtimin e vetive tÃ« reja, ose fshirjen e vetive ekzistuese.

MegjithatÃ«, ju ende mund tÃ« modifikoni vlerÃ«n e vetive ekzistuese.

</p>
</details>

---

###### 137. Cili nga opsionet e mÃ«poshtme do tÃ« modifikojÃ« objektin `person`?

```javascript
const person = {
  name: 'Lydia Hallie',
  address: {
    street: '100 Main St',
  },
};

Object.freeze(person);
```

- A: `person.name = "Evan Bacon"`
- B: `delete person.address`
- C: `person.address.street = "101 Main St"`
- D: `person.pet = { name: "Mara" }`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: C

Metoda `Object.freeze` _ngrin_ njÃ« objekt. AsnjÃ« veti nuk mund tÃ« shtohet, tÃ« modifikohet, ose tÃ« hiqet.

MegjithatÃ«, ajo vetÃ«m _ngrin sipÃ«rfaqÃ«sisht_ objektin, qÃ« do tÃ« thotÃ« se vetÃ«m vetitÃ« _e drejtpÃ«rdrejta_ nÃ« objekt janÃ« tÃ« ngrira. NÃ«se vetia Ã«shtÃ« njÃ« tjetÃ«r objekt, si `address` nÃ« kÃ«tÃ« rast, vetitÃ« nÃ« atÃ« objekt nuk janÃ« tÃ« ngrira, dhe mund tÃ« modifikohen.

</p>
</details>

---

###### 138. Cila Ã«shtÃ« vlera e saj?

```javascript
const add = x => x + x;

function myFunc(num = 2, value = add(num)) {
  console.log(num, value);
}

myFunc();
myFunc(3);
```

- A: `2` `4` and `3` `6`
- B: `2` `NaN` and `3` `NaN`
- C: `2` `Error` and `3` `6`
- D: `2` `4` and `3` `Error`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: A

SÃ« pari, ne thirrÃ«m `myFunc()` pa kaluar asnjÃ« argument. Pasi qÃ« nuk kaluam argumente, `num` dhe `value` morÃ«n vlerat e tyre tÃ« paracaktuara: num Ã«shtÃ« `2`, dhe `value` Ã«shtÃ« vlera e kthyer nga funksioni `add`. Tek funksioni `add`, ne i japim si argument `num`, i cili ka vlerÃ«n `2`. `Add` kthen `4`, e cila Ã«shtÃ« vlera e `value`.

MÃ« pas, ne thirrÃ«m `myFunc(3)` dhe kaluam vlerÃ«n `3` si vlerÃ« pÃ«r argumentin `num`. Nuk kaluam njÃ« argument pÃ«r `value`. Pasi nuk kaluam njÃ« vlerÃ« pÃ«r argumentin `value`, ai mori vlerÃ«n e paracaktuar: vlerÃ«n e kthyer nga funksioni `add`. Tek `add`, ne i japim si argument `num`, i cili ka vlerÃ«n `3`. `Add` kthen `6`, e cila Ã«shtÃ« vlera e `value`.

</p>
</details>

---

###### 139. Cila Ã«shtÃ« vlera e saj?

```javascript
class Counter {
  #number = 10

  increment() {
    this.#number++
  }

  getNum() {
    return this.#number
  }
}

const counter = new Counter()
counter.increment()

console.log(counter.#number)
```

- A: `10`
- B: `11`
- C: `undefined`
- D: `SyntaxError`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: D

NÃ« ES2020, mund tÃ« shtojmÃ« variabla private nÃ« klasa duke pÃ«rdorur `#`. Nuk mund t'i qasemi kÃ«tyre variablave jashtÃ« klasÃ«s. Kur provojmÃ« tÃ« printojmÃ« `counter.#number`, hidhet njÃ« SyntaxError: nuk mund t'i qaseni jashtÃ« klasÃ«s `Counter`!

</p>
</details>

---

###### 140. Ã‡farÃ« po mungon?

```javascript
const teams = [
  { name: 'Team 1', members: ['Paul', 'Lisa'] },
  { name: 'Team 2', members: ['Laura', 'Tim'] },
];

function* getMembers(members) {
  for (let i = 0; i < members.length; i++) {
    yield members[i];
  }
}

function* getTeams(teams) {
  for (let i = 0; i < teams.length; i++) {
    // âœ¨ SOMETHING IS MISSING HERE âœ¨
  }
}

const obj = getTeams(teams);
obj.next(); // { value: "Paul", done: false }
obj.next(); // { value: "Lisa", done: false }
```

- A: `yield getMembers(teams[i].members)`
- B: `yield* getMembers(teams[i].members)`
- C: `return getMembers(teams[i].members)`
- D: `return yield getMembers(teams[i].members)`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: B

PÃ«r tÃ« iteruar mbi `members` nÃ« Ã§do element nÃ« array `teams`, duhet tÃ« kaloni `teams[i].members` nÃ« funksionin gjenerator `getMembers`. Funksioni gjenerator kthen njÃ« objekt gjenerator. PÃ«r tÃ« iteruar mbi Ã§do element nÃ« kÃ«tÃ« objekt gjenerator, duhet tÃ« pÃ«rdorim `yield*`.

NÃ«se do tÃ« shkruanim `yield`, `return yield`, ose `return`, gjithÃ« funksioni gjenerator do tÃ« kthehej herÃ«n e parÃ« qÃ« do e thirrim metodÃ«n `next`.

</p>
</details>

---

###### 141. Cila Ã«shtÃ« vlera e saj?

```javascript
const person = {
  name: 'Lydia Hallie',
  hobbies: ['coding'],
};

function addHobby(hobby, hobbies = person.hobbies) {
  hobbies.push(hobby);
  return hobbies;
}

addHobby('running', []);
addHobby('dancing');
addHobby('baking', person.hobbies);

console.log(person.hobbies);
```

- A: `["coding"]`
- B: `["coding", "dancing"]`
- C: `["coding", "dancing", "baking"]`
- D: `["coding", "running", "dancing", "baking"]`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: C

Funksioni `addHobby` merr dy argumente, `hobby` dhe `hobbies` me vlerÃ«n e paracaktuar tÃ« array `hobbies` nÃ« objektin `person`.

SÃ« pari, ne thirrim funksionin `addHobby`, dhe japim `"running"` si vlerÃ« pÃ«r `hobby` dhe njÃ« array bosh si vlerÃ« pÃ«r `hobbies`. Pasi japim njÃ« varg bosh si vlerÃ« pÃ«r `hobbies`, `"running"` shtohet nÃ« kÃ«tÃ« varg bosh.

Pastaj, ne thirrim funksionin `addHobby`, dhe japim `"dancing"` si vlerÃ« pÃ«r `hobby`. Nuk kemi dhÃ«nÃ« vlerÃ« pÃ«r `hobbies`, kÃ«shtu qÃ« ajo merr vlerÃ«n e paracaktuar, vetinÃ« `hobbies` nÃ« objektin `person`. Ne shtojmÃ« hobi `dancing` nÃ« array `person.hobbies`.

NÃ« fund, ne thirrim funksionin `addHobby`, dhe japim `"baking"` si vlerÃ« pÃ«r `hobby`, dhe array `person.hobbies` si vlerÃ« pÃ«r `hobbies`. Ne shtojmÃ« hobi `baking` nÃ« array `person.hobbies`.

Pas shtimit tÃ« `dancing` dhe `baking`, vlera e `person.hobbies` Ã«shtÃ« `["coding", "dancing", "baking"]`

</p>
</details>

---

###### 142. Cila Ã«shtÃ« vlera e saj?

```javascript
class Bird {
  constructor() {
    console.log("I'm a bird. ğŸ¦¢");
  }
}

class Flamingo extends Bird {
  constructor() {
    console.log("I'm pink. ğŸŒ¸");
    super();
  }
}

const pet = new Flamingo();
```

- A: `I'm pink. ğŸŒ¸`
- B: `I'm pink. ğŸŒ¸` `I'm a bird. ğŸ¦¢`
- C: `I'm a bird. ğŸ¦¢` `I'm pink. ğŸŒ¸`
- D: AsgjÃ«, ne nuk kemi thirrur ndonjÃ« metodÃ«.

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: B

KrijojmÃ« variablÃ«n `pet` qÃ« Ã«shtÃ« njÃ« instancÃ« e klasÃ«s `Flamingo`. Kur ne e instantojmÃ« kÃ«tÃ« instancÃ«, thirret `constructor` nÃ« `Flamingo`. SÃ« pari, `"I'm pink. ğŸŒ¸"` printohet, pas tÃ« cilit thirrim `super()`. `super()` thirr constructorin e klasÃ«s prind, `Bird`. Thirret constructori nÃ« `Bird`, dhe printon `"I'm a bird. ğŸ¦¢"`.

</p>
</details>

---

###### 143. Cila nga opsionet rezulton me gabim?

```javascript
const emojis = ['ğŸ„', 'ğŸ…ğŸ¼', 'ğŸ', 'â­'];

/* 1 */ emojis.push('ğŸ¦Œ');
/* 2 */ emojis.splice(0, 2);
/* 3 */ emojis = [...emojis, 'ğŸ¥‚'];
/* 4 */ emojis.length = 0;
```

- A: 1
- B: 1 and 2
- C: 3 and 4
- D: 3

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: D

Fjala kyÃ§e `const` thjesht do tÃ« thotÃ« se nuk mund tÃ« _ri-deklarojmÃ«_ vlerÃ«n e asaj ndryshore, Ã«shtÃ« _vetÃ«m pÃ«r lexim_. MegjithatÃ«, vlera e elementeve tÃ« array nuk Ã«shtÃ« e pandryshueshme. VetitÃ« nÃ« vargun `emojis` mund tÃ« modifikohen, pÃ«r shembull duke shtuar vlera tÃ« reja, duke i shpÃ«rndarÃ« ato, ose duke caktuar gjatÃ«sinÃ« e vargut nÃ« 0.

</p>
</details>

---

###### 144. Ã‡farÃ« duhet tÃ« shtojmÃ« nÃ« objektin `person` pÃ«r tÃ« marrÃ« `["Lydia Hallie", 21]` si rezultat tÃ« `[...person]`?

```javascript
const person = {
  name: "Lydia Hallie",
  age: 21
}

[...person] // ["Lydia Hallie", 21]
```

- A: AsgjÃ«, objektet janÃ« tÃ« iterueshme paraprakisht.
- B: `*[Symbol.iterator]() { for (let x in this) yield* this[x] }`
- C: `*[Symbol.iterator]() { yield* Object.values(this) }`
- D: `*[Symbol.iterator]() { for (let x in this) yield this }`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: C

Objektet nuk janÃ« tÃ« paraprakisht tÃ« iterueshme. NjÃ« objekt Ã«shtÃ« i iterueshÃ«m nÃ«se protokolli i iteratorÃ«ve Ã«shtÃ« prezent. Ne mund ta shtojmÃ« kÃ«tÃ« manualisht duke shtuar simbolin e iteratorit `[Symbol.iterator]`, i cili duhet tÃ« kthejÃ« njÃ« objekt gjenerator, pÃ«r shembull duke e bÃ«rÃ« atÃ« njÃ« funksion gjenerator `*[Symbol.iterator]() {}`. Ky funksion gjenerator duhet tÃ« prodhojÃ« `Object.values` e objektit `person` nÃ«se dÃ«shirojmÃ« qÃ« tÃ« kthejÃ« array `["Lydia Hallie", 21]`: `yield* Object.values(this)`.

</p>
</details>

---

###### 145. Cila Ã«shtÃ« vlera e saj?

```javascript
let count = 0;
const nums = [0, 1, 2, 3];

nums.forEach(num => {
	if (num) count += 1
})

console.log(count)
```

- A: 1
- B: 2
- C: 3
- D: 4

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: C

Kushti `if` brenda ciklit `forEach` kontrollon nÃ«se vlera e `num` Ã«shtÃ« e vÃ«rtetÃ« apo false. MeqenÃ«se numri i parÃ« nÃ« array `nums` Ã«shtÃ« `0`, njÃ« vlerÃ« false, blloku i kodit tÃ« deklaratÃ«s `if` nuk do tÃ« ekzekutohet. `count` rritet vetÃ«m pÃ«r 3 numrat e tjerÃ« nÃ« array `nums`, `1`, `2` dhe `3`. MeqenÃ«se `count` rritet pÃ«r `1` 3 herÃ«, vlera e `count` Ã«shtÃ« `3`.

</p>
</details>

---

###### 146. Cila Ã«shtÃ« vlera e saj?

```javascript
function getFruit(fruits) {
	console.log(fruits?.[1]?.[1])
}

getFruit([['ğŸŠ', 'ğŸŒ'], ['ğŸ']])
getFruit()
getFruit([['ğŸ'], ['ğŸŠ', 'ğŸŒ']])
```

- A: `null`, `undefined`, ğŸŒ
- B: `[]`, `null`, ğŸŒ
- C: `[]`, `[]`, ğŸŒ
- D: `undefined`, `undefined`, ğŸŒ

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: D

Simboli ? na lejon tÃ« i qasemi opsionalisht vetive mÃ« tÃ« thella brenda objekteve. Ne po provojmÃ« tÃ« shfaqim elementin nÃ« indeksin 1 brenda nÃ« nÃ«n-array qÃ« Ã«shtÃ« nÃ« indeksin 1 tÃ« array fruits. NÃ«se nÃ«n-array nÃ« indeksin 1 nÃ« array fruits nuk ekziston, thjesht do tÃ« kthejÃ« undefined. NÃ«se nÃ«n-array nÃ« indeksin 1 nÃ« vargun fruits ekziston, por ky nÃ«n-array nuk ka njÃ« artikull nÃ« indeksin e tij 1, gjithashtu do tÃ« kthejÃ« undefined.

SÃ« pari, ne po pÃ«rpiqemi tÃ« printojmÃ« artikullin e dytÃ« nÃ« nÃ«n-array `['ğŸ']` tÃ« `[['ğŸŠ', 'ğŸŒ'], ['ğŸ']]`. Ky nÃ«n-array pÃ«rmban vetÃ«m  njÃ« element, qÃ« do tÃ« thotÃ« se nuk ka element nÃ« indeksin `1`, dhe kthen `undefined`.

MÃ« pas, ne po thÃ«rrasim funksionin `getFruits` pa kaluar njÃ« vlerÃ« si argument, qÃ« do tÃ« thotÃ« se `fruits` ka vlerÃ« `undefined` tÃ« paracaktuar. Pasi qÃ« po lidhim nÃ« mÃ«nyrÃ« kushtÃ«zuese elementin nÃ« indeksin `1` tÃ« `fruits`, kthen `undefined` pasi ky element nÃ« indeksin `1` nuk ekziston.

SÃ« fundmi, po pÃ«rpiqemi tÃ« shfaqim artikullin e dytÃ« nÃ« nÃ«n-array `['ğŸŠ', 'ğŸŒ']` tÃ« `['ğŸ'], ['ğŸŠ', 'ğŸŒ']`. Elementi nÃ« indeksin `1` brenda kÃ«tij nÃ«n-array Ã«shtÃ« `ğŸŒ` qÃ« printohet.

</p>
</details>

---

###### 147. Cila Ã«shtÃ« vlera e saj?

```javascript
class Calc {
	constructor() {
		this.count = 0 
	}

	increase() {
		this.count++
	}
}

const calc = new Calc()
new Calc().increase()

console.log(calc.count)
```

- A: `0`
- B: `1`
- C: `undefined`
- D: `ReferenceError`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: A

Ne i caktojmÃ« variablÃ«s `calc` tÃ« jetÃ« e barabartÃ« me njÃ« instancÃ« tÃ« re tÃ« klasÃ«s `Calc`. MÃ« pas, ne krijojmÃ« njÃ« instancÃ« tÃ« re tÃ« `Calc`, dhe thÃ«rrasim metodÃ«n `increase` nÃ« kÃ«tÃ« instancÃ«. Pasi qÃ« vetia 'count' Ã«shtÃ« brenda konstruktorit tÃ« klasÃ«s `Calc`, vetia 'calc' nuk Ã«shtÃ« e pÃ«rbashkÃ«t nÃ« prototipin e `Calc`. Kjo do tÃ« thotÃ« se vlera 'calc' nuk Ã«shtÃ« pÃ«rditÃ«suar pÃ«r instancÃ«n qÃ« tregon calc, numÃ«rimi Ã«shtÃ« ende `0`.

</p>
</details>

---

###### 148. Cila Ã«shtÃ« vlera e saj?

```javascript
const user = {
	email: "e@mail.com",
	password: "12345"
}

const updateUser = ({ email, password }) => {
	if (email) {
		Object.assign(user, { email })
	}

	if (password) {
		user.password = password
	}

	return user
}

const updatedUser = updateUser({ email: "new@email.com" })

console.log(updatedUser === user)
```

- A: `false`
- B: `true`
- C: `TypeError`
- D: `ReferenceError`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: B

Funksioni `updateUser` pÃ«rditÃ«son vlerat e vetive `email` dhe `password` nÃ« user, nÃ«se vlerat e tyre i janÃ« kaluar funksionit, pas sÃ« cilÃ«s funksioni kthen objektin `user`. Vlera e kthyer e funksionit `updateUser` Ã«shtÃ« objekti `user`, qÃ« do tÃ« thotÃ« se vlera e updatedUser Ã«shtÃ« njÃ« referencÃ« pÃ«r tÃ« njÃ«jtin objekt `user` qÃ« tregon `user`. `updatedUser === user` Ã«shtÃ« e barabartÃ« me `true`.

</p>
</details>

---

###### 149. Cila Ã«shtÃ« vlera e saj?

```javascript
const fruit = ['ğŸŒ', 'ğŸŠ', 'ğŸ']

fruit.slice(0, 1)
fruit.splice(0, 1)
fruit.unshift('ğŸ‡')

console.log(fruit)
```

- A: `['ğŸŒ', 'ğŸŠ', 'ğŸ']`
- B: `['ğŸŠ', 'ğŸ']`
- C: `['ğŸ‡', 'ğŸŠ', 'ğŸ']`
- D: `['ğŸ‡', 'ğŸŒ', 'ğŸŠ', 'ğŸ']`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: C

SÃ« pari, ne thirrim metodÃ«n `slice` nÃ« array e frutave. Metoda slice nuk modifikon array origjinal, por kthen vlerÃ«n qÃ« e ka 'prerÃ« (slice)' nga array: emoji e bananes.
MÃ« pas, ne thirrim metodÃ«n `splice` nÃ« array e frutave. Metoda splice modifikon array origjinal, qÃ« do tÃ« thotÃ« se array i frutave tani pÃ«rbÃ«het nga `['ğŸŠ', 'ğŸ']`.
NÃ« fund, ne thirrim metodÃ«n `unshift` nÃ« array e frutave, e cila modifikon array origjinal duke shtuar vlerÃ«n e dhÃ«nÃ«, nÃ« kÃ«tÃ« rast â€˜ğŸ‡â€™, si elementin e parÃ« nÃ« varg. Array i frutave tani pÃ«rbÃ«het nga `['ğŸ‡', 'ğŸŠ', 'ğŸ']`.

</p>
</details>

---

###### 150. Cila Ã«shtÃ« vlera e saj?

```javascript
const animals = {};
let dog = { emoji: 'ğŸ¶' }
let cat = { emoji: 'ğŸˆ' }

animals[dog] = { ...dog, name: "Mara" }
animals[cat] = { ...cat, name: "Sara" }

console.log(animals[dog])
```

- A: `{ emoji: "ğŸ¶", name: "Mara" }`
- B: `{ emoji: "ğŸˆ", name: "Sara" }`
- C: `undefined`
- D: `ReferenceError`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: B

Ã‡elÃ«sat e objektit konvertohen nÃ« stringje.

Pasi qÃ« vlera e `dog` Ã«shtÃ« njÃ« objekt, `animals[dog]` nÃ« fakt do tÃ« thotÃ« qÃ« ne po krijojmÃ« njÃ« veti tÃ« re tÃ« quajtur `"object Object"` tÃ« barabartÃ« me objektin e ri. Tani `animals["object Object"]` Ã«shtÃ« i barabartÃ« me `{ emoji: "ğŸ¶", name: "Mara"}`.

`cat` Ã«shtÃ« gjithashtu njÃ« objekt, qÃ« do tÃ« thotÃ« qÃ« `animals[cat]` nÃ« fakt do tÃ« thotÃ« se ne po mbishkruajmÃ« vlerÃ«n e `animals["object Object"]` me vetitÃ« e reja tÃ« macÃ«s.

Duke printuar `animals[dog]`, ose nÃ« fakt `animals["object Object"]` pasi qÃ« konvertimi i objektit `dog` nÃ« string rezulton nÃ« `"object Object"`, kthen `{ emoji: "ğŸˆ", name: "Sara" }`.

</p>
</details>

---

###### 151. Cila Ã«shtÃ« vlera e saj?

```javascript
const user = {
	email: "my@email.com",
	updateEmail: email => {
		this.email = email
	}
}

user.updateEmail("new@email.com")
console.log(user.email)
```

- A: `my@email.com`
- B: `new@email.com`
- C: `undefined`
- D: `ReferenceError`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: A

Funksioni `updateEmail` Ã«shtÃ« njÃ« funksion shigjetÃ« dhe nuk Ã«shtÃ« i lidhur me objektin `user`. Kjo do tÃ« thotÃ« se fjalÃ« kyÃ§e `this` nuk i referohet objektit `user`, por i referohet shtrirjes globale nÃ« kÃ«tÃ« rast. Vlera e `email` brenda objektit `user` nuk pÃ«rditÃ«sohet. Kur printohet vlera e `user.email`, kthehet vlera origjinale e `my@email.com`.

</p>
</details>

---

###### 152. Cila Ã«shtÃ« vlera e saj?

```javascript
const promise1 = Promise.resolve('First')
const promise2 = Promise.resolve('Second')
const promise3 = Promise.reject('Third')
const promise4 = Promise.resolve('Fourth')

const runPromises = async () => {
	const res1 = await Promise.all([promise1, promise2])
	const res2  = await Promise.all([promise3, promise4])
	return [res1, res2]
}

runPromises()
	.then(res => console.log(res))
	.catch(err => console.log(err))
```

- A: `[['First', 'Second'], ['Fourth']]`
- B: `[['First', 'Second'], ['Third', 'Fourth']]`
- C: `[['First', 'Second']]`
- D: `'Third'`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: D

Metoda `Promise.all` ekzekuton premtimet e dhÃ«na si argumente paralelisht. NÃ«se njÃ« premtim dÃ«shton, metoda 'Promise.all' _refuzon_ me vlerÃ«n e premtimit tÃ« refuzuar. NÃ« kÃ«tÃ« rast, `promise3` u refuzua me vlerÃ«n `"Third"`. Ne po kapim vlerÃ«n e refuzuar nÃ« metodÃ«n `catch` nÃ« thirrjen `runPromises` pÃ«r tÃ« kapur Ã§do gabim brenda funksionit `runPromises`. VetÃ«m `"Third"` printohet, pasi `promise3` u refuzua me kÃ«tÃ« vlerÃ«.

</p>
</details>

---

###### 153. Cila duhet tÃ« jetÃ« vlera e `method` pÃ«r tÃ« printuar `{ name: "Lydia", age: 22 }`?

```javascript
const keys = ["name", "age"]
const values = ["Lydia", 22]

const method = /* ?? */
Object[method](keys.map((_, i) => {
	return [keys[i], values[i]]
})) // { name: "Lydia", age: 22 }
```

- A: `entries`
- B: `values`
- C: `fromEntries`
- D: `forEach`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: C

Metoda `fromEntries` transformon njÃ« array 2d nÃ« njÃ« objekt. Elementi i parÃ« nÃ« Ã§do nÃ«n-array do tÃ« jetÃ« Ã§elÃ«si, dhe elementi i dytÃ« nÃ« Ã§do nÃ«n-array do tÃ« jetÃ« vlera. NÃ« kÃ«tÃ« rast, ne jemi duke mapuar mbi array `keys`, i cili kthen njÃ« array ku elementi i parÃ« Ã«shtÃ« elementi nÃ« array tÃ« Ã§elÃ«save nÃ« indeksin aktual, dhe elementi i dytÃ« Ã«shtÃ« elementi i vlerave tÃ« array  nÃ« indeksin aktual.

Kjo krijon njÃ« array tÃ« nÃ«n-arrays qÃ« pÃ«rmbajnÃ« Ã§elÃ«sat dhe vlerat e duhura, tÃ« cilat rezultojnÃ« nÃ« `{ name: "Lydia", age: 22 }`

</p>
</details>

---

###### 154. Cila Ã«shtÃ« vlera e saj?

```javascript
const createMember = ({ email, address = {}}) => {
	const validEmail = /.+\@.+\..+/.test(email)
	if (!validEmail) throw new Error("Valid email pls")

	return {
		email,
		address: address ? address : null
	}
}

const member = createMember({ email: "my@email.com" })
console.log(member)
```

- A: `{ email: "my@email.com", address: null }`
- B: `{ email: "my@email.com" }`
- C: `{ email: "my@email.com", address: {} }`
- D: `{ email: "my@email.com", address: undefined }`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: C

Vlera e paracaktuar e `address` Ã«shtÃ« njÃ« objekt i zbrazÃ«t `{}`. Kur vendosÃ«m variablÃ«n `member` tÃ« barabartÃ« me objektin qÃ« kthehet nga funksioni `createMember`, ne nuk kaluam njÃ« vlerÃ« pÃ«r adresÃ«n, qÃ« do tÃ« thotÃ« se vlera e adresÃ«s Ã«shtÃ« objekti i zbrazÃ«t parazgjedhur `{}`. NjÃ« objekt i zbrazÃ«t Ã«shtÃ« njÃ« vlerÃ« e vÃ«rtetÃ«, qÃ« do tÃ« thotÃ« se gjendja e `address ? address : null` kushtÃ«zuese kthehet `true`. Vlera e adresÃ«s Ã«shtÃ« objekti i zbrazÃ«t `{}`.

</p>
</details>

---

###### 155. Cila Ã«shtÃ« vlera e saj?

```javascript
let randomValue = { name: "Lydia" }
randomValue = 23

if (!typeof randomValue === "string") {
	console.log("It's not a string!")
} else {
	console.log("Yay it's a string!")
}
```

- A: `It's not a string!`
- B: `Yay it's a string!`
- C: `TypeError`
- D: `undefined`

<details><summary><b>PÃ«rgjigja</b></summary>
<p>

#### PÃ«rgjigja: B

Kushti brenda deklaratÃ«s `if` kontrollon nÃ«se vlera e `!typeof randomValue` Ã«shtÃ« e barabartÃ« me `"string"`. Operatori `!` e shndÃ«rron vlerÃ«n nÃ« njÃ« vlerÃ« booleane. NÃ«se vlera Ã«shtÃ« e vÃ«rtetÃ«, vlera e kthyer do tÃ« jetÃ« `false`, nÃ«se vlera Ã«shtÃ« e pavÃ«rtetÃ«, vlera e kthyer do tÃ« jetÃ« `true`. NÃ« kÃ«tÃ« rast, vlera e kthyer e `typeof randomValue` Ã«shtÃ« vlera e vÃ«rtetÃ« `"number"`, qÃ« do tÃ« thotÃ« se vlera e `!typeof randomValue` Ã«shtÃ« vlera booleane `false`.

`!typeof randomValue === "string"` gjithmonÃ« kthen false, pasi nÃ« fakt po kontrollojmÃ« `false === "string"`. Pasi qÃ« kushtÃ«zimi ktheu `false`, blloku i kodit tÃ« deklaratÃ«s `else` ekzekutohet, dhe `Yay it's a string!` printohet.

</p>
</details>
