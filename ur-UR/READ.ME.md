(اعلی) جاوا سوالات کے # لسٹ

میں نے روزانہ ایک سے زیادہ پسند میری [انسٹاگرام] (https://www.instagram.com/theavocoder) پر جاوا سوالات، جس میں میں نے بھی یہاں پوسٹ کریں گے پوسٹ!

اعلی درجے کی بنیادی سے: کس طرح آپ کو جاوا اسکرپٹ جانتے ٹیسٹ، آپ کے علم میں تھوڑا سا تروتازہ، یا آپ کو کوڈنگ انٹرویو کے لئے تیار! : پٹھوں: راکٹ: میں نے نئے سوالات کے ساتھ اس ریپو ہفتہ وار اپ ڈیٹ کریں. آخری اپ ڈیٹ: <a href=#20191009> میں <b> اکتوبر 9th </ b> کے لئے

جوابات سوالات کے ذیل میں گرنے والی حصوں میں ہیں، صرف اس کو بڑھانے کے لئے ان پر کلک کریں. گڈ لک: دل:

ایک ای میل میں مزید سوالات میں شامل کیا ہے جب بھی حاصل کرنے کے لئے چاہتے ہیں؟ <br />
<a target="_blank" href="https://www.theavocoder.com/subscribe"> میں <b> ✨✉Subscribe updates✉✨ ای میل کرنے </ b> کے لئے


دستیاب زبانوں کی فہرست:
* [انگریزی] (../ EN-EN / README.md)
* [العربية] (../ AR-AR / README_AR.md)
* [اللغة العامية - مصری عربی] (../ AR-EG / README_ar-EG.md)
* [بوسانسکی] (../ BS-BS / README-bs_BS.md) 
* [Deutsch کی] (../ ڈی DE / README.md) 
* [Español کی] (../ ES-ES / README-ES.md)
* [اردو] (../ FR-FR / README_fr-FR.md)
* [日本語] (../ JA-JA / README-ja_JA.md) 
* [한국어] (../ KO-KR / README-ko_KR.md) 
* [پرتگالی برازیل] (../ PT-BR / README_pt_BR.md) 
* [Русский] (../ RU-RU / README.md)
* [Українська мова] (../ UA-UA / README-ua_UA.md) 
* [سے Tiếng Việt کی] (../ VI-VI / README-vi.md)
* [中文 版本] (../ ZH-CN / README-zh_CN.md)
* [اردو] (../ TR-TR / README-tr_TR.md)
* [ไทย] (../ TH-TH / README-th_TH.md)


---

###### 1. پیداوار کیا ہے؟

`` `جاوا سکرپٹ
sayHi تقریب () {
 console.log کے (نام)؛
 console.log کے (عمر)؛
 متغیر کا نام = "لڈا"؛
 عمر دو = 21؛
}

کہو ہائے()؛
`` `

- A: `Lydia` اور` undefined`
- B: `Lydia` اور` ReferenceError`
- C: `ReferenceError` اور` 21`
- D: `undefined` اور` ReferenceError`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

#### جواب: D

تقریب کے اندر اندر، ہم سب سے پہلے `var` مطلوبہ الفاظ کے ساتھ` name` متغیر کا اعلان. اس کا مطلب ہے کہ متغیر، undefined` `کے پہلے سے طے شدہ قیمت کے ساتھ (میموری کی جگہ کی تخلیق کے مرحلے کے دوران قائم کیا جاتا ہے) کشائی ہو جاتا ہے ہم اصل میں ہم متغیر کی وضاحت جہاں لائن حاصل ہے جب تک. ہم لکیر ہم `name` متغیر لاگ ان کرنے کی کوشش کریں جہاں پر ابھی تک متغیر کی وضاحت نہیں کی ہے، تو یہ اب بھی undefined`` کی قدر رکھتا ہے.

`let` مطلوبہ الفاظ کی (اور` const`) کے ساتھ متغیر کشائی کی ہیں، لیکن var` `برعکس ملے <i> کے initialized نہیں کرتے </ i> کے. وہ قابل رسائی نہیں ہیں اس سے پہلے کی لکیر ہم اعلان (ابتدا) ان. یہ "دنیاوی مردہ زون" کہا جاتا ہے. ہم وہ اعلان کر رہے ہیں اس سے پہلے متغیر تک رسائی حاصل کرنے کی کوشش کرتے ہیں، جاوا سکرپٹ کو ایک `ReferenceError` ڈالی ہے.

</ P>
</ تفصیلات>

---

###### 2. آؤٹ پٹ کیا ہے؟

`` `جاوا سکرپٹ
کے لئے (متغیر میں = 0؛ میں <3؛ میں + +) {
 setTimeout (() => console.log کے (میں)، 1)؛
}

کے لئے (میں = 0 تاکہ میں 3 <؛ میں + +) {
 setTimeout (() => console.log کے (میں)، 1)؛
}
`` `

- A: `0 1 2` اور` 0 1 2`
- B: `0 1 2` اور` 3 3 3`
- C: `3 3 3` اور` 0 1 2`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: C

کیونکہ جاوا اسکرپٹ میں تقریب قطار کے، `setTimeout` کال بیک تقریب _after_ لوپ پھانسی دے دی گئی ہے کہا جاتا ہے. چونکہ پہلی لوپ میں متغیر `i`` var` مطلوبہ لفظ کو استعمال کرتے ہوئے اعلان کیا گیا تھا، اس کی قیمت عالمی تھے. لوپ کے دوران، ہم `کی قدر` طرف 1` ہر وقت i`، یک رکنی آپریٹر `استعمال کرتے ہوئے` incremented کیا ++. وقت `setTimeout` کال بیک تقریب کو لاگو کیا گیا تھا کی طرف سے،` i` پہلی مثال میں `3` کے برابر تھا.

دوسری لوپ میں، متغیر `i`` let` مطلوبہ لفظ کو استعمال کرتے ہوئے اعلان کیا گیا تھا: متغیر `let` (اور` const`) مطلوبہ الفاظ کے ساتھ اعلان بلاک سکوپ (ایک بلاک `{}` درمیان کچھ بھی ہے) ہے. ہر iteration کے دوران `i` ایک نئی قیمت پڑے گا، اور ہر قیمت کے لوپ کے اندر سکوپ رہا ہے.

</ P>
</ تفصیلات>

---

###### 3. آؤٹ پٹ کیا ہے؟

`` `جاوا سکرپٹ
CONST شکل = {
 رداس: 10،
 قطر () {
 this.radius * 2 واپس؛
 }،
 فریم: () => 2 * Math.PI * this.radius
}؛

console.log کے (shape.diameter ())؛
console.log کے (shape.perimeter ())؛
`` `

- A: `20` اور` 62.83185307179586`
- B: `20` اور` NaN`
- C: `20` اور` 63`
- D: `NaN` اور` 63`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: بی

ایک باقاعدہ تقریب ہے کہ diameter` `کی قدر perimeter`` کی قدر ایک تیر تقریب ہے جبکہ رکھیں کہ.

تیر کے افعال کے ساتھ، `this` مطلوبہ الفاظ کی باقاعدہ افعال کے برعکس، اس کی موجودہ ارد گرد کے دائرہ کار سے مراد! اس کا مطلب یہ ہے کہ جب ہم `perimeter` کو فون، یہ شکل میں غالب نہیں کرتا، لیکن اس کے ارد گرد دائرہ کار کو (مثلا ونڈو).

اس اعتراض، `واپس جس undefined` پر کوئی قدر` radius` نہیں ہے.

</ P>
</ تفصیلات>

---

###### 4. پیداوار کیا ہے؟

`` `جاوا سکرپٹ
+ سچا؛
! "لڈا"؛
`` `

- A: `1` اور` FALSE`
- B: `FALSE` اور` NaN`
- C: `FALSE` اور` FALSE`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: ایک

یک رکنی علاوہ ایک بڑی تعداد کے لئے ایک اوپیرانڈ میں تبدیل کرنے کی کوشش کرتا ہے. `TRUE`` 1` FALSE` `0` ہے، اور`.

سٹرنگ ` 'Lydia'` ایک truthy قدر ہے. ہم اصل میں پوچھ رہے ہیں کیا، "اس truthy قدر falsy ہے؟" ہے. یہ `FALSE` لوٹاتا ہے.

</ P>
</ تفصیلات>

---

###### 5. کون سا سچ ہے؟

`` `جاوا سکرپٹ
CONST پرندوں = {
 سائز: "چھوٹے"
}؛

CONST ماؤس = {
 نام: "مکی"،
 چھوٹے: سچ
}؛
`` `

- A: `mouse.bird.size` درست نہیں ہے
- B: `ماؤس [bird.size]` نہ درست ہے
- C: `ماؤس [چڑیا [" سائز "]]` نہ درست ہے
- D: ان میں سے سب درست ہیں

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: ایک

جاوا میں، تمام اعتراض چابیاں ڈور ہیں (یہ ایک علامت ہے، جب تک). ہم ڈور کے طور پر ان _type_ نہیں ہو سکتا اگرچہ، وہ ہمیشہ ہڈ کے تحت ڈور میں تبدیل کیا جاتا ہے.

جاوا ترجمانی کرتا ہے (یا unboxes) کے بیانات. ہم بریکٹ سنکیتن کا استعمال کرتے ہیں تو، یہ سب سے پہلے افتتاحی بریکٹ `دیکھتا [` اور یہ اختتامی بریکٹ `پائے تک جا رکھتا]`. صرف اس صورت میں، یہ بیان اندازہ ہو گی.

`ماؤس [bird.size]`: سب سے پہلے یہ `bird.size`، جس` "چھوٹے" `تشخیص کرتا ہے. `ماؤس [" چھوٹے "]` ریٹرن `TRUE`

تاہم، ڈاٹ سنکیتن کے ساتھ، ایسا نہیں ہے. `mouse` جس` کہ mouse.bird` `undefined` ہے کا مطلب ہے کہ` bird` نامی ایک اہم، ضروری نہیں ہے. `mouse.bird.size`: اس کے بعد، ہم ڈاٹ سنکیتن کا استعمال کرتے ہوئے` size` لئے پوچھنا. چونکہ `mouse.bird`` undefined`، ہم اصل undefined.size` پوچھ رہے ہیں کیا جاتا ہے `. یہ درست نہیں ہے، اور `undefined` کی ملکیت نہیں پڑھ سکتا" سائز "سے ملتے جلتے ایک خرابی پھینک دیں گے.

</ P>
</ تفصیلات>

---


###### 6. پیداوار کیا ہے؟

`` `جاوا سکرپٹ
دو C = {سلام: "ارے!" }؛
د دے.

D = C؛
c.greeting = "ہیلو".
console.log کے (d.greeting)؛
`` `

- A: `Hello`
- B: `ارے`
- C: `undefined`
- D: `ReferenceError`
- E: `TypeError`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: ایک

انہیں ایک دوسرے کے برابر کی ترتیب جب جاوا میں، تمام اشیاء _reference_ طرف تعامل کرتے ہیں.

سب سے پہلے، متغیر `c` کسی چیز کے لئے ایک قیمت رکھتا ہے. بعد میں، ہم `اسی ریفرنس` کہ c` اعتراض کرنے کے لئے ہے کے ساتھ d` تفویض.

<IMG ایسآرسی = "https://i.imgur.com/ko5k0fs.png" چوڑائی = "200">

آپ ایک چیز کو تبدیل کرتے ہیں، آپ ان میں سے سب کو تبدیل.

</ P>
</ تفصیلات>

---

###### 7. پیداوار کیا ہے؟

`` `جاوا سکرپٹ
دو ایک = 3؛
دو ب = نیا نمبر (3)؛
ج دو = 3؛

console.log کے (ایک == ب)؛
console.log کے (ایک === ب)؛
console.log کے (ب === C)؛
`` `

- A: `TRUE`` FALSE` `TRUE`
- B: `FALSE`` FALSE` `TRUE`
- C: `TRUE`` FALSE` `FALSE`
- D: `FALSE`` TRUE` `TRUE`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: C

`نئے نمبر ()` ایک بلٹ میں تقریب تعمیر ہے. یہ ایک بڑی تعداد کی طرح لگتا ہے، لیکن یہ واقعی ایک نمبر نہیں ہے: یہ اضافی خصوصیات میں سے ایک گروپ ہے اور کسی چیز کی ہے.

ہم `==` آپریٹر کا استعمال کرتے ہیں، تو یہ صرف یہ ایک ہی _value_ ہے چاہے وہ چیک کرتا ہے. وہ دونوں `3` کی قدر ہے، تو یہ` TRUE` واپس.

تاہم، ہم `===` آپریٹر کا استعمال کرتے ہیں، دونوں کی قدر _and_ قسم کے ایک ہی ہونا چاہئے. یہ نہیں ہے: `نیا نمبر ()` نہیں ایک بڑی تعداد، یہ ایک ** اعتراض ہے ہے **. دونوں واپسی `false.`

</ P>
</ تفصیلات>

---

###### 8. پیداوار کیا ہے؟

`` `جاوا سکرپٹ
کلاس گرگٹ {
 جامد colorChange (newColor) {
 this.newColor = newColor؛
 this.newColor واپس؛
 }

 ڈویلپر ({newColor = "گرین"} = {}) {
 this.newColor = newColor؛
 }
}

CONST ئیڈی = نئے گرگٹ ({newColor: "جامنی"})؛
console.log کے (freddie.colorChange ( "اورنج"))؛
`` `

- A: `orange`
- B: `purple`
- C: `green`
- D: `TypeError`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

#### جواب: D

`colorChange` تقریب مستحکم ہے. جامد طریقوں کو جس میں وہ پیدا کر رہے ہیں تعمیر پر رہنے کے لئے تیار کیا گیا ہے، اور کسی بھی بچے کو نیچے منظور نہیں کیا جا سکتا. چونکہ `freddie` ایک بچہ ہے، تقریب نیچے منظور نہیں ہے، اور` freddie` مثال پر دستیاب نہیں ہے: ایک `TypeError` پھینک دیا جاتا ہے.

</ P>
</ تفصیلات>

---

###### 9. آؤٹ پٹ کیا ہے؟

`` `جاوا سکرپٹ
سلام دو؛
greetign = {}؛ // ٹائپنگ میں کوئی!
console.log کے (greetign)؛
`` `

- A: `{}`
- B: `ReferenceError: greetign نہیں defined` ہے
- C: `undefined`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: ایک

ہم صرف عالمی شئی پر ایک خالی اعتراض پیدا کیونکہ یہ اعتراض نوشتہ! ہم `طور greeting` غلط ٹائپ کرتے وقت` greetign`، جے ایس مترجم اصل میں اس طور `global.greetign = دیکھا {}` (یا `window.greetign = {}` ایک براؤزر میں).

اس سے بچنے کے لئے، ہم "سخت استعمال کرتے ہیں" `استعمال کریں` کر سکتے ہیں. یہ اس بات کا یقین ہے کہ آپ جو کچھ بھی اس کے برابر مقرر کرنے سے پہلے ایک متغیر کا اعلان کر دیا ہوتا ہے.

</ P>
</ تفصیلات>

---

###### 10. ہم اس کو کیا کرنا تو کیا ہوتا؟

`` `جاوا سکرپٹ
تقریب چھال () {
 console.log کے ( "Woof کی!")؛
}

bark.animal = "کتے"؛
`` `

- A: کچھ نہیں، یہ مکمل طور پر ٹھیک ہے!
- B: `SyntaxError`. آپ کو اس طرح ایک تقریب کے لیے خواص کو شامل نہیں کر سکتے.
- C: `" Woof کی "` ریکارڈ ہو جاتا ہے.
- D: `ReferenceError`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: ایک

یہ افعال اشیاء ہیں، کیونکہ جاوا میں ممکن ہے! (سب کچھ اس کے علاوہ قدیم اقسام کی اشیاء ہیں)

ایک تقریب اعتراض کی ایک خاص قسم ہے. کوڈ آپ اپنے آپ کو لکھنے کے اصل تقریب نہیں ہے. تقریب کی خصوصیات کے ساتھ کسی چیز ہے. اس کی خاصیت invocable ہے.

</ P>
</ تفصیلات>

---

###### 11. آؤٹ پٹ کیا ہے؟

`` `جاوا سکرپٹ
تقریب شخص (FIRSTNAME، LASTNAME) {
 this.firstName = FIRSTNAME؛
 this.lastName = LASTNAME؛
}

CONST رکن = نئے شخص ( "لڈا"، "Hallie")؛
Person.getFullName = تقریب () {
 واپسی `$ {this.firstName} $ {this.lastName}`؛
}؛

console.log کے (member.getFullName ())؛
`` `

- A: `TypeError`
- B: `SyntaxError`
- C: `لڈا Hallie`
- D: `undefined`` undefined`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: ایک

آپ کو باقاعدگی اشیاء کے ساتھ یہ کر سکتے ہیں کی طرح آپ کو ایک تعمیر کرنے کے لئے خصوصیات کو شامل نہیں کرسکتے. آپ ایک ہی بار میں تمام اشیاء کے لئے ایک خصوصیت شامل کرنے کے لئے چاہتے ہیں، تو آپ اس کے بجائے پروٹوٹائپ استعمال کرنا ہے. تو اس صورت میں،

`` `JS
Person.prototype.getFullName = تقریب () {
 واپسی `$ {this.firstName} $ {this.lastName}`؛
}؛
`` `

`member.getFullName ()` کام کر دیا جاتا. یہ کیوں فائدہ مند ہے؟ ہم ڈویلپر خود کو اس طریقے سے شامل ہے کہ کہیں. ہو سکتا ہے کہ نہیں ہر `Person` مثال اس طریقہ کار کی ضرورت ہے. وہ اب بھی اس کی جائداد، جس سے ہر مثال کے طور پر میموری کی جگہ کے لیتا ہوگا کیونکہ یہ میموری کی جگہ کی ایک بہت برباد کرے گا. اس کے بجائے، ہم صرف پروٹوٹائپ کو اس میں شامل ہے تو، ہم صرف یہ ایک ہی جگہ پر یاد میں ہے، ابھی تک وہ سب کے سب اس تک رسائی حاصل!

</ P>
</ تفصیلات>

---

###### 12. آؤٹ پٹ کیا ہے؟

`` `جاوا سکرپٹ
تقریب شخص (FIRSTNAME، LASTNAME) {
 this.firstName = FIRSTNAME؛
 this.lastName = LASTNAME؛
}

CONST لڈا = نئے شخص ( "لڈا"، "Hallie")؛
CONST میں سارہ = شخص ( "سارہ"، "سمتھ")؛

console.log کے (لدیہ)؛
console.log کے (سارہ)؛
`` `

- A: `شخص {FIRSTNAME:" لڈا "، LASTNAME:" Hallie "}` اور `undefined`
- B: `شخص {FIRSTNAME:" لڈا "، LASTNAME:" Hallie "}` اور `شخص {FIRSTNAME:" سارہ "، LASTNAME:" سمتھ "}`
- C: `شخص {FIRSTNAME:" لڈا "، LASTNAME:" Hallie "}` اور `{}`
- D: `شخص {FIRSTNAME:" لڈا "، LASTNAME:" Hallie "}` اور `ReferenceError`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: ایک

`sarah` لئے، ہم` new` مطلوبہ لفظ استعمال نہیں کیا. `new` استعمال کرتے وقت، یہ ہے کہ ہم تخلیق نئے خالی اعتراض سے مراد ہے. تاہم، اگر آپ `new` جو ** عالمی اعتراض سے مراد ** شامل نہیں ہے!

ہم `this.firstName` برابر` "سارہ" `اور` this.lastName` برابر `" سمتھ "` کہا. ہم اصل میں کیا کیا، وضاحت کر رہا ہے `global.firstName = 'Sarah'` اور` global.lastName =' Smith'`. `sarah` خود بائیں` undefined` ہے، ہم `Person` تقریب سے ایک قدر واپس نہیں ہے کے بعد سے.

</ P>
</ تفصیلات>

---

###### 13. واقعہ بازی کے تین مراحل کیا ہیں؟

- A: ٹارگٹ> قبضہ> سے bubbling
- B: ابل> کے ھدف> قبضہ
- C: ٹارگٹ> سے bubbling> قبضہ
- D: قبضہ> کے ھدف> سے bubbling

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

#### جواب: D

** قبضہ ** مرحلے کے دوران، واقعہ ٹارگٹ عنصر کے لئے نیچے پرکھا عناصر سے گزرتا ہے. اس کے بعد یہ *** ہدف ** عنصر پہنچ جاتا ہے، اور ** سے bubbling ** شروع ہوتا ہے.

<IMG ایسآرسی = "https://i.imgur.com/N18oRgd.png" چوڑائی = "200">

</ P>
</ تفصیلات>

---

###### 14. تمام اعتراض prototypes کی ہے.

- ایک سچا
- B: جھوٹے

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: بی

تمام اشیاء ** بیس اعتراض **، سوائے prototypes کی ہے. بیس اعتراض صارف، یا `new` مطلوبہ لفظ استعمال کرتے ہوئے تخلیق کیا جاتا ہے کہ کسی چیز کی طرف سے پیدا اعتراض ہے. بیس اعتراض جیسے `.toString` کچھ طریقوں اور خصوصیات، تک رسائی حاصل ہے. اس سے آپ کو بلٹ میں استعمال کر سکتے کیوں جاوا طریقوں کی وجہ سے ہے! اس طرح کے طریقوں کے تمام پروٹوٹائپ پر دستیاب ہیں. جاوا اسکرپٹ اپنے اعتراض پر براہ راست اسے تلاش نہیں کر سکتے ہیں اگرچہ، یہ پروٹوٹائپ چین کے نیچے جاتا ہے اور یہ آپ کے لئے قابل رسائی بناتا ہے جس نے یہ پتہ چلا ہے.

</ P>
</ تفصیلات>

---

###### 15. آؤٹ پٹ کیا ہے؟

`` `جاوا سکرپٹ
تقریب رقم (A، B) {
 A + B واپس؛
}

رقم (1، "2")؛
`` `

- A: `NaN`
- B: `TypeError`
- C: `" 12 "`
- D: `3`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: C

جاوا سکرپٹ ایک ** متحرک طور پر ٹائپ زبان ** ہے ہم بعض متغیر ہیں کس قسم کی وضاحت نہیں کرتے. قدریں خود بخود آپ کو یہ جان کر جس _implicit قسم coercion_ کہا جاتا ہے کے بغیر ایک اور قسم میں تبدیل کیا جا سکتا ہے. ** جبر ** دوسرے میں ایک قسم سے تبدیل کیا جاتا ہے.

اس مثال میں، جاوا تعداد میں `1` ایک تار میں، احساس کرے اور ایک قدر واپس کرنے کی تقریب کے لئے ترتیب میں بدل دیتا ہے. ایک عددی قسم ( `1`) اور ایک سٹرنگ کی قسم کے علاوہ دوران (` '2'`)، نمبر ایک سٹرنگ کے طور پر علاج کیا جاتا ہے. ہم جیسے `" ہیلو "+" دنیا "` ڈور سلسلہ بندی کرنا کر سکتے ہیں، تو یہاں کیا ہو رہا ہے `" 1 "+" 2 "` واپس جس `" 12 "` ہے.

</ P>
</ تفصیلات>

---

###### 16. آؤٹ پٹ کیا ہے؟

`` `جاوا سکرپٹ
تعداد کی اجازت = 0؛
console.log کے (نمبر ++)؛
console.log کے (++ تعداد)؛
console.log کے (تعداد)؛
`` `

- A: `1`` 1` `2`
- B: `1`` 2` `2`
- C: `0`` 2` `2`
- D: `0`` 1` `2`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: C

** postfix ** یک رکنی آپریٹر `++`:

1. قیمت (اس کی واپسی `0`) لوٹاتا
2. دھیرے بڑھتا قیمت (تعداد اب ہے `1`)

** سابقہ ​​** یک رکنی آپریٹر `++`:

1. دھیرے بڑھتا قیمت (تعداد اب ہے `2`)
2. قدر (اس کی واپسی `2`) لوٹاتا

یہ `0 2 2` واپس.

</ P>
</ تفصیلات>

---

###### 17. آؤٹ پٹ کیا ہے؟

`` `جاوا سکرپٹ
getPersonInfo (ایک، دو، تین) تقریب {
 console.log کے (ایک)؛
 console.log کے (دو)؛
 console.log کے (تین)؛
}

CONST شخص = "لڈا"؛
CONST عمر = 21؛

getPersonInfo` $ {شخص} $ {عمر} سال old` ہے؛
`` `

- A: `" لڈا "` `21`` [ ""، "ہے"، "سال کی عمر میں"] `
- B: `[" "،" ہے "،" سال کی عمر میں "]` `" لڈا "` `21`
- C: `" لڈا "` `` `[" "،" "،" سال کی عمر "ہے] 21`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: بی

آپ کو ٹیگ سانچے لاٹرالس استعمال کرتے ہیں تو، سب سے پہلے دلیل کی قدر ہمیشہ سٹرنگ اقدار کی ایک صف ہے. باقی دلائل منظور اظہارات کی اقدار حاصل کریں!

</ P>
</ تفصیلات>

---

###### 18. آؤٹ پٹ کیا ہے؟

`` `جاوا سکرپٹ
تقریب checkAge (ڈیٹا) {
 اگر (ڈیٹا === {عمر: 18}) {
 console.log کے ( "آپ ایک بالغ ہو!")؛
 } ورنہ اگر (ڈیٹا == {عمر: 18}) {
 console.log کے ( "آپ اب بھی ایک بالغ ہو.")؛
 } ورنہ {
 console.log کے ( `ہمم .. تم ایک سال کی عمر میں guess` ضرورت نہیں ہے)؛
 }
}

checkAge ({عمر: 18})؛
`` `

- A: `آپ بالغ ہیں`!
- B: `آپ کو اب بھی ایک adult.` ہیں
- C: `ہمم .. تم ایک سال کی عمر میں guess` ضرورت نہیں ہے

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: C

مساوات جانچ کرتے ہیں، primitives میں، ان کے _value_ طرف نسبت کرتے ہوئے اشیاء کو ان کے _reference_ طرف نسبت کر رہے ہیں کر رہے ہیں. اشیاء کی یاد میں ایک ہی مقام پر ایک حوالہ ہے تو جاوا چیک کرتا ہے.

دو اشیاء کہ ہم موازنہ کر رہے ہیں کہ نہیں ہے: اعتراض ہم ایک پیرامیٹر کے طور پر منظور کیا ہم مساوات چیک کرنے کے لیے استعمال کیا اعتراض سے زیادہ یاد میں ایک مختلف جگہ سے مراد ہے.

=== {عمر: 18} `اور` {عمر: 18} == {عمر: 18} `واپسی` FALSE`: یہ کیوں دونوں `{18 عمر} ہے.

</ P>
</ تفصیلات>

---

###### 19. آؤٹ پٹ کیا ہے؟

`` `جاوا سکرپٹ
کام getAge (... ARGS) {
 console.log کے (typeof ARGS)؛
}

getAge (21)؛
`` `

- A: `" تعداد "`
- B: `" صف "`
- C: `" اعتراض "`
- D: `" نےن "`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: C

باقی پیرامیٹر ( `... args`.) کی اجازت دیتا ہے ہمیں ایک صف میں تمام باقی دلائل" جمع ". ایک صف، کسی چیز ہے تاکہ `ریٹرن args`` "اعتراض" typeof `

</ P>
</ تفصیلات>

---

###### 20. آؤٹ پٹ کیا ہے؟

`` `جاوا سکرپٹ
تقریب getAge () {
 "سخت استعمال کرتے ہیں"؛
 عمر = 21؛
 console.log کے (عمر)؛
}

getAge ()؛
`` `

- A: `21`
- B: `undefined`
- C: `ReferenceError`
- D: `TypeError`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: C

`" سخت استعمال کرتے ہیں "` ساتھ، آپ کو کہ آپ نے غلطی عالمی متغیر کا اعلان نہیں کرتے اس بات کو یقینی بنا سکتے ہیں. ہم متغیر `age` اعلان کر دیا کبھی نہیں، اور اس کے بعد ہم استعمال` "سخت استعمال کرتے ہیں" `، یہ ایک حوالہ کی خرابی پھینک دیں گے. ہم `استعمال نہیں کیا تو" سخت استعمال کرتے ہیں "`، یہ کام کیا گیا ہوتا جائیداد کے بعد `age` عالمی اعتراض میں شامل کر دیا گیا ہوتا.

</ P>
</ تفصیلات>

---

###### 21. کس کی قدر `sum`؟

`` `جاوا سکرپٹ
CONST رقم = سے Eval ( "10 * 10 + 5")؛
`` `

- A: `105`
- B: `" 105 "`
- C: `TypeError`
- D: `" 10 * 10 + 5 "`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: ایک

`eval` ایک سٹرنگ کے طور پر منظور کیا گیا ہے کہ کوڈ کی تشخیص کرتا ہے. یہ ایک اظہار ہے، اس معاملے میں کی طرح ہے، تو یہ اظہار رائے کی تشخیص کرتا ہے. اظہار `10 * 10 + 5` ہے. یہ نمبر `105` واپس.

</ P>
</ تفصیلات>

---

###### 22. کتنی دیر cool_secret رسائی ہے؟

`` `جاوا سکرپٹ
sessionStorage.setItem (123 "cool_secret"،)؛
`` `

- A: ہمیشہ، ڈیٹا کھو نہیں کرتا.
- B: صارف جب ٹیب بند کرتا ہے.
- C: صارف پورے براؤزر، نہ صرف ٹیب کو بند کر دیتا ہے جب.
- ڈی: صارف کو ان کے کمپیوٹر بند جب.

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: بی

`sessionStorage` میں اکٹھا ڈیٹا _tab_ بند کرنے کے بعد ہٹا دیا جاتا ہے.

آپ نے استعمال تو `localStorage`، ڈیٹا وہاں ہمیشہ ہوتا جب تک کہ مثال کے` localStorage.clear () `ومباحثہ ہے.

</ P>
</ تفصیلات>

---

###### 23. آؤٹ پٹ کیا ہے؟

`` `جاوا سکرپٹ
متغیر NUM = 8؛
متغیر NUM = 10؛

console.log کے (NUM)؛
`` `

- A: `8`
- B: `10`
- C: `SyntaxError`
- D: `ReferenceError`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: بی

`var` مطلوبہ الفاظ کے ساتھ، آپ کو ایک ہی نام کے ساتھ ایک سے زیادہ متغیر کا اعلان کر سکتے ہیں. متغیر پھر تازہ ترین قدر کریں گے.

وہ بلاک سکوپ ہیں کے بعد سے آپ `let` یا` const` کے ساتھ ایسا نہیں کر سکتے.

</ P>
</ تفصیلات>

---

###### 24. آؤٹ پٹ کیا ہے؟

`` `جاوا سکرپٹ
CONST پر obj = {1: "ایک"، 2: "B"، 3: "C"}؛
CONST سیٹ = نیا سیٹ ([1، 2، 3، 4، 5])؛

obj.hasOwnProperty ( "1")؛
(1) obj.hasOwnProperty؛
set.has ( "1")؛
set.has (1)؛
`` `

- A: `FALSE`` TRUE` `FALSE`` TRUE`
- B: `FALSE`` TRUE` `TRUE`` TRUE`
- C: `TRUE`` TRUE` `FALSE`` TRUE`
- D: `TRUE`` TRUE` `TRUE`` TRUE`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: C

آپ کو ایک تار کے طور پر یہ اپنے آپ کو ٹائپ نہیں ہے یہاں تک کہ اگر تمام اعتراض چابیاں (نشان چھوڑ کر)، ہڈ کے تحت ڈور ہیں. کیوں `obj.hasOwnProperty ( '1')` بھی درست واپسی یہ ہے.

یہ ایک سیٹ کے لئے اس طرح سے کام نہیں کرتا. ': (1) `لوٹاتا ہے` FALSE` کوئی `` set.has 1'` میں ہماری سیٹ' نہیں ہے. اس عددی قسم `1`،` set.has (1) `ریٹرن` TRUE` ہے.

</ P>
</ تفصیلات>

---

###### 25. آؤٹ پٹ کیا ہے؟

`` `جاوا سکرپٹ
CONST پر obj = {A: "ایک"، ب: "دو"، ایک "تین"}؛
console.log کے (پر obj)؛
`` `

- A: `{A:" ایک "، ب:" دو "}`
- B: `{ب:" دو "، ایک" تین "}`
- C: `{A:" تین "، ب:" دو "}`
- D: `SyntaxError`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: C

آپ ایک ہی نام کے دو چابیاں ہیں، تو کلید تبدیل کیا جائے گا. یہ ابھی اپنی پہلی پوزیشن میں ہوں گے، لیکن آخری متعین قدر کے ساتھ.

</ P>
</ تفصیلات>

---

عالمی اعتراض، اور "اس" کلیدی لفظ: ###### 26. جاوا عالمی عملدرآمد تناظر نے دو چیزیں پیدا کرتا ہے.

- ایک سچا
- B: جھوٹے
- C: یہ انحصار کرتا ہے

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: ایک

بیس پھانسی تناظر عالمی پھانسی سیاق و سباق ہے: یہ آپ کے کوڈ میں ہر جگہ قابل رسائی ہے کیا ہے.

</ P>
</ تفصیلات>

---

###### 27. آؤٹ پٹ کیا ہے؟

`` `جاوا سکرپٹ
کے لئے (میں = 1 بتائیں؛ میں <5؛ میں + +) {
 اگر (میں === 3) جاری؛
 console.log کے (میں)؛
}
`` `

- A: `1`` 2`
- B: `1`` 2` `3`
- C: `1`` 2` `4`
- D: `1`` 3` `4`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: C

ایک خاص حالت `TRUE` آنے کی صورت` CONTINUE` بیان ایک iteration کے فضلے کے ڈھیر.

</ P>
</ تفصیلات>

---

###### 28. آؤٹ پٹ کیا ہے؟

`` `جاوا سکرپٹ
String.prototype.giveLydiaPizza = () => {
 واپسی "بس پہلے سے ہی لڈا پیزا دے!"؛
}؛

CONST نام = "لڈا"؛

name.giveLydiaPizza ()؛
`` `

- A: `" بس پہلے سے ہی لڈا پیزا دے! "`
- B: `TypeError: نہیں ایک function`
- C: `SyntaxError`
- D: `undefined`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: ایک

`اسٹرنگ` جسے ہم جائیدادوں کو شامل کر سکتے ہیں ایک بلٹ میں تعمیر ہے. میں نے ابھی اس کے پروٹوٹائپ کے لئے ایک طریقہ کار میں شامل کیا. آدم ڈور خود کار طریقے سے ایک تار اعتراض، سٹرنگ پروٹوٹائپ تقریب کی طرف سے پیدا میں تبدیل کیا جاتا ہے. لہذا، تمام ڈور (سٹرنگ اشیاء) اس طریقہ کار کو رسائی حاصل ہے!

</ P>
</ تفصیلات>

---

###### 29. آؤٹ پٹ کیا ہے؟

`` `جاوا سکرپٹ
CONST ایک = {}؛
CONST ب = {کلید: "B"}؛
CONST C = {کلید: "C"}؛

ایک [ب] = 123؛
ایک [C] = 456؛

console.log کے (ایک [ب])؛
`` `

- A: `123`
- B: `456`
- C: `undefined`
- D: `ReferenceError`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: بی

آبجیکٹ چابیاں خود کار طریقے ڈور میں تبدیل کیا جاتا ہے. ہم `` 123` کی قدر کے ساتھ، A` اعتراض کرنے کا کلیدی طور کسی چیز کو قائم کرنے کے لئے کی کوشش کر رہے ہیں.

تاہم، ہم کسی چیز stringify جب، یہ ہو جاتا ہے `" [آبجیکٹ اعتراض] "`. تو ہم یہاں کیا کہہ رہے ہیں، یہ ہے کہ `ایک [" آبجیکٹ اعتراض "] = 123`. اس کے بعد، ہم پھر بھی ایسا ہی کرنے کی کوشش کر سکتے ہیں. `c` ایک اور اعتراض ہے کہ ہم نے لپیٹ stringifying کر رہے ہیں. پس `ایک [" آبجیکٹ اعتراض "] = 456`.

اس کے بعد، ہم لاگ ان `ایک [ب]`، جو اصل ہے `ایک [" آبجیکٹ اعتراض "]`. ہم صرف قائم ہے کہ `456` کرنے کے لئے، تو یہ واپس` 456`.

</ P>
</ تفصیلات>

---

###### 30. آؤٹ پٹ کیا ہے؟

`` `جاوا سکرپٹ
CONST FOO کو = () => console.log کے ( "پہلا")؛
CONST بار = () => setTimeout (() => console.log کے ( "دوسرا"))؛
CONST باز = () => console.log کے ( "تیسری")؛

بار ()؛
FOO کو ()؛
باز ()؛
`` `

- A: `First`` Second` `Third`
- B: `First`` Third` `Second`
- C: `Second`` First` `Third`
- D: `Second`` Third` `First`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: بی

ہم نے ایک `setTimeout` تقریب ہے اور سب سے پہلے اسے پکارا. پھر بھی، یہ گزشتہ ریکارڈ کیا گیا تھا.

یہ براؤزرز میں، ہم صرف رن ٹائم انجن ضرورت نہیں ہے کیونکہ، ہم بھی کسی چیز کے نام سے ایک `WebAPI` ہے ہے. `WebAPI` ہمارے ساتھ شروع کرنے کے لئے` setTimeout` تقریب دیتا ہے، اور مثال کے طور DOM.

_callback_ بعد WebAPI پر دھکیل دیا جاتا ہے، `setTimeout` تقریب میں خود (لیکن کال بیک!) اسٹیک دور کھولے رہا ہے.

<IMG ایسآرسی = "https://i.imgur.com/X5wsHOg.png" چوڑائی = "200">

اب، `foo` ومباحثہ ہو جاتا ہے، اور` "سب سے پہلے" `ریکارڈ کیا جارہا ہے.

<IMG ایسآرسی = "https://i.imgur.com/Pvc0dGq.png" چوڑائی = "200">

`foo` اسٹیک دور کھولے جاتا ہے، اور` baz` ومباحثہ ہو جاتا ہے. `" تیسرا "` ریکارڈ ہو جاتا ہے.

<IMG ایسآرسی = "https://i.imgur.com/WhA2bCP.png" چوڑائی = "200">

WebAPI صرف یہ تیار ہے جب بھی اسٹیک والی چیزیں شامل نہیں کرسکتے. اس کے بجائے، یہ _queue_ نامی کسی چیز کو کال بیک تقریب کو ہلا دیتا ہے.

<IMG ایسآرسی = "https://i.imgur.com/NSnDZmU.png" چوڑائی = "200">

ایک واقعہ لوپ کام کرنے کے لئے شروع ہوتا ہے جہاں یہ ہے. ایک ** واقعہ لوپ ** اسٹیک اور کام کی قطار میں نظر آتا ہے. اسٹیک خالی ہے تو، یہ قطار پر پہلی چیز لیتا ہے اور اسٹیک پر اسے ہلا دیتا ہے.

<IMG ایسآرسی = "https://i.imgur.com/uyiScAI.png" چوڑائی = "200">

`bar` ومباحثہ ہو جاتا ہے،` "دوسرا" `ریکارڈ ہو جاتا ہے، اور یہ اسٹیک دور کھولے رہا ہے.

</ P>
</ تفصیلات>

---

###### 31. بٹن پر کلک کرنے پر جب event.target کیا ہے؟

`` `HTML
<div کے ہیں OnClick = "console.log کے ( 'پہلے div کے')">
 <div کے ہیں OnClick = "console.log کے ( 'دوسری div کے')">
 <بٹن ہیں OnClick = "console.log کے ( 'بٹن')">
 پر کلک کریں!
 </ بٹن>
 </ DIV>
</ DIV>
`` `

- A: بیرونی `div`
- B: اندرونی `div`
- C: `button`
- D: تمام جالی دار عناصر کی ایک صف.

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: C

واقعہ کی وجہ سے اس گہری اندر در اندر عنصر ایونٹ کا ہدف ہے. آپ `event.stopPropagation` طرف سے bubbling روک سکتا

</ P>
</ تفصیلات>

---

###### 32. آپ پیراگراف کلک کرتے ہیں، انتخاب کی پیداوار کیا ہے؟

`` `HTML
<div کے ہیں OnClick = "console.log کے ( 'div کے')">
 <P ہیں OnClick = "console.log کے ( 'P')">
 یہاں کلک کریں!
 </ P>
</ DIV>
`` `

- A: `p`` div`
- B: `div`` p`
- C: `p`
- D: `div`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: ایک

`p` اور` div`: ہم `p` کلک کریں، تو ہم دو نوشتہ جات ملاحظہ کریں. قبضہ، ہدف، اور bubbling: تقریب تبلیغ کے دوران، 3 مراحل موجود ہیں. بنیادی طور پر، ایونٹ handlers سے bubbling مرحلے میں پھانسی دے رہے ہیں (آپ `TRUE`` کرنے useCapture` مقرر ہے جب تک). اس سے باہر سب سے گہری اندر در اندر عنصر سے چلا جاتا ہے.

</ P>
</ تفصیلات>

---

###### 33. آؤٹ پٹ کیا ہے؟

`` `جاوا سکرپٹ
CONST شخص = {نام: "لڈا"}؛

تقریب sayHi (عمر) {
 console.log کے ( `$ {this.name} $ ہے {عمر}`)؛
}

sayHi.call (شخص، 21)؛
sayHi.bind (شخص، 21)؛
`` `

- A: `جانچ` لڈا ہے 21` 21`
- B: `function`` function`
- C: `لڈا ہے 21`` لڈا ہے 21`
- D: `لڈا 21`` function` ہے

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

#### جواب: D

دونوں کے ساتھ، ہم اعتراض ہم `this` سے رجوع کرنے کے مطلوبہ الفاظ کے لئے چاہتے ہیں جس کے لئے منتقل کر سکتے ہیں. تاہم، `.call` بھی immediately_ _executed ہے!

`.bind.` تقریب کی ایک _copy_ واپس، لیکن ایک پابند تناظر کے ساتھ! یہ فوری طور پر قتل نہیں کیا جاتا.

</ P>
</ تفصیلات>

---

###### 34. آؤٹ پٹ کیا ہے؟

`` `جاوا سکرپٹ
sayHi تقریب () {
 واپسی (() => 0) ()؛
}

console.log کے (typeof sayHi ())؛
`` `

- A: `" اعتراض "`
- B: `" تعداد "`
- C: `" تقریب "`
- D: `" جانچ "`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: بی

`sayHi` تقریب فوری طور پر لاگو تقریب (IIFE) کے واپس آ قدر واپس کرتا ہے. یہ تقریب `0` واپس آئے، جس قسم` "تعداد" `ہے.

FYI کریں: `null`،` undefined`، `boolean`،` number`، `اسٹرنگ`،` object`، اور `symbol`: صرف 7 بلٹ میں اقسام ہیں. `" تقریب "` ایک قسم، افعال اشیاء ہیں کے بعد سے، ہے جو قسم کے `" اعتراض "` ہے.
</ P>
</ تفصیلات>

---

###### 35. ان اقدار میں سے کون falsy ہیں؟

`` `جاوا سکرپٹ
0؛
نیا نمبر (0)؛
( "")؛
( "")؛
نئے بولین (جھوٹے)؛
جانچ؛
`` `

- A: `0`،` '' `` undefined`
- B: `0`،` نیا نمبر (0) `` '' `` نئے بولین (جھوٹے) `` undefined`
- C: `0`،` '' `` نئے بولین (جھوٹے) `` undefined`
- D: ان میں سے سب falsy ہیں

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: ایک

صرف چھ falsy اقدار موجود ہیں:

- `undefined`
- `null`
- `NaN`
- `0`
- ` ''` (خالی سٹرنگ)
- `FALSE`

فنکشن تعمیر، جیسے `نئے Number` اور` نئے Boolean` truthy ہیں.

</ P>
</ تفصیلات>

---

###### 36. آؤٹ پٹ کیا ہے؟

`` `جاوا سکرپٹ
console.log کے (typeof typeof 1)؛
`` `

- A: `" تعداد "`
- B: `" سٹرنگ "`
- C: `" اعتراض "`
- D: `" جانچ "`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: بی

`typeof 1`` "تعداد" `واپس.
`typeof" تعداد "` ریٹرن `" سٹرنگ "`

</ P>
</ تفصیلات>

---

###### 37. آؤٹ پٹ کیا ہے؟

`` `جاوا سکرپٹ
CONST اعداد = [1، 2، 3]؛
نمبرز [10] 11 =؛
console.log کے (تعداد)؛
`` `

- A: `[1، 2، 3، 7 X شہوت انگیز null، 11]`
- B: `[1، 2، 3، 11]`
- C: `[1، 2، 3، 7 ایکس خالی، 11]`
- D: `SyntaxError`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: C

آپ صف کی لمبائی سے زیادہ ہے کہ ایک صف میں ایک عنصر کے لئے ایک قیمت مقرر کرتے وقت، جاوا "خالی دورانیے" کہا جاتا ہے کچھ پیدا کرتا ہے. یہ اصل میں undefined` `کی قدر ہے، لیکن آپ کی طرح کچھ نظر آئے گا:

`[1، 2، 3، 7 ایکس خالی، 11]`

آپ اسے چلاتے ہیں جہاں پر منحصر ہے (یہ ہر براؤزر، نوڈ، وغیرہ کے لئے مختلف ہے)

</ P>
</ تفصیلات>

---

###### 38. آؤٹ پٹ کیا ہے؟

`` `جاوا سکرپٹ
(() => {
 X، Y دو؛
 کوشش {
 نیا خرابی پھینک ()؛
 } کیچ (X) {
 (X = 1)، (Y = 2)؛
 console.log کے (X)؛
 }
 console.log کے (X)؛
 console.log کے (Y)؛
}) ()؛
`` `

- A: `1`` undefined` `2`
- B: `undefined`` undefined` `undefined`
- C: `1`` 1` `2`
- D: `1`` undefined` `undefined`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: ایک

`catch` بلاک دلیل` x` حاصل کرتا ہے. یہ ہم دلائل کے پاس جب متغیر کے طور پر ایک ہی `x` نہیں ہے. یہ متغیر `x` بلاک سکوپ ہے.

بعد میں، ہم اس بلاک-سکوپ `1` کو متغیر برابر، اور سیٹ متغیر` y` کی قیمت مقرر. اب، ہم `1` کے برابر ہے جس کے ٹکڑے-سکوپ متغیر` x`، لاگ ان کریں.

`catch` بلاک،` کے باہر x` y` `2` ہے اب بھی` undefined` ہے، اور `. ہم کو `console.log کے (X)` `catch` بلاک کے باہر چاہتے ہیں تو، یہ undefined` واپس`، اور `y` واپس` 2`.

</ P>
</ تفصیلات>

---

###### 39. جاوا اسکرپٹ میں سب کچھ تو ہے ...

- A: آدم یا اعتراض
- B: تقریب یا اعتراض
- C: چال سوال! صرف اشیاء
- D: نمبر یا اعتراض

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: ایک

جاوا سکرپٹ کو آدم کی اقسام اور اشیاء ہے.

آدم اقسام `boolean`،` null`، `undefined`،` bigint`، `number`،` اسٹرنگ`، اور `symbol` ہیں.

کیا کسی چیز سے ایک آدم primitives میں کسی بھی املاک یا طریقوں کی ضرورت نہیں ہے فرق؛ تاہم، اگر آپ نوٹ کریں گے کہ `FOO'` 'foo'.toUpperCase ()` `تجزیہ' اور ایک` TypeError` کے نتیجے میں نہیں کرتا. آپ کو ایک تار کی طرح ایک آدم پر ایک جائداد یا طریقہ کار تک رسائی حاصل کرنے کی کوشش کرتے ہیں، جاوا لپیٹ، چادر کلاس میں سے ایک کا استعمال کرتے ہوئے اعتراض لپیٹ گے کیونکہ یعنی `اسٹرنگ`، اور پھر فوری طور پر چادر اظہار کی تشخیص کے بعد ضائع کر یہ ہے. `null` اور` undefined` نمائش اس رویے کے علاوہ تمام primitives میں.

</ P>
</ تفصیلات>

---

###### 40. آؤٹ پٹ کیا ہے؟

`` `جاوا سکرپٹ
[[0، 1]، [2، 3]] کو کم (
 (اے سی سی، رائج) => {
 acc.concat (رائج) واپس؛
 }،
 [1، 2]
)؛
`` `

- A: `[0، 1، 2، 3، 1، 2]`
- B: `[6، 1، 2]`
- C: `[1، 2، 0، 1، 2، 3]`
- D: `[1، 2، 6]`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: C

`[1، 2]` ہمارے ابتدائی قیمت ہے. یہ قدر ہم کے ساتھ شروع، اور بہت پہلے `acc` کی قدر ہے. پہلے دور کے دوران، `acc`` ہے [1،2] `، اور` cur` ہے `[0، 1]`. ہم نے ان سلسلہ بندی کرنا، جس `[1، 2، 0، 1]` میں یہ نتائج.

اس کے بعد، `[1، 2، 0، 1]` `acc` اور` ہے [2، 3] `` cur` ہے. ہم نے ان سلسلہ بندی کرنا، اور حاصل `[1، 2، 0، 1، 2، 3]`

</ P>
</ تفصیلات>

---

###### 41. آؤٹ پٹ کیا ہے؟

`` `جاوا سکرپٹ
!!خالی؛
! ""؛
!! 1؛
`` `

- A: `FALSE`` TRUE` `FALSE`
- B: `FALSE`` FALSE` `TRUE`
- C: `FALSE`` TRUE` `TRUE`
- D: `TRUE`` TRUE` `FALSE`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: بی

`null` falsy ہے. `! TRUE` واپس null`.` `! FALSE` لوٹاتا TRUE`.`

`" "` falsy ہے. `!" "` ریٹرن `TRUE`. `! FALSE` لوٹاتا TRUE`.`

`1` truthy ہے. `! 1` FALSE` واپس`. `! FALSE` لوٹاتا ہے` TRUE`.

</ P>
</ تفصیلات>

---

###### 42. کیا براؤزر میں `setInterval` طریقہ کار کی واپسی کرتا ہے؟

`` `جاوا سکرپٹ
setInterval (() => console.log کے ( "ہیلو")، 1000)؛
`` `

- A: ایک منفرد ID
- B: ملی سیکنڈز کی مقدار متعین کردہ
- C: منظور تقریب
- D: `undefined`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: ایک

یہ ایک منفرد ID واپس. اس ID `clearInterval ()` تقریب کے ساتھ کہ وقفہ صاف کرنے کے لئے استعمال کیا جا سکتا ہے.

</ P>
</ تفصیلات>

---

###### 43. یہ کیا واپس کرتا ہے؟

`` `جاوا سکرپٹ
[... "لڈا"]؛
`` `

- A: `[" L "،" Y "،" د "اور" میں "،" ایک "]`
- B: `[" لڈا "]`
- C: `[[]،" لڈا "]`
- D: `[[" L "،" Y "،" D "،" میں "،" ایک "]]`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: ایک

ایک سٹرنگ ایک iterable ہے. پھیلنے کا آپریٹر ایک عنصر کے لئے ایک iterable کے ہر کردار کے نقشے.

</ P>
</ تفصیلات>

---

###### 44. آؤٹ پٹ کیا ہے؟

`` `جاوا سکرپٹ
تقریب * جنریٹر (میں) {
 میں برآمد ہوں؛
 برآمد ہوں میں * 2؛
}

CONST جنرل = جنریٹر (10)؛

console.log کے (. gen.next () قدر)؛
console.log کے (. gen.next () قدر)؛
`` `

- A: `[0، 10]، [10، 20]`
- B: `20، 20`
- C: `10، 20`
- D: `0، 10 اور 10، 20`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: C

باقاعدہ افعال فریاد بعد وسط راستہ نہیں روکا جا سکتا. تاہم، ایک جنریٹر تقریب ہو سکتا ہے درمیان میں ہی "روک دیا"، اور بعد میں اسے کہاں روکا سے جاری ہے. ہر بار ایک جنریٹر تقریب ایک `yield` مطلوبہ الفاظ کے مقابلوں، تقریب کے بعد متعین قدر ملتی ہے. اس صورت میں جنریٹر تقریب قدر _return_ نہیں ہے کہ نوٹ، یہ قدر _yields_.

سب سے پہلے، ہم `برابر i` کرنے` 10` ساتھ جنریٹر تقریب کی ابتدا. ہم `اگلے ()` طریقہ استعمال کرتے ہوئے جنریٹر تقریب پکارتے. پہلی بار ہم نے جنریٹر تقریب، `i`` 10` کے برابر ہے پکارتے. اس سے پہلے `yield` مطلوبہ لفظ کا میاب: یہ i`` کی قدر ملتی ہے. جنریٹر اب 10` ریکارڈ ہو جاتا ہے "روک دیا گیا"، اور `.

اس کے بعد، ہم `اگلے ()` طریقے کے ساتھ دوبارہ تقریب پکارتے. اس سے یہ اب بھی ساتھ `برابر i`` 10` کو، جو پہلے بند کر دیا جہاں جاری رکھنے کے لئے شروع ہوتا ہے. اب، یہ اگلے `yield` مطلوبہ الفاظ کے مقابلوں، اور پیداوار` میں * 2`. `i`` 10` کے برابر ہے، لہذا اسے واپس `10 * 2`، جس` 20`. یہ `10 میں اس کے نتائج، 20`.

</ P>
</ تفصیلات>

---

###### 45. یہ کیا واپس کرتا ہے؟

`` `جاوا سکرپٹ
CONST firstPromise = نیا وعدہ ((لوڈ، سے Rej) => {
 setTimeout (لوڈ، 500، "ایک")؛
})؛

CONST secondPromise = نیا وعدہ ((لوڈ، سے Rej) => {
 setTimeout (لوڈ، 100، "دو")؛
})؛

Promise.race ([firstPromise، secondPromise]) پھر (لوڈ => console.log کے (لوڈ)).
`` `

- A: `" ایک "`
- B: `" دو "`
- C: `" دو "" ایک "`
- D: `" ایک "" دو "`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: بی

ہم `Promise.race` طریقہ کار سے ایک سے زیادہ وعدے گزر جانے پر، یہ / / مسترد کرتا حل ہوجاتا ہے کہ _first_ وعدہ کو رد کرتا عزم. `setTimeout` طریقہ کار کے لئے، ہم ایک ٹائمر منتقل: دوسرا وعدہ (` secondPromise`) کے لئے سب سے پہلے وعدہ ( `firstPromise`) کے لئے 500ms کے، اور 100ms. یہ `secondPromise`` 'two'` کی قدر کے ساتھ سب سے پہلے حل ہو جاتا ہے کا مطلب ہے. `res` اب` 'two'`، ریکارڈ ہو جاتا ہے جس کی قدر رکھتا ہے.

</ P>
</ تفصیلات>

---

###### 46. آؤٹ پٹ کیا ہے؟

`` `جاوا سکرپٹ
دو شخص = {نام: "لڈا"}؛
CONST کے اراکین = [شخص]؛
شخص نل =؛

console.log کے (ممبران)؛
`` `

- A: `null`
- B: `[معدوم]`
- C: `[{}]`
- D: `[{نام:" لڈا "}]`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

#### جواب: D

سب سے پہلے، ہم ایک `name` جائیداد ہے کہ کسی چیز کی قدر کے ساتھ ایک متغیر` person` اعلان.

<IMG ایسآرسی = "https://i.imgur.com/TML1MbS.png" چوڑائی = "200">

اس کے بعد، ہم `members` نامی ایک متغیر کا اعلان. ہم اس صف `person` متغیر کی قدر کے برابر کے پہلے عنصر مقرر. انہیں ایک دوسرے کے برابر کی ترتیب جب آبجیکٹ _reference_ طرف تعامل کرتے ہیں. آپ کو ایک متغیر سے ایک حوالہ تفویض کرتے ہیں تو، آپ اس ریفرنس کی ایک _copy_ بناتے ہیں. (نوٹ کریں کہ وہ _same_ ریفرنس نہیں ہے!)

<IMG ایسآرسی = "https://i.imgur.com/FSG5K3F.png" چوڑائی = "300">

اس کے بعد، ہم متغیر سیٹ `null`` برابر person`.

<IMG ایسآرسی = "https://i.imgur.com/sYjcsMT.png" چوڑائی = "300">

ہم صرف اس عنصر اعتراض کے لئے ایک مختلف (کاپی) ریفرنس کیں، صف میں پہلی عنصر `person` متغیر کی قدر میں تبدیلی کرنے، اور نہیں ہیں. `members` میں پہلا عنصر اب بھی اصل اعتراض کو اس ریفرنس ڈگری حاصل کی. ہم `members` صف لاگ ان کرتے ہیں تو، سب سے پہلے عنصر اب بھی ریکارڈ ہو جاتا ہے جس چیز کو، کی قدر رکھتا ہے.

</ P>
</ تفصیلات>

---

###### 47. آؤٹ پٹ کیا ہے؟

`` `جاوا سکرپٹ
CONST شخص = {
 نام: "لڈا"،
 عمر: 21
}؛

(شخص میں CONST شے) {لئے
 console.log کے (شے)؛
}
`` `

- A: `{نام:" لڈا "}، {عمر: 21}`
- B: `" نام "،" عمر "`
- C: `" لڈا "، 21`
- D: `[" نام "،" لڈا "]، [" عمر "، 21]`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: بی

ایک `غیر in` لوپ کے ساتھ، ہم اس صورت` name` اور `age` میں، اعتراض چابیاں کے ذریعے iterate کر سکتے ہیں. ہڈ کے تحت اعتراض چابیاں ڈور ہیں (وہ ایک علامت نہیں ہو تو). ہر لوپ، ہم item` موجودہ چابی اس پر iterating کر رہا ہے اس کے برابر `کی قیمت مقرر. سب سے پہلے، `item` name`` کے برابر ہے، اور ریکارڈ ہو جاتا ہے. اس کے بعد، `item` age`، ریکارڈ ہو جاتا ہے جس کے` کے برابر ہے.

</ P>
</ تفصیلات>

---

###### 48. آؤٹ پٹ کیا ہے؟

`` `جاوا سکرپٹ
console.log کے (3 + 4 + "5")؛
`` `

- A: `" 345 "`
- B: `" 75 "`
- C: `12`
- D: `" 12 "`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: بی

یا تو بائیں سے دائیں یا دائیں سے بائیں آپریٹر associativity حکم کی سنکلک، اظہار کی تشخیص کرتا ہے ہے. تمام آپریٹرز _same_ مقدم ہو تو یہ صرف کیا ہوتا. `+`: ہم صرف آپریٹر میں سے ایک قسم ہے. اس کے علاوہ کے طور پر، associativity بائیں سے دائیں جاتی ہے.

`3 + 4` پہلے جانچا جاتا ہے. یہ نمبر `7` میں یہ نتائج.

`7 + '5'` کیونکہ جبر کے` "75" میں نتائج `. جاوا تعداد میں `7` ایک تار میں، ہم` + `آپریٹر کا استعمال کرتے ہوئے دو ڈور سلسلہ بندی کرنا کر سکتے ہیں سوال 15. دیکھنے بدلتا ہے. `" 7 "+" 5 "` میں `" 75 "` نتائج.

</ P>
</ تفصیلات>

---

###### 49. `num` کی قدر کیا ہے؟

`` `جاوا سکرپٹ
CONST NUM = parseInt ( "7 * 6"، 10)؛
`` `

- A: `42`
- B: `" 42 "`
- C: `7`
- D: `NaN`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: C

صرف سٹرنگ میں پہلے نمبرز واپس آ جاتا ہے. _radix_ (تعداد کے کس قسم کی ہم کو اس کا تجزیہ کرنا چاہتے ہیں کی وضاحت کرنے کے لیے دوسری دلیل: بیس 10، شش اعشاری، اجاداری، بائنری، وغیرہ) کی بنا پر، `parseInt` چیکس چاہے سٹرنگ میں حروف درست ہیں. جو کہ جڑ میں ایک درست تعداد نہیں ہے ایک کردار مقابلوں کے بعد، یہ تصریف رک جاتا ہے اور مندرجہ ذیل حروف کو نظر انداز.

`*` ایک درست نمبر نہیں ہے. یہ صرف parses ہے `" 7 "` اعشاریہ `میں 7`. `num` اب 7`` کی قدر رکھتا ہے.

</ P>
</ تفصیلات>

---

###### 50. output` کیا ہے؟

`` `جاوا سکرپٹ
[1، 2، 3] .نقشہ (NUM => {
 اگر (typeof NUM === "تعداد") کی واپسی؛
 واپسی NUM * 2؛
})؛
`` `

- A: `[]`
- B: `[شہوت انگیز null، شہوت انگیز null، شہوت انگیز null]`
- C: `[جانچ، جانچ، جانچ]`
- D: `[3 ایکس خالی]`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: C

صف پر میپنگ جب، num` `کی قدر عنصر یہ فی الحال زائد looping کے ہے کے برابر ہے. اس صورت میں، عناصر اعداد ہیں، اگر ایسا ہے تو بیان کرنے کی شرط `typeof NUM ===" تعداد "` ریٹرن `TRUE`. نقشہ تقریب میں ایک نئی صف پیدا کرتا ہے اور تقریب سے واپس اقدار اضافہ.

تاہم، ہم ایک قدر واپس نہیں آتے. ہم تقریب سے ایک قدر واپس نہیں کرتے ہیں تو، تقریب `undefined` واپس. صف میں ہر عنصر کے لئے، تقریب کے ٹکڑے ہر عنصر کے لئے تو ہم `واپس آ undefined`، بلایا جاتا ہے.

</ P>
</ تفصیلات>

---

###### 51. آؤٹ پٹ کیا ہے؟

`` `جاوا سکرپٹ
تقریب getInfo (رکن، سال) {
 member.name = "لڈا"؛
 سال = "1998"؛
}

CONST شخص = {نام: "سارہ"}؛
CONST birthYear = "1997"؛

getInfo (شخص، birthYear)؛

console.log کے (شخص، birthYear)؛
`` `

- A: `{نام:" لڈا "}،" 1997 "`
- B: `{نام:" سارہ "}،" 1998 "`
- C: `{نام:" لڈا "}،" 1998 "`
- D: `{نام:" سارہ "}،" 1997 "`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: ایک

دلائل، _value_ کی طرف سے منظور کر رہے ہیں جب تک کہ ان کی قیمت کسی چیز ہے، اس کے بعد وہ _reference_ کی طرف سے منظور کر رہے ہیں. `birthYear`، قدر کی طرف سے منظور کیا جاتا ہے کہ یہ ایک سٹرنگ، نہ کسی چیز میں ہے کے بعد سے. ہم قدر کی طرف سے دلائل منتقل کرتے ہیں تو، اس قدر کی ایک _copy_ (سوال 46 ملاحظہ کریں) پر پیدا ہوتا ہے.

متغیر `birthYear` قدر` "1997" `کے لئے ایک ریفرنس ہے. دلیل `بھی قدر` "1997" `کے لئے ایک حوالہ ہے year`، لیکن جیسے` birthYear` کرنے کے لئے ایک حوالہ ہے جو اسی قدر نہیں ہے. ہم قائم کرنے کی طرف year` `کی قدر کو اپ ڈیٹ جب` year` برابر `" 1998 "`، ہم صرف year` `کی قدر کو اپ ڈیٹ کر رہے ہیں کرنے کے لئے. `birthYear` اب بھی` "1997" `کے برابر ہے.

person` `کی قدر کسی چیز ہے. دلیل `member` _same_ اعتراض کرنے کے لئے ایک (کاپی) ریفرنس ہے. ہم اعتراض کی املاک پر نظر ثانی کرتے وقت `member` وہ دونوں ایک ہی شئی کے لئے ایک ریفرنس ہے کے بعد سے، کے لئے، person`` کی قدر بھی نظر ثانی کی جائے گی ایک حوالہ ہے. `person` کی` name` جائیداد اب قدر `" لڈا "` کے برابر ہے

</ P>
</ تفصیلات>

---

###### 52. آؤٹ پٹ کیا ہے؟

`` `جاوا سکرپٹ
تقریب سلام () {
 پھینک "ہیلو دنیا!"؛
}

sayHi تقریب () {
 کوشش {
 CONST کے اعداد و شمار = سلام ()؛
 console.log کے ( "یہ کام کیا!"، ڈیٹا)؛
 } کیچ (ای) {
 console.log کے ( "اوہ نہیں ایک خرابی:"، ای)؛
 }
}

کہو ہائے()؛
`` `

- A: `یہ کام کیا! ہیلو دنیا! `
- B: `اوہ نہیں ایک خامی: undefined`
- C: `SyntaxError: صرف غلطی پھینک سکتے objects`
- D: `اوہ نہیں ایک خامی: ہیلو دنیا`!

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

#### جواب: D

`throw` بیان کے ساتھ، ہم اپنی مرضی کے مطابق کی غلطیاں بنا سکتے ہیں. اس بیان کے ساتھ، آپ مستثنیات پھینک کر سکتے ہیں. ایک استثناء ہو سکتا ہے ایک <b> سٹرنگ </ b> پر، ایک <b> تعداد میں </ b> پر، ایک <b> بولین </ b> یا ایک <b> پر اعتراض ہے </ b>. اس صورت میں، ہماری رعایت سٹرنگ ` 'ہیلو world'` ہے.

`catch` بیان کے ساتھ، ہم ایک رعایت` try` بلاک میں پھینک دیا جاتا ہے تو کیا کیا وضاحت کر سکتے ہیں. ایک رعایت پھینک دیا جاتا ہے: سٹرنگ ` 'ہیلو world'`. `e` اب اس سٹرنگ، ہم لاگ ان کریں جس کے برابر ہے. world'` ہیلو: یہ ` 'ایک خرابی میں اوہ یہ نتائج.

</ P>
</ تفصیلات>

---

###### 53. آؤٹ پٹ کیا ہے؟

`` `جاوا سکرپٹ
تقریب کار () {
 this.make = "لیمبوروگھینی"؛
 واپس آنے {بنانے کے: "Maserati کی"}؛
}

CONST MyCar اے = نئی کار ()؛
console.log کے (myCar.make)؛
`` `

- A: `" لیمبوروگھینی "`
- B: `" Maserati کی "`
- C: `ReferenceError`
- D: `TypeError`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: بی

آپ کو ایک جائیداد کو واپس جب، جائیداد کی قیمت _returned_ قدر، نہ قدر تعمیر تقریب میں قائم کرنے کے لئے برابر ہے. ہم سٹرنگ `" Maserati کی "` واپس آ جائیں، تو `myCar.make`` "Maserati کی" `کے برابر ہے.

</ P>
</ تفصیلات>

---

###### 54. آؤٹ پٹ کیا ہے؟

`` `جاوا سکرپٹ
(() => {
 دو X = (Y = 10)؛
}) ()؛

console.log کے (typeof X)؛
console.log کے (typeof Y)؛
`` `

- A: `" جانچ "،" تعداد "`
- B: `" نمبر "،" تعداد "`
- C: `" اعتراض "،" تعداد "`
- D: `" نمبر "،" جانچ "`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: ایک

`دیں X = Y = 10؛` اصل لئے آشلپی ہے:

`` `جاوا سکرپٹ
Y 10 =؛
دو X = Y؛
`` `

ہم مقرر کرتے وقت `` 10` کرنے y` برابر، ہم اصل میں ایک پراپرٹی `y` عالمی اعتراض (` براؤزر میں window`، `گھنڈی میں global`) تک کا اضافہ. ایک براؤزر، `window.y` اب` 10` کے برابر ہے میں.

اس کے بعد، ہم y` `کی قدر ہے جو` 10` ساتھ ایک متغیر `x` اعلان. `let` مطلوبہ الفاظ کے ساتھ اعلان متغیر، _block scoped_ ہیں وہ صرف بلاک وہ میں اعلان کر رہے ہیں کے اندر اندر وضاحت کر رہے ہیں؛ فوری طور پر-ومباحثہ تقریب (IIFE) اس معاملے میں. ہم `typeof` آپریٹر کا استعمال کرتے ہیں، اوپیرانڈ` وضاحت نہیں ہے x`: ہم `x` بلاک اس میں اعلان کیا ہے کے باہر تک رسائی حاصل کرنے کی کوشش کر رہے ہیں یہ` کہ x` وضاحت نہیں ہے کا مطلب ہے. جو ایک قدر تفویض یا اعلان کر دیا گیا نہیں کیا ہے، اقدار `" جانچ "قسم کے ہیں`. `console.log کے (typeof X)` لوٹاتا ہے `" جانچ "`.

`10` کرنے y` برابر` ترتیب جب تاہم، ہم ایک عالمی متغیر `y` پیدا. یہ قدر اپنے کوڈ میں قابل رسائی کہیں بھی ہے. `y` وضاحت کی گئی ہے، اور قسم` "تعداد" `کی ایک قیمت رکھتا ہے. `console.log کے (typeof Y)` لوٹاتا ہے `" تعداد "`.

</ P>
</ تفصیلات>

---

###### 55. آؤٹ پٹ کیا ہے؟

`` `جاوا سکرپٹ
کلاس ڈاگ {
 ڈویلپر (نام) {
 this.name = نام؛
 }
}

Dog.prototype.bark = تقریب () {
 console.log کے ( `Woof کی میں $ {this.name}` ہوں)؛
}؛

CONST پالتو جانوروں = نئے ڈاگ ( "مارا")؛

pet.bark ()؛

Dog.prototype.bark کو حذف؛

pet.bark ()؛
`` `

- A: `" Woof کی مجھے مارا ہوں "` `TypeError`
- B: `" Woof کی مجھے مارا ہوں "` `" Woof کی مجھے مارا ہوں "`
- C: `" Woof کی مجھے مارا ہوں "` `undefined`
- D: `TypeError`،` TypeError`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: ایک

ہم نے بھی پروٹوٹائپ پر، `delete` مطلوبہ لفظ کو استعمال کرتے ہوئے اشیاء کی خصوصیات کو خارج کر سکتے ہیں. پروٹوٹائپ پر ایک جائیداد کو ختم کر کے، ایسا نہیں آپ اب پروٹوٹائپ سلسلہ میں ہے. اس صورت میں، `bark` تقریب دستیاب نہیں اب پروٹوٹائپ پر Dog.prototype.bark` کو حذف` بعد ہے، ابھی تک ہم اب بھی اس تک رسائی حاصل کرنے کی کوشش کریں.

ہم کہ ایک تقریب نہیں ہے کہ کچھ کالعدم قرار دینے کی کوشش کرتے ہیں تو، ایک `TypeError` پھینک دیا جاتا ہے. اس صورت میں `TypeError: pet.bark نہیں function`،` بعد pet.bark` `undefined` ہے.

</ P>
</ تفصیلات>

---

###### 56. آؤٹ پٹ کیا ہے؟

`` `جاوا سکرپٹ
CONST سیٹ = نیا سیٹ ([1، 1، 2، 3، 4])؛

console.log کے (مقرر)؛
`` `

- A: `[1، 1، 2، 3، 4]`
- B: `[1، 2، 3، 4]`
- C: `{1، 1، 2، 3، 4}`
- D: `{1، 2، 3، 4}`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

#### جواب: D

`Set` اعتراض _unique_ اقدار کا مجموعہ ہے: ایک قیمت صرف ایک سیٹ میں ایک بار ہو سکتا ہے.

ہم گزر iterable `[1، 1، 2، 3، 4]` ڈوپلیکیٹ قدر `1` کے ساتھ. ہم نے ایک سیٹ میں اسی اقدار کے دو کی ضرورت نہیں کر سکتے ہیں کے بعد سے، ان میں سے ایک کو ہٹا دیا جاتا ہے. یہ `{1، 2، 3، 4}` میں یہ نتائج.

</ P>
</ تفصیلات>

---

###### 57. آؤٹ پٹ کیا ہے؟

`` `جاوا سکرپٹ
// counter.js
انسداد دو = 10؛
برآمد ڈیفالٹ کاؤنٹر؛
`` `

`` `جاوا سکرپٹ
// index.js
"./counter" سے myCounter درآمد؛

myCounter + = 1؛

console.log کے (myCounter)؛
`` `

- A: `10`
- B: `11`
- C: `Error`
- D: `NaN`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: C

ایک درآمد ماڈیول _read-only_ ہے: آپ کو درآمد ماڈیول پر نظر ثانی نہیں کر سکتے. صرف ماڈیول برآمد کرتا ہے کہ ان کو اس قدر تبدیل کر سکتے ہیں.

ہم `myCounter` کی قدر اضافہ کرنے کی کوشش کرتے ہیں تو، یہ ایک غلطی ڈالی:` myCounter` صرف پڑھنے کیلئے ہے اور میں ترمیم نہیں کی جا سکتی.

</ P>
</ تفصیلات>

---

###### 58. آؤٹ پٹ کیا ہے؟

`` `جاوا سکرپٹ
CONST نام = "لڈا"؛
عمر = 21؛

console.log کے (نام حذف)؛
console.log کے (عمر کو حذف)؛
`` `

- A: `FALSE`،` TRUE`
- B: `" لڈا "` `21`
- C: `TRUE`،` TRUE`
- D: `undefined`،` undefined`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: ایک

، `ایک کامیاب منسوخی پر TRUE` ورنہ یہ` FALSE` کو واپس کر دیں گے: `delete` آپریٹر ایک بولین قدر واپس کرتا ہے. تاہم، `var`،` const` یا `let` مطلوبہ الفاظ کے ساتھ اعلان متغیر` delete` آپریٹر کا استعمال کرتے ہوئے خارج کر دیا نہیں کیا جا سکتا.

`name` متغیر ایک` const` مطلوبہ الفاظ کے ساتھ اعلان کیا گیا تھا، اس لئے اس کی منسوخی کامیاب نہیں ہے: `FALSE` واپس آ جاتا ہے. ہم مقرر کرتے وقت `` 21` کرنے age` برابر، ہم اصل نام سے ایک جائیداد سے شامل `عالمی اعتراض کرنے age`. آپ نے کامیابی کے اتنے `age` ریٹرن` TRUE` خارج کر دیں، اس طرح، بھی عالمی اعتراض اشیاء سے خواص کو حذف کر سکتے ہیں.

</ P>
</ تفصیلات>

---

###### 59. آؤٹ پٹ کیا ہے؟

`` `جاوا سکرپٹ
CONST اعداد = [1، 2، 3، 4، 5]؛
CONST [Y] = نمبروں؛

console.log کے (Y)؛
`` `

- A: `[[1، 2، 3، 4، 5]]`
- B: `[1، 2، 3، 4، 5]`
- C: `1`
- D: `[1]`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: C

ہم تباہ کاری کے ذریعے اشیاء سے اریز یا خواص سے اقدار پیک کھولیں کر سکتے ہیں. مثال کے طور پر:

`` `جاوا سکرپٹ
[A، B] = [1، 2]؛
`` `

<IMG ایسآرسی = "https://i.imgur.com/ADFpVop.png" چوڑائی = "200">

A` `کی قدر اب` 1` ہے، اور b` `کی قدر اب` 2` ہے. کیا ہم اصل سوال میں نے کیا، یہ ہے کہ:

`` `جاوا سکرپٹ
[Y] = [1، 2، 3، 4، 5]؛
`` `

<IMG ایسآرسی = "https://i.imgur.com/NzGkMNk.png" چوڑائی = "200">

اس کا مطلب یہ y` `کی قدر صف، نمبر` 1` ہے جس میں پہلی قیمت کے برابر ہے. ہم `y`،` لاگ ان کرتے 1` واپس آ جاتا ہے.

</ P>
</ تفصیلات>

---

###### 60. آؤٹ پٹ کیا ہے؟

`` `جاوا سکرپٹ
CONST صارف = {نام: "لڈا"، عمر: 21}؛
CONST منتظم = {ایڈمن: یہ سچ ہے، ... صارف}؛

console.log کے (ایڈمن)؛
`` `

- A: `{ایڈمن: یہ سچ ہے، صارف: {نام:" لڈا "، عمر: 21}}`
- B: `{ایڈمن: یہ سچ ہے، نام" لڈا "، عمر: 21}`
- C: `{ایڈمن: یہ سچ ہے، صارف: [" لڈا "، 21]}`
- D: `{ایڈمن: سچ}`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: بی

اس کو پھیلانے کا آپریٹر `استعمال کرتے ہوئے اشیاء کو جمع کرنے کے لئے ممکن ہے ...`. یہ آپ کو ایک چیز کی کلید / قدر جوڑوں کی کاپیاں بنانے کے، اور ایک اور اعتراض پر ان کو شامل ہے. اس صورت میں، ہم `user` اعتراض کی کاپیاں بنانے کے، اور` admin` اعتراض میں شامل کریں. {: سچ، نام "لڈا"، عمر: 21 منتظم} `` admin` اعتراض اب جس `نتیجے کاپی کیا کلید / قدر جوڑوں، پر مشتمل ہے.

</ P>
</ تفصیلات>

---

###### 61. آؤٹ پٹ کیا ہے؟

`` `جاوا سکرپٹ
CONST شخص = {نام: "لڈا"}؛

Object.defineProperty (شخص "عمر"، {قیمت: 21})؛

console.log کے (شخص)؛
console.log کے (Object.keys (شخص))؛
`` `

- A: `{نام:" لڈا "، عمر: 21}` `[" نام "،" عمر "]`
- B: `{نام:" لڈا "، عمر: 21}` `[" نام "]`
- C: `{نام:" لڈا "}` `[" نام "،" عمر "]`
- D: `{نام:" لڈا "}` `[" عمر "]`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: بی

`defineProperty` طریقہ کار کے ساتھ، ہم کسی چیز کے لئے نئی خصوصیات کا اضافہ کریں یا موجودہ والوں کو نظر ثانی کر سکتے ہیں. ہم `defineProperty` طریقہ استعمال کرتے ہوئے کسی چیز کے لئے ایک پراپرٹی کو شامل کرتے ہیں، وہ پہلے سے طے شدہ _not enumerable_ کر سکتے ہیں. `Object.keys` طریقہ اس صورت میں صرف" نام "` `میں، کسی چیز سے تمام _enumerable_ جائیداد ناموں واپس.

پراپرٹیز استعمال کرتے ہوئے `defineProperty` طریقہ کار پہلے سے طے شدہ کی طرف سے ناقابل تغیر ہیں شامل. آپ `writable`،` configurable` اور `enumerable` خواص کا استعمال کرتے ہوئے اس رویے کی جگہ لے لے سکتے ہیں. اس طرح، `defineProperty` طریقہ آپ کو آپ کسی چیز میں اضافہ کر رہے خواص کے دوران بہت زیادہ کنٹرول فراہم کرتا ہے.

</ P>
</ تفصیلات>

---

###### 62. آؤٹ پٹ کیا ہے؟

`` `جاوا سکرپٹ
CONST ترتیبات = {
 صارف کا نام: "lydiahallie"،
 سطح: 19
 صحت: 90
}؛

CONST کے اعداد و شمار = JSON.stringify (ترتیبات، [ "سطح"، "صحت"])؛
console.log کے (ڈیٹا)؛
`` `

- A: `" { "سطح": 19، "صحت": 90} "`
- B: `" { "صارف نام": "lydiahallie"} "`
- C: `" [ "سطح"، "صحت"] "`
- D: `" { "صارف نام": "lydiahallie"، "سطح": 19، "صحت": 90} "`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: ایک

`JSON.stringify` کی دوسری دلیل _replacer_ ہے. REPLACER یا تو ایک تقریب یا ایک سرنی ہو جائے، اور آپ کو اقدار stringified کیا جانا چاہئے کہ کیا اور کس طرح کنٹرول کرتے ہیں کی اجازت دیتا ہے کر سکتے ہیں.

REPLACER ایک _array_ ہو تو صف میں شامل صرف جائیداد ناموں JSON سٹرنگ میں شامل کیا جائے گا. اس صورت میں، نام `" سطح "` اور `" صحت "کے ساتھ صرف خواص` شامل ہیں، `" صارف نام "` خارج کر دیا جاتا ہے. "{" صحت "، 19" ": 90 کی سطح}" `` data` `کے برابر ہے.

REPLACER ایک _function_ ہے، تو اس تقریب اعتراض آپ stringifying رہے میں ہر املاک پر زور دیا جاتا ہے. قدر اس تقریب سے واپس جائیداد جو JSON سٹرنگ میں شامل کر دیا ہے جب کی قدر ہو جائے گا. قدر `undefined` ہے، تو اس کی خاصیت JSON سٹرنگ سے خارج کر دیا جاتا ہے.

</ P>
</ تفصیلات>

---

###### 63. آؤٹ پٹ کیا ہے؟

`` `جاوا سکرپٹ
NUM دو = 10؛

CONST increaseNumber = () => NUM ++؛
CONST increasePassedNumber = تعداد میں => نمبر کی ++؛

CONST num1 = increaseNumber ()؛
CONST num2 = increasePassedNumber (num1)؛

console.log کے (num1)؛
console.log کے (num2)؛
`` `

- A: `10`،` 10`
- B: `10`،` 11`
- C: `11`،` 11`
- D: `11`،` 12`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: ایک

یک رکنی آپریٹر `++` اوپیرانڈ، _then اوپیرانڈ کی قدر increments_ کی قدر returns_ _first. num1` `کی قدر` increaseNumber` تقریب پہلی num` `کی قدر` 10` ہے جو واپس، اور صرف اس کے بعد num` `کی قدر دھیرے بڑھتا بعد` 10` ہے.

`num2` ہم` `increasePassedNumber` کرنے num1` گزر کے بعد سے،` 10` ہے. `number`` 10` (num1` `کی قیمت کے برابر یک رکنی آپریٹر` ++ `اوپیرانڈ کی قدر returns_ _first، _then اوپیرانڈ کی قدر increments_ ہے، ایک بار پھر.` کی قدر number` ہے ` 10`، لہذا `num2`` 10` کے برابر ہے.

</ P>
</ تفصیلات>

---

###### 64. آؤٹ پٹ کیا ہے؟

`` `جاوا سکرپٹ
CONST قدر = {تعداد: 10}؛

CONST ضرب = (X = {... قدر}) => {
 console.log کے ((x.number * = 2))؛
}؛

ضرب()؛
ضرب()؛
(قدر) ضرب؛
(قدر) ضرب؛
`` `

- A: `20`،` 40`، `80`،` 160`
- B: `20`،` 40`، `20`،` 40`
- C: `20`،` 20`، `20`،` 40`
- D: `NaN`،` NaN`، `20`،` 40`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: C

ES6 میں، ہم نے ایک طے شدہ قیمت کے ساتھ پیرامیٹرز کی ابتدا کر سکتے ہیں. کوئی اور قدر تقریب میں منظور کیا گیا ہے تو اس پیرامیٹر کی قدر، پہلے سے طے شدہ قیمت ہو جائے گا، یا پیرامیٹر کی قدر ہے تو `" جانچ "`. اس صورت میں، ہم نے ایک نئی چیز میں `قدر` اعتراض کی خصوصیات پھیل تو` x` `{تعداد: 10} کی ڈیفالٹ قدر ہے`.

پہلے سے طے شدہ دلیل _call time_ پر جانچا جاتا ہے! ہر بار جب ہم تقریب کو فون، ایک _new_ اعتراض پیدا ہوتا ہے. ہم ایک قدر گزر بغیر `multiply` تقریب سے پہلے دو مرتبہ پکارتے:` x` `{تعداد: 10} کی ڈیفالٹ قدر ہے`. پھر ہم اس نمبر، جس `20` کی ضرب قدر لاگ ان کریں.

`قدر` کہا جاتا اعتراض: ہم ضرب پکارتے تیسری بار، ہم ایک دلیل منظور کرتے. `* =` آپریٹر اصل `x.number لئے آشلپی ہے = x.number * 2`: ہم x.number`` کی قدر میں ترمیم کریں، اور پھیلتا قدر `20` لاگ ان کریں.

چوتھی بار، ہم پھر `قدر` اعتراض گزر. `x.number` ماضی میں،` 20` کے لئے نظر ثانی کی گئی تھی تاکہ `x.number * = 2` لاگز` 40`.

</ P>
</ تفصیلات>

---

###### 65. آؤٹ پٹ کیا ہے؟

`` `جاوا سکرپٹ
[1، 2، 3، 4] .reduce ((X، Y) => console.log کے (X، Y))؛
`` `

- A: `1`` 2` اور `3`` 3` اور `6`` 4`
- B: `1`` 2` اور `2`` 3` اور `3`` 4`
- C: `1`` undefined` اور `2`` undefined` اور `3`` undefined` اور `4`` undefined`
- D: `1`` 2` اور `undefined`` 3` اور `undefined`` 4`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

#### جواب: D

پہلی دلیل `reduce` طریقہ کار کو موصول ہونا _accumulator_،` اس کیس میں x` ہے. دوسری دلیل _current value_، `y` ہے. کم کرنے کے طریقہ کار کے ساتھ، ہم بالآخر ایک واحد قدر نتیجے میں کر سکتے ہیں جس کی صف میں ہر عنصر پر ایک کال بیک تقریب کو پھانسی.

اس مثال میں، ہم کسی بھی اقدار کو واپس لوٹنے نہیں ہیں ہم تو صرف سنچایک اور موجودہ قدر کی اقدار لاگنگ رہے ہیں.

سنچایک کی قدر کال بیک تقریب کے پہلے واپس آ قدر کے برابر ہے. آپ `reduce` طریقہ کار سے اختیاری` initialValue` دلیل منظور نہیں ہے تو، سنچایک پہلی کال پر سب سے پہلے عنصر کے برابر ہے.

پہلی کال پر، سنچایک ( `x`)` 1` ہے، اور موجودہ قدر ( `y`)` ہے 2`. ہم کال بیک تقریب سے واپس نہیں کرتے، ہم سنچایک اور موجودہ قدر لاگ ان کریں: `1` اور` ریکارڈ حاصل 2`.

آپ کو ایک تقریب سے ایک قدر واپس نہیں کرتے ہیں تو، یہ undefined` واپس `. اگلی کال پر، سنچایک `undefined` ہے، اور موجودہ قدر` ہے 3`. `undefined` اور` ریکارڈ حاصل 3`.

چوتھی کال پر، ہم پھر سے کال بیک کی تقریب سے واپس نہیں آتے. سنچایک دوبارہ `undefined` ہے، اور موجودہ قدر` ہے 4`. `undefined` اور` ریکارڈ حاصل 4`.
</ P>
</ تفصیلات>
 
---

###### 66. جس ڈویلپر کے ساتھ ہم کامیابی `Dog` کلاس میں توسیع کر سکتے ہیں؟

`` `جاوا سکرپٹ
کلاس ڈاگ {
 ڈویلپر (نام) {
 this.name = نام؛
 }
}؛

کلاس لیبراڈور ڈاگ {توسیع
 // 1 
 ڈویلپر (نام، سائز) {
 this.size = سائز؛
 }
 // 2
 ڈویلپر (نام، سائز) {
 سپر (نام)؛
 this.size = سائز؛
 }
 // 3
 ڈویلپر (سائز) {
 سپر (نام)؛
 this.size = سائز؛
 }
 // 4 
 ڈویلپر (نام، سائز) {
 this.name = نام؛
 this.size = سائز؛
 }

}؛
`` `

- A: 1
- B: 2
- C: 3
- D: 4

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: بی

ایک حاصل کی کلاس میں، آپ `super` بلا سے پہلے` this` مطلوبہ لفظ تک رسائی حاصل نہیں کر سکتے. آپ کو ایسا کرنے کی کوشش کریں، تو یہ ایک ReferenceError پھینک دیں گے: 1 اور 4 ایک حوالہ خامی پھینک دیں گے.

`super` مطلوبہ الفاظ کے ساتھ، ہم کو دی دلائل کے ساتھ کہ والدین کلاس کی تعمیر پر کال کریں. والدین کے ڈویلپر `name` دلیل حاصل کرتا ہے، اس لیے ہم` super` `کرنے name` منتقل کرنے کی ضرورت ہے.

`Labrador` کلاس` Labrador` طبقے پر ایک اضافی جائیداد کے طور پر دو دلائل، `name` اس میں توسیع کے بعد` Dog`، اور `size` حاصل کرتا ہے. وہ دونوں `Labrador`، جس ڈویلپر 2 کا استعمال کرتے ہوئے صحیح طریقے سے کیا جاتا ہے پر تعمیر تقریب میں منظور کیا جا کرنے کی ضرورت ہے.
</ P>
</ تفصیلات>

---

###### 67. آؤٹ پٹ کیا ہے؟

`` `جاوا سکرپٹ
// index.js
console.log کے ( 'index.js چلانے')؛
درآمدی './sum.js' سے {رقم}؛
console.log کے (رقم (1، 2))؛

// sum.js
console.log کے ( 'sum.js چلانے')؛
برآمد CONST رقم = (A، B) => A + B؛
`` `

- A: `sum.js` چلانے index.js` چلانے،` `3`
- B: `sum.js` چلانے،` index.js` چلانے، `3`
- C: `sum.js` چلانے،` 3`، `index.js` چلانے
- D: `index.js` چلانے،` undefined`، `چلانے sum.js`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: بی

`import` مطلوبہ الفاظ کے ساتھ، تمام درآمد ماڈیولز _pre-parsed_ ہیں. اس کا مطلب ہے کہ درآمد ماڈیولز _first_ رن حاصل، فائل ماڈیول _after_ قتل ہو جاتا درآمد جس میں کوڈ.

یہ درمیان `ضرورت ہوتی ہے ()` CommonJS میں اور `import` ایک فرق ہے! `کی ضرورت ہوتی ہے ()` کے ساتھ، آپ تھوڑی دیر کے کوڈ کو چلانے کے کیا جا رہا ہے کے مطالبے پر انحصار لوڈ کر سکتے ہیں. ہم نے استعمال کیا ہے `بجائے` import` کے require` چاہتے ہیں تو `sum.js` چلانے index.js` چل رہا ہے،` `3` گی کنسول ریکارڈ کیا گیا ہے.

</ P>
</ تفصیلات>

---

###### 68. آؤٹ پٹ کیا ہے؟

`` `جاوا سکرپٹ
console.log کے (نمبر (2) === نمبر (2))
console.log کے (بولین (باطل) === بولین (جھوٹے))
console.log کے (علامت ( 'FOO کو') === علامت ( 'FOO کو'))
`` `

- A: `TRUE`،` TRUE`، `FALSE`
- B: `FALSE`،` TRUE`، `FALSE`
- C: `TRUE`،` FALSE`، `TRUE`
- D: `TRUE`،` TRUE`، `TRUE`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: ایک

ہر علامت کو مکمل طور پر منفرد ہے. دلیل علامت لئے منظور کرنے کے مقصد علامت ایک وضاحت دینے کے لئے ہے. علامت کی قدر منظور دلیل پر انحصار نہیں ہے. پہلی `علامت ( 'FOO کو')`، اور دوسری `علامت ( 'FOO کو')`: ہم مساوات ٹیسٹ کے طور پر، ہم دو بالکل نئی علامتوں پیدا کر رہے ہیں. یہ دو اقدار منفرد ہے اور ایک دوسرے کے برابر نہیں `علامت ( 'FOO کو') === علامت ( 'FOO کو')` لوٹاتا ہے `FALSE` ہیں.

</ P>
</ تفصیلات>

---

###### 69. آؤٹ پٹ کیا ہے؟

`` `جاوا سکرپٹ
CONST نام = "لڈا Hallie"
console.log کے (name.padStart (13))
console.log کے (name.padStart (2))
`` `

- A: `" لڈا Hallie "` `" لڈا Hallie "`
- B: `" لڈا Hallie "` `" لڈا Hallie "` ( `" [13X سفید فاصلہ] لدیہ Hallie "` `" [2X سفید فاصلہ] لدیہ Hallie "`)
- C: `" لڈا Hallie "` `" لڈا Hallie "` ( `" [1X سفید فاصلہ] لدیہ Hallie "` `" لڈا Hallie "`)
- D: `" لڈا Hallie "` `" آڈیو "` 

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: C

`padStart` طریقہ کار کے ساتھ، ہم ایک تار کے آغاز کے لیے بھرتی شامل کر سکتے ہیں. قدر اس طریقہ کار کو منظور _total_ بھرتی کے ساتھ ایک دوسرے کے ساتھ سٹرنگ کی لمبائی. سٹرنگ `" لڈا Hallie "` 12` `کی لمبائی ہے. `name.padStart (13)` سٹرنگ کے آغاز میں 1 خلا، داخل کرتا ہے، کیونکہ 12 + 1 13 ہے.

دلیل `padStart` طریقہ کار سے گزر صف کی لمبائی سے چھوٹا ہے تو، کوئی بھرتی شامل کیا جائے گا.

</ P>
</ تفصیلات>

---

###### 70. آؤٹ پٹ کیا ہے؟

`` `جاوا سکرپٹ
console.log کے ( "🥑" + "💻")؛
`` `

- A: `" 🥑💻 "`
- B: `257548`
- C: ان کے کوڈ کو پوائنٹس پر مشتمل ایک سٹرنگ
- D: میں خرابی

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: ایک

`+` آپریٹر کے ساتھ، آپ کی ڈور سلسلہ بندی کرنا کر سکتے ہیں. اس صورت میں، ہم سٹرنگ `` سٹرنگ کے ساتھ `` نتیجے `concatenating کی جاتی ہیں" 🥑 "" 💻 "` '🥑💻 ".

</ P>
</ تفصیلات>

---

###### 71. ہم کیسے اقدار console.log کے بیان کے بعد باہر تبصرہ کر رہے ہیں کہ لاگ ان کر سکتے ہیں؟

`` `جاوا سکرپٹ
تقریب * startGame () {
 CONST جواب = اپج "اگر آپ کو جاوا اسکرپٹ محبت کرتے ہو؟"؛
 اگر (جواب! == "ہاں") {
 واپسی "ارے واہ ... لگتا ہے ہم یہاں چلے گئے"؛
 }
 واپسی "جاوا آپ کو واپس سے محبت کرتا ❤️"؛
}

CONST کھیل = startGame ()؛
console.log کے (/ * 1 * /)؛ // آپ کو جاوا محبت کرتے ہیں؟
console.log کے (/ * 2 * /)؛ // جاوا آپ کو واپس سے محبت کرتا ❤️
`` `

- A: `game.next (" جی ہاں ") قدر` اور` game.next () قدر`
- B: `game.next.value (" ہاں ")` اور `game.next.value ()`
- C: `game.next () قدر` اور` game.next ( "جی ہاں") قدر`.
- D: `game.next.value ()` اور `game.next.value (" ہاں ")`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: C

یہ `yield` مطلوبہ لفظ کو دیکھتا ہے جب ایک جنریٹر تقریب اس پر عملدرآمد" توقف ". سب سے پہلے، ہم تقریب بلا `game.next (). قدر` طرف سٹرنگ" آپ کو جاوا محبت کرتے ہو؟ "، جس میں کیا کیا جا سکتا برآمد کرنے کی اجازت دینا ہے.

یہ سب سے پہلے `yield` مطلوبہ الفاظ کی تلاش کرتا ہے جب تک ہر سطر، پھانسی ہے. تقریب کے اندر اندر پہلی لائن پر ایک `yield` مطلوبہ لفظ نہیں ہے: پھانسی کی پہلی پیداوار کے ساتھ بند ہو جاتا ہے! _This کا مطلب ہے کہ متغیر `answer` ابھی تک وضاحت نہیں ہے! _

ہم `game.next (" جی ہاں "). قدر` کال کرتے ہیں، پچھلے` yield` `اگلے ()` تقریب `" ہاں "` میں اس کیس کو منظور پیرامیٹرز کی قدر کے ساتھ تبدیل کر رہا ہے. متغیر کی قدر `answer` اب برابر ہے` "ہاں" `. اگر بیان کرنے کی شرط `FALSE` واپس، اور` جاوا آپ کو واپس سے محبت کرتا ❤️` ریکارڈ ہو جاتا ہے.

</ P>
</ تفصیلات>

---

###### 72. آؤٹ پٹ کیا ہے؟

`` `جاوا سکرپٹ
console.log کے (String.raw`Hello \ nworld`)؛
`` `

- A: `ہیلو دنیا`!
- B: `Hello` <br /> & nbsp؛ پر پر & nbsp؛ پر & nbsp؛ `world`
- C: `ہیلو \ nworld`
- D: `ہیلو \ /> پر & nbsp <br n`؛ پر & nbsp؛ پر & nbsp؛ `world`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: C

`String.raw` ایک سٹرنگ جہاں فرار (` \ n`، `\ v`،` \ t` وغیرہ) کو نظر انداز کر رہے ہیں واپس! backslashes کی آپ کی طرح کچھ کے ساتھ ختم کر سکتے ہیں کے بعد سے ایک مسئلہ ہو سکتا ہے:

`` CONST راہ = `C: پروجیکٹس \ \ دستاویزات \ table.html`` `

جس میں احتمال ہو:

`" C: DocumentsProjects able.html "`

`String.raw` کے ساتھ، یہ صرف فرار اور پرنٹ نظر انداز کریں گے:

`C: پروجیکٹس \ table.html` \ \ دستاویزات

اس صورت میں، سٹرنگ `ہیلو \ nworld`، ریکارڈ ہو جاتا ہے ہے.

</ P>
</ تفصیلات>

---

###### 73. آؤٹ پٹ کیا ہے؟

`` `جاوا سکرپٹ
کرنے async تقریب getData () {
 واپسی Promise.resolve ( "! میں نے اسے بنایا") کا انتظار؛
}

CONST کے اعداد و شمار = getData ()؛
console.log کے (ڈیٹا)؛
`` `

- A: `" میں نے اسے بنایا! "`
- B: `وعدہ {<حل کر لیا>:" میں نے اسے بنایا! "}`
- C: `وعدہ {<زیر التوا>}`
- D: `undefined`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: C

ایک کرنے async تقریب ہمیشہ ایک وعدہ واپس. `await` اب بھی وعدہ کو حل کرنے کے لئے انتظار کرنے کے لئے ہے: ایک زیر التواء وعدہ ہم` getData () `ترتیب میں` قائم کرنے کے لئے یہ کرنے کی data` برابر فون جب واپس آ جاتا ہے.

ہم سے حل قدر `تک رسائی حاصل کرنے کے لئے چاہتا تھا، تو`، ہم `.پھر ()` `data` پر طریقہ استعمال کیا جا سکتا تھا" میں نے اسے بنایا ":

`data.then (لوڈ => console.log کے (لوڈ))`

یہ انتخاب کریں گے لیا ہے `" میں نے اسے بنایا! "`

</ P>
</ تفصیلات>

---

###### 74. آؤٹ پٹ کیا ہے؟

`` `جاوا سکرپٹ
تقریب addToList (شے، فہرست) {
 list.push (شے) واپس؛
}

CONST نتیجہ = addToList ( "سیب"، [ "کیلا"])؛
console.log کے (نتیجہ)؛
`` `

- A: `[ 'ایپل'، 'کیلا']`
- B: `2`
- C: `TRUE`
- D: `undefined`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: بی

`.پش ()` طریقہ کار نئی صف کی _length_ واپس! ماضی میں، صف سے ایک عنصر (سٹرنگ `" کیلا "`) موجود ہیں اور `1` کی لمبائی تھی. سٹرنگ `" سیب "کے اضافے کے بعد` صف، صف دو عناصر پر مشتمل ہے، اور 2` `کی لمبائی ہے. یہ `addToList` تقریب سے واپس ہو جاتا ہے.

`push` طریقہ کار اصل صف ترمیم. آپ array_ کے _length بجائے تقریب سے _array_ کو واپس کرنا چاہتے تھے تو، آپ `item` اس پر زور دے رہے ہیں کے بعد list` واپس آ جانا چاہیے تھا`.

</ P>
</ تفصیلات>

---

###### 75. آؤٹ پٹ کیا ہے؟

`` `جاوا سکرپٹ
CONST باکس = {ایکس 10، Y: 20}؛

Object.freeze (باکس)؛

CONST شکل = باکس؛
shape.x = 100؛

console.log کے (شکل)؛
`` `

- A: `{X: 100، Y: 20}`
- B: `{ایکس 10، Y: 20}`
- C: `{X: 100}`
- D: `ReferenceError`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: بی

`Object.freeze` یہ ناممکن شامل کرنے، ہٹانے، یا کسی چیز کی خصوصیات پر نظر ثانی کرنے کے لئے (جب تک کہ جائیداد کی قیمت کا ایک اور اعتراض ہے) ہوتا ہے.

ہم متغیر `shape` تخلیق اور اسے منجمد اعتراض کے برابر مقرر کرتے وقت` box`، `shape` بھی ایک منجمد اعتراض سے مراد ہے. آپ چیک کر سکتے ہیں کسی چیز Object.isFrozen` استعمال کرتے ہوئے `طرف منجمد ہے یا نہیں. اس صورت میں، `Object.isFrozen (شکل)` سچ، متغیر `shape` ایک منجمد شئے کو ایک حوالہ ہے کے بعد واپس.

`چونکہ shape` منجمد ہے، اور x`` کی قدر کسی چیز کو نہیں ہے کے بعد سے، ہم املاک `x` میں ترمیم نہیں کر سکتے ہیں. `x` اب بھی` 10` کے برابر ہے، اور `{ایکس 10، Y: 20}` ریکارڈ ہو جاتا ہے.

</ P>
</ تفصیلات>

---

###### 76. آؤٹ پٹ کیا ہے؟

`` `جاوا سکرپٹ
CONST {نام: Myname کی} = {نام: "لڈا"}؛

console.log کے (نام)؛
`` `

- A: `" لڈا "`
- B: `" Myname کی "`
- C: `undefined`
- D: `ReferenceError`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

#### جواب: D

ہم دائیں ہاتھ کی طرف پر اعتراض سے جائیداد `name` جب پیک کھولیں، ہم نام` myName` ساتھ ایک متغیر کو اپنی قدر `" لڈا "` تفویض.

ساتھ `{نام: Myname کی}`، ہم `دائیں ہاتھ کی طرف پر` name` جائیداد کی قیمت کے ساتھ myName` نامی ایک نئی متغیر بنانا چاہتے ہیں کہ جاوا بتائیں.

ہم کو لاگ name`، کی وضاحت نہیں ہے کہ ایک متغیر `کوشش کے بعد سے، ایک ReferenceError پھینک دیا جاتا ہے.

</ P>
</ تفصیلات>

---

###### 77. یہ ایک خالص تقریب ہے؟

`` `جاوا سکرپٹ
تقریب رقم (A، B) {
 A + B واپس؛
}
`` `

- ایک: جی ہاں
- B: کوئی

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: ایک

ایک خالص تقریب ایک تقریب اسی دلائل منظور کر رہے ہیں تو _always_، ایک ہی نتیجہ لوٹاتا ہے.

`sum` تقریب ہمیشہ ایک ہی نتیجہ واپس. ہم `1` اور` 2` منتقل، تو یہ واپسی `3` ضمنی اثرات کے بغیر _always_ گا. ہم `5` اور` 10` منتقل، تو یہ اسی طرح کی واپسی _always_ گے `15`، اور. یہ ایک خالص تقریب کی تعریف کی ہے.

</ P>
</ تفصیلات>

---

###### 78. آؤٹ پٹ کیا ہے؟

`` `جاوا سکرپٹ
CONST شامل کریں = () => {
 CONST کیشے = {}؛
 واپس آ NUM => {
 اگر (کیشے میں NUM) {
کیش سے `واپس! $ {کیشے [NUM]} `؛
 } ورنہ {
 CONST نتیجہ = NUM ​​+ 10؛
 کیشے [NUM] = نتیجے؛
واپس آ `محسوب! $ {نتیجہ} `؛
 }
 }؛
}؛

CONST addFunction = شامل کریں ()؛
console.log کے (addFunction (10))؛
console.log کے (addFunction (10))؛
console.log کے (addFunction (5 * 2))؛
`` `

- A: `محسوب! 20` `محسوب! 20` `محسوب! 20`
- B: `محسوب! 20` `کیش سے! 20` `محسوب! 20`
- C: `محسوب! 20` `کیش سے! 20` `کیش سے! 20`
- D: `محسوب! 20` `کیش سے! 20` `Error`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: C

`add` تقریب ایک _memoized_ تقریب ہے. memoization کے ساتھ، ہم اس پر عملدرآمد کی رفتار تیز کرنے کے لئے میں ایک تقریب کے نتائج کیشے کر سکتے ہیں. اس صورت میں، ہم نے پہلے واپس آ اقدار ذخیرہ ہے کہ ایک `cache` اعتراض تخلیق کرتے ہیں.

ہم ایک ہی دلیل کے ساتھ دوبارہ `addFunction` تقریب کہتے ہیں، یہ سب سے پہلے چیک کرتا ہے جو پہلے سے ہی اس کیشے میں اس قدر ہو گیا ہے یا نہیں. اگر یہ بات ہے، کیش قدر پھانسی کے وقت پر بچاتا ہے جو، واپس آ جائے گا. ورنہ، یہ عارضی نہیں ہے، یہ قیمت کا حساب اور اس کے بعد اس کی دکان گا.

ہم ایک ہی قیمت کے ساتھ `addFunction` تقریب تین بار کال کریں: سب سے پہلے فریاد پر، تقریب کی قدر جب` num` برابر `10` ابھی تک عارضی نہیں ہے. cache` میں تو بیان `NUM کی شرط واپس` FALSE`، اور کچھ اور بلاک قتل ہو جاتا: `محسوب! 20` ریکارڈ ہو جاتا ہے، اور نتیجہ کی قدر کیشے اعتراض میں شامل کیا جاتا ہے. `cache` اب جیسے` {10: 20} لگتا `.

دوسری بار، `cache` اعتراض قدر` 10` لئے واپس آ جاتا ہے پر مشتمل ہے. cache` میں تو بیان `NUM کی شرط` TRUE`، اور ` 'واپس کیش سے! 20'` ریکارڈ ہو جاتا ہے.

تیسری بار، ہم تقریب جس `10` کو اندازہ ہو جاتا ہے کرنے کے لئے` 5 * 2` گزر. `cache` اعتراض قدر` 10` لئے واپس آ جاتا ہے پر مشتمل ہے. cache` میں تو بیان `NUM کی شرط` TRUE`، اور ` 'واپس کیش سے! 20'` ریکارڈ ہو جاتا ہے.

</ P>
</ تفصیلات>

---

###### 79. آؤٹ پٹ کیا ہے؟

`` `جاوا سکرپٹ
CONST myLifeSummedUp = [ "☕"، "💻"، "🍷"، "🍫"]

کے لئے (myLifeSummedUp میں آئٹم دیں) {
 console.log کے (شے)
}

کے لئے (myLifeSummedUp کی شے دیں) {
 console.log کے (شے)
}
`` `

- A: `0`` 1` `2`` 3` اور `" ☕ "` `" 💻 "` `" 🍷 "` `" 🍫 "`
- B: `" ☕ "` `" 💻 "` `" 🍷 "` `" 🍫 "` اور `" ☕ "` `" 💻 "` `" 🍷 "` `" 🍫 "`
- C: `" ☕ "` `" 💻 "` `" 🍷 "` `" 🍫 "` اور `0`` 1` `2`` 3`
- D: `0`` 1` `2`` 3` اور `{0:" ☕ "، 1:" 💻 "، 2:" 🍷 "، 3:" 🍫 "}`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: ایک

ایک _for-in_ لوپ کے ساتھ، ہم ** قابل شمار ** جائیدادوں پر iterate کر سکتے ہیں. ایک صف میں، قابل شمار خواص جو اصل میں ان کے اشاریہ جات ہیں صف عناصر، کے "چابیاں" ہیں. تم ایک صف کے طور پر دیکھ سکتا تھا:

`{0:" ☕ "، 1:" 💻 "، 2:" 🍷 "، 3:" 🍫 "}`

کہاں چابیاں قابل شمار خواص ہیں. `0`` 1` `2`` ریکارڈ حاصل 3`.

ایک _for-of_ لوپ کے ساتھ، ہم پر iterate کر سکتے ہیں ** iterables **. ایک صف میں ایک iterable ہے. ہم صف پر iterate جب، متغیر "شے" عنصر یہ فی الحال پر iterating رہا ہے کے برابر ہے، `" ☕ "` `" 💻 "` `" 🍷 "` `" 🍫 "` انتخاب حاصل.

</ P>
</ تفصیلات>

---

###### 80. آؤٹ پٹ کیا ہے؟

`` `جاوا سکرپٹ
CONST فہرست = [1 + 2، 1 * 2، 1/2]
console.log کے (فہرست)
`` `

- A: `[" 1 + 2 "،" 1 * 2 "،" 1/2 "]`
- B: `[" 12 "، 2، 0.5]`
- C: `[3، 2، 0.5]`
- D: `[1، 1، 1]`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: C

لڑی عناصر کسی بھی قدر کے حامل ہیں کر سکتے ہیں. نمبرز، ڈور، اشیاء، دیگر لڑیاں، شہوت انگیز null، بولین اقدار، جانچ، اور اس طرح کے طور پر تاریخوں، افعال، اور حساب دیگر اظہارات.

عنصر واپس کیا قیمت کے برابر ہو جائے گا. `1 + 2` ریٹرن` 3`، `1 * 2` ریٹرن` 2`، اور `1 / 2` ریٹرن` 0.5`.

</ P>
</ تفصیلات>

---

###### 81. آؤٹ پٹ کیا ہے؟

`` `جاوا سکرپٹ
تقریب sayHi (نام) {
 واپس آ `ہیلو، $ {نام}`
}

console.log کے (sayHi ())
`` `

- A: `ہیلو وہاں،`
- B: `ہیلو، undefined`
- C: `ہیلو، null`
- D: `ReferenceError`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: بی

بنیادی طور پر، دلائل، جب تک ایک قدر تقریب میں منظور کیا گیا ہے، undefined` `کی قدر ہے. اس صورت میں، ہم `name` دلیل کے لئے ایک قدر منظور نہیں کیا. `name` undefined` ریکارڈ ہو جاتا ہے جس کے` کے برابر ہے.

ES6 میں، ہم اس ڈیفالٹ `ڈیفالٹ پیرامیٹرز کے ساتھ undefined` قدر ادلیکھت کر سکتے ہیں. مثال کے طور پر:

`تقریب sayHi (نام =" لڈا ") {...}`

اس صورت میں، ہم نے ایک قیمت منتقل نہیں کیا تو یا ہم `undefined` منظور ہے تو،` name` ہمیشہ سٹرنگ `Lydia` کے برابر ہو گی

</ P>
</ تفصیلات>

---

###### 82. آؤٹ پٹ کیا ہے؟

`` `جاوا سکرپٹ
متغیر کی حیثیت = "😎"

setTimeout (() => {
 CONST کی حیثیت = "😍"

 CONST کے اعداد و شمار = {
 حیثیت: "🥑"،
 getStatus () {
 this.status واپس آ جائیں
 }
 }

 console.log کے (data.getStatus ())
 console.log کے (data.getStatus.call (یہ))
}، 0)
`` `

- A: `" 🥑 "` اور `" 😍 "`
- B: `" 🥑 "` اور `" 😎 "`
- C: `" 😍 "` اور `" 😎 "`
- D: `" 😎 "` اور `" 😎 "`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: بی

`this` مطلوبہ لفظ کی قدر میں جہاں آپ اسے استعمال پر منحصر ہے. ایک ** طریقہ کار ** میں، `getStatus` طریقہ کار کی طرح،` this` مطلوبہ لفظ _the اعتراض طریقہ کار to_ تعلق رکھتا ہے کہ مراد ہے. `اتنا this`` data` اعتراض سے مراد طریقہ، `data` اعتراض سے تعلق رکھتا ہے. ہم `this.status` لاگ ان کرتے ہیں تو،` `data` اعتراض پر status` املاک جس` ہے "🥑" `ریکارڈ ہو جاتا ہے.

`call` طریقہ کار کے ساتھ، ہم اعتراض` this` مطلوبہ لفظ جس سے مراد کو تبدیل کرسکتے ہیں. *** افعال ** میں، `this` مطلوبہ الفاظ کی تقریب to_ تعلق رکھتا ہے کہ _the اعتراض سے مراد ہے. ہم `_global object_ پر setTimeout` تقریب کا اعلان` setTimeout` تقریب کے اندر اندر اتنی، `this` مطلوبہ لفظ _global object_ سے مراد ہے. عالمی شئی پر، `" 😎 "` کی قدر کے ساتھ _status_ نامی ایک متغیر ہے. لاگنگ جب `this.status`،` "😎" `ریکارڈ ہو جاتا ہے.


</ P>
</ تفصیلات>

---

###### 83. آؤٹ پٹ کیا ہے؟

`` `جاوا سکرپٹ
CONST شخص = {
 نام: "لڈا"،
 عمر: 21
}

دو شہر = person.city
شہر = "ایمسٹرڈیم"

console.log کے (شخص)
`` `

- A: `{نام:" لڈا "، عمر: 21}`
- B: `{نام:" لڈا "، عمر: 21، شہر:" ایمسٹرڈیم "}`
- C: `{نام:" لڈا "، عمر: 21، شہر: غیروضاحتی}`
- D: `" ایمسٹرڈیم "`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: ایک

ہم متغیر `` `person` اعتراض پر city` نامی جائیداد کی قیمت کے برابر city` مقرر. `city` نامی اس اعتراض کی کوئی جائیداد نہیں ہے، تو متغیر` city` undefined` `کی قدر ہے.

ہم _not_ `person` اعتراض خود حوالہ کر رہے ہیں یاد رکھیں کہ! ہم صرف متغیر `` person` اعتراض پر `city` جائیداد کی موجودہ قیمت کے برابر city` مقرر.

اس کے بعد، ہم `سٹرنگ` "ایمسٹرڈیم" `برابر city` مقرر. اس شخص نے اعتراض کو تبدیل نہیں کرتا: اس اعتراض کا کوئی حوالہ نہیں ہے.

`person` اعتراض لاگنگ جب، غیرترمیم شدہ اعتراض واپس آ جاتا ہے. 

</ P>
</ تفصیلات>

---

###### 84. آؤٹ پٹ کیا ہے؟

`` `جاوا سکرپٹ
تقریب checkAge (عمر) {
 اگر (عمر <18) {
 CONST پیغام = "معاف کیجئے گا، آپ کو بہت چھوٹے ہو."
 } ورنہ {
 CONST پیغام = "ہاں ہاں! تم پرانے کافی ہو!"
 }

 واپسی کا پیغام
}

console.log کے (checkAge (21))
`` `

- A: `" معاف کیجئے گا، آپ کو بہت چھوٹے ہو. "`
- B: `"! گرما تم کافی پرانی ہو! "`
- C: `ReferenceError`
- D: `undefined`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: C

`const` اور` let` مطلوبہ الفاظ کے ساتھ متغیر _block-scoped_ ہیں. A بلاک گھوبگھرالی بریکٹ ( `{}`) کے درمیان کچھ بھی ہے. اس صورت میں، اگر / باقی بیانات کی گھوبگھرالی بریکٹ. آپ کے ٹکڑے اس میں قرار دیا گیا ہے کے باہر ایک متغیر حوالہ نہیں کر سکتے ہیں، ایک ReferenceError پھینک دیا جاتا ہے.

</ P>
</ تفصیلات>

---

###### 85. معلومات کی قسم کا انتخاب ملے گا؟

`` `جاوا سکرپٹ
بازیافت ( 'https://www.website.com/api/user/1')
 .پھر (لوڈ => res.json ())
 .پھر (لوڈ => console.log کے (لوڈ))
`` `

- A: `fetch` طریقہ کار کا نتیجہ.
- B: `fetch` طریقہ کار کے دوسرے فریاد کا نتیجہ.
- C: پچھلے `.پھر میں کال بیک (کے نتیجہ)`.
- D: یہ ہمیشہ جانچ کی جائے گی. 

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: C

سیکنڈ `.then` پچھلے` .then` کے واپس آ قدر کے برابر ہے میں res` `کی قدر. آپ `جکڑا جانا یہ قیمت اگلے ہینڈلر کے لئے منظور کیا جاتا ہے جہاں کی طرح .then`s رکھ سکتے ہیں.

</ P>
</ تفصیلات>

---

###### 86. کون سا اختیار آپ `ایک دلیل کے طور TRUE` پاس نہیں کر سکتے فراہم کی، hasName` TRUE`` کے برابر مقرر کرنے کی `ایک طریقہ ہے؟

`` `جاوا سکرپٹ
تقریب getName (نام) {
 CONST hasName = //
}
`` `

- A: `!! name`
- B: `name`
- C: `نئے بولین (نام)`
- D: `name.length`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: ایک

`کے ساتھ !! name`، ہم اس بات کا تعین name`` کی قدر truthy یا falsy ہے یا نہیں. نام truthy ہے تو ہم آپ کے لئے جانچ کرنا چاہتے ہیں جس میں، `! FALSE` لوٹاتا name`.` `FALSE`! (` !! name` عملی طور پر کیا ہے) `TRUE` واپس.

مقرر کرتے ہوئے `name`، آپ hasName` جو بھی قیمت آپ` getName` تقریب نہ بولین قدر `TRUE` کو منظور کرنے کے برابر مقرر` `برابر hasName`.

`نئے بولین (سچے)` کسی چیز چادر نہ بولین قدر خود واپس.

`name.length`، منظور دلیل کی لمبائی واپس یہ` TRUE` ہے نہیں.

</ P>
</ تفصیلات>

---

###### 87. آؤٹ پٹ کیا ہے؟

`` `جاوا سکرپٹ
console.log کے ( "میں پیزا چاہتے ہیں" [0])
`` `

- A: `" "" `
- B: `" میں "`
- C: `SyntaxError`
- D: `undefined`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: بی

ایک تار میں ایک مخصوص انڈیکس پر ایک کردار حاصل کرنے کے لئے، آپ کو بریکٹ سنکیتن استعمال کر سکتے ہیں. سٹرنگ میں پہلے کردار اسی انڈیکس 0، اور ہے. اس صورت میں ہم عنصر جس انڈیکس ہے 0، کردار `" I'`، ریکارڈ ہو جاتا ہے جس کے حاصل کرنے کے لئے چاہتے ہیں.

اس طریقے IE7 میں اور نیچے کی سہولت نہیں ہے یاد رکھیں کہ. اس صورت میں، .charAt کا استعمال `()`

</ P>
</ تفصیلات>

---

###### 88. آؤٹ پٹ کیا ہے؟

`` `جاوا سکرپٹ
تقریب رقم (num1، num2 = num1) {
 console.log کے (num1 + num2)
}

رقم (10)
`` `

- A: `NaN`
- B: `20`
- C: `ReferenceError`
- D: `undefined`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: بی

وہ کے طور پر پہلے سے طے شدہ پیرامیٹر _before_ بیان کیا گیا ہے کے تم ایک ڈیفالٹ پیرامیٹر کی قدر تقریب کا ایک پیرامیٹر کے برابر تک کے طور پر مقرر کر سکتے ہیں. ہم قدر `10`` sum` تقریب کو منتقل. `sum` تقریب صرف 1 دلیل حاصل کرتا ہے تو یہ` num2` لئے قیمت منظور نہیں ہے کا مطلب ہے کہ، اور num1` `کی قدر منظور قدر` 10` اس معاملے میں کے برابر ہے. num2` `کے ڈیفالٹ قدر` num1`، جس `10` کی قدر ہے. `num1 + num2` ریٹرن` 20`.

آپ کو ایک پہلے سے طے شدہ پیرامیٹر کی قدر ایک پیرامیٹر (دائیں جانب) _after_ وضاحت کی گئی ہے جس کے برابر مقرر کرنے کی کوشش کر رہے ہیں، پیرامیٹر کی قدر ابھی سے initialized نہیں کیا گیا ہے، ایک خرابی پھینک دیں گے جس میں. 

</ P>
</ تفصیلات>

---

###### 89. آؤٹ پٹ کیا ہے؟

`` `جاوا سکرپٹ
// module.js 
برآمد ڈیفالٹ () => "ہیلو دنیا"
برآمد CONST نام = "لڈا"

// index.js 
"./module" سے ڈیٹا کی درآمد *

console.log کے (ڈیٹا)
`` `

- A: `{ڈیفالٹ: تقریب سے طے شدہ ()، نام" لڈا "}`
- B: `{ڈیفالٹ: تقریب سے طے شدہ ()}`
- C: `{ڈیفالٹ:" ہیلو دنیا "، نام" لڈا "}`
- D: `module.js` کے گلوبل اعتراض

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: ایک

name` نحو طور `درآمد * کے ساتھ، ہم` `بلایا data` تخلیق کیا جاتا ہے ایک نئی چیز کے طور index.js` فائل میں` module.js` فائل سے _all exports_ درآمد کریں. ڈیفالٹ برآمد، اور ایک نامی برآمد: `module.js` فائل میں، دو برآمدات موجود ہیں. ڈیفالٹ برآمد سٹرنگ `" ہیلو دنیا "` واپس جس میں ایک تقریب ہے، اور نامی برآمد نامی ایک متغیر ہے `سٹرنگ` "لڈا" `کی قدر ہے جس name`.

`data` اعتراض ڈیفالٹ برآمد کے لئے ایک` default` جائیداد ہے، دیگر خصوصیات نامی برآمدات اور ان کے اسی اقدار کے نام ہیں. 

</ P>
</ تفصیلات>

---

###### 90. آؤٹ پٹ کیا ہے؟

`` `جاوا سکرپٹ
کلاس شخص {
 ڈویلپر (نام) {
 this.name = نام
 }
}

CONST رکن = نئے شخص ( "جان")
console.log کے (typeof رکن)
`` `

- A: `" کلاس "`
- B: `" تقریب "`
- C: `" اعتراض "`
- D: `" سٹرنگ "`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: C

کلاسز تقریب تعمیر کے لئے نحوی چینی کی ہے. ایک تقریب تعمیر طور `Person` طبقے کے برابر ہو جائے گا:

`` `جاوا سکرپٹ
تقریب شخص () {
 this.name = نام
}
`` `

`ایک مثال کے طور پر` Person`، `typeof` مطلوبہ الفاظ کی ریٹرن` "اعتراض" `کی ایک مثال کی تخلیق میں new` نتائج کے ساتھ ایک تقریب تعمیر کالنگ. `typeof member` ریٹرن` "اعتراض" `.

</ P>
</ تفصیلات>

---

###### 91. آؤٹ پٹ کیا ہے؟

`` `جاوا سکرپٹ
دو newList = [1، 2، 3] .پش (4)

console.log کے (newList.push (5))
`` `

- A: `[1، 2، 3، 4، 5]`
- B: `[1، 2، 3، 5]`
- C: `[1، 2، 3، 4]`
- D: `Error`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

#### جواب: D

`.push` طریقہ کار صف کے _new length_ واپس نہ صف خود! مقرر کرتے ہوئے `newList` برابر` [1، 2، 3] .پش (4) `، ہم مقرر` newList` صف کے نئے لمبائی کے برابر: `4`.

اس کے بعد، ہم `` پر newList` .push` طریقہ کار کو استعمال کرنے کی کوشش کریں. ایک TypeError پھینک دیا جاتا ہے: `newList` عددی قدر` 4` ہے کے بعد سے، ہم `.push` طریقہ کار کا استعمال نہیں کر سکتے.

</ P>
</ تفصیلات>

---

###### 92. آؤٹ پٹ کیا ہے؟

`` `جاوا سکرپٹ
giveLydiaPizza تقریب () {
 واپسی "یہاں پیزا ہے!"
}

CONST giveLydiaChocolate = () => "یہاں چاکلیٹ ہے ... اب پہلے سے ہی جم مارا جانا."

console.log کے (giveLydiaPizza.prototype)
console.log کے (giveLydiaChocolate.prototype)
`` `

- A: `{ڈویلپر: ...}` `{ڈویلپر: ...}` 
- B: `{}` `{ڈویلپر: ...}` 
- C: `{ڈویلپر: ...}` `{}`
- D: `{ڈویلپر: ...}` `undefined`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

#### جواب: D

جیسے `giveLydiaPizza` تقریب باقاعدہ افعال، ایک` constructor` جائیداد کے ساتھ کسی چیز کو (پروٹوٹائپ اعتراض) ہے جس کی وجہ `prototype` جائیداد، ہے. جیسے `giveLydiaChocolate` تقریب افعال تیر تاہم، یہ` prototype` جائیداد نہیں ہے. `giveLydiaChocolate.prototype` استعمال کرتے ہوئے` `prototype` جائیداد تک رسائی حاصل کرنے کی کوشش کرتے وقت undefined` واپس آ جاتا ہے.

</ P>
</ تفصیلات>

---

###### 93. آؤٹ پٹ کیا ہے؟

`` `جاوا سکرپٹ
CONST شخص = {
 نام: "لڈا"،
 عمر: 21
}

کے لئے {(CONST [X، Y] Object.entries (شخص) کے)
 console.log کے (X، Y)
}
`` `

- A: `name`` Lydia` اور `age`` 21`
- B: `[" نام "،" لڈا "]` اور `[" عمر "، 21]` 
- C: `[" نام "،" عمر "]` اور `undefined`
- D: `Error`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: ایک

`Object.entries (شخص)` اندر در اندر arrays کے ایک صف، چابیاں اور اشیاء پر مشتمل واپسی:

`[[ 'نام'، 'لدیہ']، [ 'عمر'، 21]]` 

`غیر of` لوپ استعمال کرتے ہوئے، ہم ایک عنصر پر سرنی میں، subarrays اس صورت میں دہرانا کر سکتے ہیں. ہم کے لئے کی لوپ کا استعمال کرتے ہوئے `CONST [X، Y]` میں نے فوری طور پر subarrays destructure سکتے ہیں. `x` subarray میں پہلا عنصر کے برابر ہے،` y` subarray میں دوسرا عنصر کے برابر ہے.

پہلی subarray `` x` برابر `" نام "`، اور `` "لڈا" `کرنے y` برابر، کیوںہو جاتا ہے جس کے ساتھ ہے [" نام "،" لڈا "]`.
`` ریکارڈ حاصل ہے جس میں "عمر" `، اور` `21` کرنے y` برابر، برابر x` ساتھ دوسری subarray،` ہے [ "عمر"، 21] `.

</ P>
</ تفصیلات>

---

###### 94. آؤٹ پٹ کیا ہے؟

`` `جاوا سکرپٹ
تقریب getItems (fruitList، ... ARGS، favoriteFruit) {
 واپس آ جائیں [... fruitList، ... ARGS، favoriteFruit]
}

getItems ([ "کیلا"، "سیب"]، "ناشپاتیاں"، "اورنج")
`` `

- A: `[" کیلا "،" سیب "،" ناشپاتیاں "،" اورنج "]`
- B: `[[" کیلا "،" سیب "]،" ناشپاتیاں "،" اورنج "]` 
- C: `[" کیلا "،" سیب "، [" ناشپاتی "]،" اورنج "]`
- D: `SyntaxError`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

#### جواب: D

`... args` آرام پیرامیٹر ہے. باقی پیرامیٹر کی قدر باقی تمام دلائل پر مشتمل ایک صف ہے، *** اور صرف گزشتہ پیرامیٹر ہو سکتا ہے **! اس مثال میں، باقی پیرامیٹر دوسرے پیرامیٹر تھا. یہ ممکن نہیں ہے، اور ایک نحوی خامی پھینک دیں گے.

`` `جاوا سکرپٹ
تقریب getItems (fruitList، favoriteFruit، ... ARGS) {
 واپس آ جائیں [... fruitList، ... ARGS، favoriteFruit]
}

getItems ([ "کیلا"، "سیب"]، "ناشپاتیاں"، "اورنج")
`` `

اوپر کی مثال کام کرتا ہے. یہ صف `[ 'کیلا'، 'ایپل'، 'نارنجی'، 'ناشپاتی']` واپس
</ P>
</ تفصیلات>

---

###### 95. آؤٹ پٹ کیا ہے؟

`` `جاوا سکرپٹ
تقریب nums (A، B) {
 اگر
 (ا> ب)
 console.log کے ( 'ایک بڑا ہے')
 ورنہ 
 console.log کے ( 'ب بڑا ہے')
 واپسی 
 A + B
}

console.log کے (nums (4، 2))
console.log کے (nums (1، 2))
`` `

- A: ایک bigger` ہے `` 6` اور `ب bigger` ہے` 3`
- B: `ایک، bigger`` undefined` ہے اور `ب bigger` ہے،` undefined`
- C: `undefined` اور` undefined`
- D: `SyntaxError`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: بی

جاوا میں، ہم نیم وقفہ لکھنے کے لئے _have_ نہیں ( `؛`) واضح طور پر، تاہم جاوا سکرپٹ کے انجن کو اب بھی بیانات کے بعد ان کا اضافہ کر دیتی. یہ ** خودکار سیمی کولن اضافے ** کہا جاتا ہے. ایک بیان مثال کے `طرح throw`،` return`، `break`، وغیرہ متغیر، یا مطلوبہ الفاظ ہو سکتے ہیں

یہاں، ہم نے ایک `return` بیان، اور ایک اور قدر` ایک ایک _new line_ پر + b` لکھا. تاہم، یہ ایک نئی سطر ہے کے بعد سے، کے انجن نہیں جانتا ہے کہ یہ اصل قدر ہے کہ ہم واپس کرنا چاہتا ہے. اس کے بجائے، یہ خود کار طریقے return` `بعد ایک نیم وقفہ میں شامل کیا. آپ کے طور پر اس کو دیکھ سکتا ہے:

`` `جاوا سکرپٹ
 واپس؛
 A + B
`` `

اس کا مطلب یہ ہے کہ `A + b` پہنچ کبھی نہیں رہا ہے، ایک تقریب` return` مطلوبہ الفاظ کے پیچھے بھاگ رک جاتا ہے کے بعد سے. کوئی قیمت واپس آ جاتا ہے تو یہاں کی طرح، تقریب `undefined` واپس. `اگر / else` بیانات کے بعد کوئی خود کار طریقے سے اندراج نہیں ہے یاد رکھیں کہ!

</ P>
</ تفصیلات>

---

###### 96. آؤٹ پٹ کیا ہے؟

`` `جاوا سکرپٹ
کلاس شخص {
 ڈویلپر () {
 this.name = "لڈا"
 }
}

پرسنز = کلاس AnotherPerson {
 ڈویلپر () {
 this.name = "سارہ"
 }
}

CONST رکن = نئے شخص ()
console.log کے (member.name)
`` `

- A: `" لڈا "`
- B: `" سارہ "`
- C: `خرابی: redeclare نہیں کر سکتے Person`
- D: `SyntaxError`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: بی

ہم دیگر کلاسوں / تقریب تعمیر کے برابر کلاسوں مقرر کر سکتے ہیں. اس صورت میں، ہم نے مقرر `Person` AnotherPerson`` کے برابر. اس ڈویلپر اجراء نام `Sarah` ہے، لہذا نئی` Person` مثال `member` اجراء نام جائیداد` "سارہ" `ہے.

</ P>
</ تفصیلات>

---

###### 97. آؤٹ پٹ کیا ہے؟

`` `جاوا سکرپٹ
CONST معلومات = {
 [علامت ( 'ایک')] 'B'
}

console.log کے (معلومات)
console.log کے (Object.keys (معلومات))
`` `

- A: `{علامت ( 'ایک'): 'ب'}` اور `[" {علامت (علیہ السلام) "]`
- B: `{}` اور `[]`
- C: `{ج:" ب "}` اور `[" ایک "]`
- D: `{علامت ( 'ایک'): 'ب'}` اور `[]`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

#### جواب: D

علامت _enumerable_ نہیں ہے. Object.keys طریقہ کار کسی چیز پر تمام _enumerable_ چابی خواص واپس. علامت ظاہر ہو نہیں کرے گا، اور ایک خالی صف واپس آ جاتا ہے. پورے اعتراض لاگنگ کی تو تمام خصوصیات کو دیکھا جا سکے گا، یہاں تک کہ غیر قابل شمار ہیں.

یہ ایک علامت کے بہت سے خصوصیات میں سے ایک ہے: (ایک ہی شئے میں خصوصیات شامل کرنے کے لئے چاہتے ہیں کہ 2 لائبریریوں کے ساتھ کام کرتے وقت مثال کے طور پر اشیاء پر حادثاتی نام تصادم روکتا ہے) ایک مکمل طور پر منفرد قیمت کی نمائندگی کرنے کے علاوہ، آپ کر سکتے ہیں بھی "چھپانے" اس طرح اشیاء پر خصوصیات (اگرچہ مکمل طور پر نہیں ہے. آپ اب بھی `Object.getOwnPropertySymbols ()` طریقہ استعمال کرتے ہوئے علامتوں تک رسائی حاصل کر سکتے ہیں).

</ P>
</ تفصیلات>

---

###### 98. آؤٹ پٹ کیا ہے؟

`` `جاوا سکرپٹ
CONST getList = ([X، ... Y]) => [X، Y]
CONST getUser = صارف => {نام: user.name، عمر: user.age}

CONST فہرست = [1، 2، 3، 4]
CONST صارف = {نام: "لڈا"، عمر: 21}

console.log کے (getList (فہرست))
console.log کے (getUser (صارف))
`` `

- A: `[1، [2، 3، 4]]` اور `undefined`
- B: `[1، [2، 3، 4]]` اور `{نام:" لڈا "، عمر: 21}`
- C: `[1، 2، 3، 4]` اور `{نام:" لڈا "، عمر: 21}`
- D: `Error` اور` {نام: "لڈا"، عمر: 21} `

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: ایک

`getList` دالہ کو اس دلیل کے طور پر ایک صف حاصل کرتا ہے. `getList` تقریب کا قوسین کے درمیان، ہم فورا اس صف destructure. آپ کے طور پر اس کو دیکھ سکتا ہے:

 `[X، ... Y] = [1، 2، 3، 4]`

باقی پیرامیٹر کے ساتھ `... y`، ہم سب" باقی "دلائل ایک صف میں ڈال دیا. باقی دلائل `2`،` 3` اور `اس کیس میں 4` ہیں. y` `کی قدر باقی سب پیرامیٹرز مشتمل ایک صف ہے. x` `کی قدر اس معاملے میں` 1` کے برابر ہے، اس لیے ہم کو لاگ جب `[X، Y]` `[1، [2، 3، 4]]` ریکارڈ ہو جاتا ہے.

`getUser` تقریب کسی چیز حاصل کرتا ہے. تیر کے افعال کے ساتھ، ہم گھوبگھرالی بریکٹ لکھنے کے لئے _have_ نہیں کرتے ہم تو صرف ایک قدر واپس تو. تاہم، آپ کو ایک تیر تقریب سے ایک _object_ واپس کرنا چاہتے ہیں تو، آپ کو قوسین کے درمیان یہ لکھنے کے لئے، دوسری صورت میں کوئی قیمت واپس آ جاتا ہے! مندرجہ ذیل فعل کسی چیز کو واپس لوٹ چکے ہوتے:

`` `CONST getUser = صارف => ({نام: user.name، عمر: user.age})` ``

چونکہ کوئی قیمت اس صورت میں واپس آ جاتا ہے، تقریب `undefined` واپس.

</ P>
</ تفصیلات>

---

###### 99. آؤٹ پٹ کیا ہے؟

`` `جاوا سکرپٹ
CONST نام = "لڈا"

console.log کے (نام ())
`` `

- A: `SyntaxError`
- B: `ReferenceError`
- C: `TypeError`
- D: `undefined`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: C

متغیر `name` ایک سٹرنگ، جس میں ایک تقریب نہیں ہے، اس طرح پکارتے نہیں کر سکتے کی قدر رکھتا ہے. 

ایک قدر توقع کی قسم کی نہیں ہے جب TypeErrors پھینک دیا ہو جاتے ہیں. جاوا `name` توقع ہم اس کو کالعدم قرار دینے کی کوشش کر رہے ہیں کے بعد سے ایک تقریب ہو. تاہم یہ ایک تار تھا، تو ایک TypeError پھینک دیا جاتا ہے: نام ایک تقریب نہیں ہے!

SyntaxErrors آپ اس مثال کے طور پر درست نہیں ہے جاوا، آپ لفظ `` retrun` طور return` لکھا ہے جب کسی چیز لکھا ہے جب پھینک دیا ہو جاتے ہیں. 
جاوا سکرپٹ ایک قدر آپ تک رسائی حاصل کرنے کی کوشش کر رہے ہیں کہ ایک حوالہ تلاش کرنے کے قابل نہیں ہے جب ReferenceErrors پھینک دیا ہو جاتے ہیں.

</ P>
</ تفصیلات>

---

###### 100. پیداوار کی قدر کیا ہے؟

`` `جاوا سکرپٹ
// 🎉✨ یہ میرا کی 100th سوال ہے! ✨🎉

CONST پیداوار = `$ {[] && 'آئی ایم'} ممکن!
آپ کو $ چاہئے lol` { '' && `n't`} اتنا جاوا بعد ایک تھراپسٹ دیکھیں
`` `

- A: `ممکن! تم اتنا جاوا lol` بعد ایک تھراپسٹ دیکھنا چاہئے
- B: `ناممکن! تم اتنا جاوا lol` بعد ایک تھراپسٹ دیکھنا چاہئے
- C: `ممکن! تم اتنا جاوا lol` بعد ایک تھراپسٹ نظر نہیں کرنا چاہئے
- D: `ناممکن! تم اتنا جاوا lol` بعد ایک تھراپسٹ نظر نہیں کرنا چاہئے

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: بی

`[]` ایک truthy قدر ہے. `&&` آپریٹر کے ساتھ، بائیں ہاتھ کی قدر ایک truthy قدر ہے تو دائیں ہاتھ کی قدر لوٹائی جائے گی. اس صورت میں، بائیں ہاتھ کی قدر `[]` ایک truthy قدر ہے، لہذا `" Im'` واپس آ جاتا ہے.

`" "` ایک falsy قدر ہے. بائیں ہاتھ قدر falsy ہے، تو کچھ بھی نہیں واپس آ جاتا ہے. `n't` لوٹائے نہ ہو جائے.

</ P>
</ تفصیلات>

---

###### 101. پیداوار کی قدر کیا ہے؟

`` `جاوا سکرپٹ
CONST سے ایک = (جھوٹے || {} || کالعدم)
CONST دو = (کالعدم || جھوٹے || "")
CONST تین = ([||] 0 || سچ)

console.log کے (ایک، دو، تین)
`` `

- A: `FALSE`` null` `[]`
- B: `null`` "" `` TRUE`
- C: `{}` `" "` `[]`
- D: `null`` null` `TRUE`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: C

`||` آپریٹر کے ساتھ، ہم سب سے پہلے truthy اوپیرانڈ واپس آ سکتے ہیں. تمام اقدار falsy ہیں، گزشتہ اوپیرانڈ واپس آ جاتا ہے.

`(جھوٹے || {} || انگیز null)`: خالی اعتراض `{}` ایک truthy قدر ہے. یہ پہلا (اور صرف) truthy قدر، واپس آ جاتا ہے ہے. `one` کے برابر ہے` {} `.

`(کالعدم || جھوٹے ||" ")`: تمام operands falsy اقدار ہیں. اس کا مطلب ہے کہ ماضی اوپیرانڈ، `" "` واپس آ جاتا ہے. `two`" "` کرنے `برابر ہے.

`([] || 0 ||" ")`: خالی array` [] `ایک truthy قدر ہے. یہ پہلا truthy قدر، واپس آ جاتا ہے ہے. `three`` [] `کے برابر ہے.

</ P>
</ تفصیلات>

---

###### 102. پیداوار کی قدر کیا ہے؟

`` `جاوا سکرپٹ
CONST myPromise = () => Promise.resolve ( 'میں نے حل کر دیا ہے!')

تقریب firstFunction () {
 myPromise (). پھر (لوڈ => console.log کے (لوڈ))
 console.log کے ( 'دوسرا')
}

کرنے async تقریب secondFunction () {
 console.log کے (myPromise منتظر ())
 console.log کے ( 'دوسرا')
}

firstFunction ()
secondFunction ()
`` `

- A: `میں حل کر لیا ہے` `second` اور` میں نے حل کر لیا ہے `` second`
- B: `second`،` میں نے حل کر لیا ہے `اور` second`، `میں نے حل کر لیا ہے`!
- C: `میں حل کر لیا ہے` `second` اور` second`، `میں نے حل کر لیا ہے`!
- D: `second`،` میں نے حل کر لیا ہے `اور` میں نے حل کر لیا ہے `` second`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

#### جواب: D

ایک وعدہ کے ساتھ، ہم بنیادی طور پر _I اس تقریب کو پھانسی کرنا چاہتے ہیں، لیکن میں جبکہ یہ چل رہا ہے اس میں کچھ وقت لگ سکتا ہے کے بعد سے اب کے لئے ایک طرف ڈال دیں گے. ایک مخصوص قیمت پر حل صرف اس وقت جب ہے (یا مسترد کر دیا)، اور کال اسٹیک خالی ہے، جب میں نے یہ value._ استعمال کرنا چاہتے ہیں

ہم دونوں `.then` اور` ایک `async` تقریب میں await` مطلوبہ الفاظ کے ساتھ اس قدر مل سکتا ہے. ہم دونوں `.then` اور` کے ساتھ ایک وعدہ کی قیمت حاصل کر سکتے ہیں، اگرچہ await`، وہ تھوڑا سا مختلف کام کرتے ہیں.

`firstFunction` میں، ہم (ایک طرح سے) یہ چل رہا تھا، لیکن دوسرے کوڈ، ہے جو` console.log کے ( 'دوسرا') `میں اس کیس چل رہا ہے جاری ایک طرف myPromise تقریب رکھ دیا. اس کے بعد، تقریب سٹرنگ کے ساتھ حل `میں نے یہ دیکھا کے بعد callstack خالی تھا کہ جو اس کے بعد انتخاب کر لی resolved` ہیں.

`secondFunction` میں انتظار مطلوبہ الفاظ کے ساتھ، ہم لفظی ایک کرنے async تقریب کی کارکردگی کو موقوف تک قدر اگلی لائن پر منتقل befoer حل کیا گیا ہے.

`second` ریکارڈ کیا گیا ہے: یہ جو قیمت کے ساتھ حل کرنے کے لئے` میں resolved` ہے، اور جو کچھ بھی ہوا صرف ایک بار، ہم اگلی لائن پر منتقل کر دیا `myPromise` انتظار کیا مطلب ہے کہ. 

</ P>
</ تفصیلات>

---

###### 103. پیداوار کی قدر کیا ہے؟

`` `جاوا سکرپٹ
CONST سیٹ = نیا سیٹ ()

set.add (1)
set.add ( "لڈا")
set.add ({نام: "لڈا"})

کے لئے (سیٹ کے آئٹم دیں) {
 console.log کے (شے + 2)
}
`` `

- A: `3`،` NaN`، `NaN`
- B: `3`،` 7`، `NaN`
- C: `3`،` Lydia2`، `[آبجیکٹ اعتراض] 2`
- D: `" 12 "` `Lydia2`،` [آبجیکٹ اعتراض] 2`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: C

`+` آپریٹر صرف numerica lvalues ​​شامل کرنے کے لئے نہیں استعمال کیا جاتا ہے، لیکن ہم نے ڈور سلسلہ بندی کرنا کے لئے اسے استعمال کر سکتے ہیں. جاوا سکرپٹ کے انجن کو دیکھتا ہے کہ جب بھی ایک یا ایک سے زیادہ اقدار ایک نمبر نہیں ہیں، یہ ایک تار میں تعداد کو coerces.

سب سے پہلے ایک ہے جس میں ایک عددی قدر ہے، 1` `ہے. `1 + 2` نمبر 3 کی واپسی.

تاہم، دوسری ایک ایک تار `" لڈا "` ہے. `" لڈا "` ایک تار ہے اور `2` ایک بڑی تعداد ہے:` 2` ایک سٹرنگ میں مجبور ہو جاتا ہے. `" لڈا "` اور `" 2 "` ملتا لئے concatenated، جس سٹرنگ `" Lydia2 "` میں hresults.

`{نام:" لڈا "}` کسی چیز ہے. ایک بڑی تعداد ہے اور نہ ہی کسی چیز نہ تو ایک تار ہے، تو یہ دونوں stringifies. ہم ایک باقاعدہ اعتراض stringify جب بھی، یہ ہو جاتا ہے `" [آبجیکٹ اعتراض] "`. `" [آبجیکٹ اعتراض] "` کے ساتھ `" 2 "` بن جاتا ہے `" [آبجیکٹ اعتراض] 2 "` لئے concatenated.

</ P>
</ تفصیلات>

---

###### 104. اس کی قیمت کیا ہے؟

`` `جاوا سکرپٹ
Promise.resolve (5)
`` `

- A: `5`
- B: `وعدہ {<زیر التوا>: 5}`
- C: `وعدہ {<حل کر لیا>: 5}`
- D: `Error`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: C

ہم ایک وعدہ یا ایک غیر وعدہ تو ہم Promise.resolve` `کرنا چاہتے قدر کی کسی بھی قسم کو منتقل کر سکتے ہیں. طریقہ کار خود حل کر لیا قیمت کے ساتھ ایک وعدہ واپس. آپ ایک باقاعدہ تقریب منتقل، تو یہ ایک باقاعدہ قیمت کے ساتھ ایک حل کر وعدہ ہو جائے گا. آپ کو ایک وعدہ ہے تو یہ کہ منظور وعدے کا حل کیا قیمت کے ساتھ ایک حل کر وعدہ ہو جائے گا.

اس صورت میں، ہم صرف عددی قدر `5` منظور. اس قدر `5` ساتھ ایک حل کر وعدہ واپس.

</ P>
</ تفصیلات>

---

###### 105. اس کی قیمت کیا ہے؟

`` `جاوا سکرپٹ
تقریب compareMembers (PERSON1، PERSON2 = شخص) {
 اگر (PERSON1! == PERSON2) {
 console.log کے ( "نہیں ایک ہی!")
 } ورنہ {
 console.log کے ( "وہ ایک ہی ہیں!")
 }
}

CONST شخص = {نام: "لڈا"}

compareMembers (شخص)
`` `

- A: `ایک ہی نہیں ہے`!
- B: `وہ ایک ہی ہیں`!
- C: `ReferenceError`
- D: `SyntaxError`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: بی

آبجیکٹ ریفرنس کی طرف سے منظور کیا جاتا ہے. ہم سخت مساوات کے لئے اشیاء کی جانچ پڑتال جب ( `===`)، ہم ان کے حوالہ جات کا موازنہ کر رہے.

`` person` اعتراض کے برابر person2` لئے ہم پہلے سے طے شدہ قیمت مقرر، اور `person1` لئے قیمت کے طور پر` person` اعتراض منظور.

یہ دونوں اقدار، میموری میں اسی جگہ پر ایک حوالہ ہے اس طرح وہ برابر ہیں کا مطلب ہے کہ.

`else` بیان میں کوڈ بلاک چلایا جاتا ہے، اور` وہ ایک ہی ہیں! `ریکارڈ ہو جاتا ہے. 

</ P>
</ تفصیلات>

---

###### 106. اس کی قیمت کیا ہے؟

`` `جاوا سکرپٹ
CONST colorConfig = {
 ریڈ: یہ سچ ہے،
 نیلے: جھوٹے،
 سبز: یہ سچ ہے،
 سیاہ: یہ سچ ہے،
 پیلے رنگ: جھوٹے،
}

CONST رنگ = [ "گلابی"، "سرخ"، "نیلے"]

console.log کے (colorConfig.colors [1])
`` `

- A: `TRUE`
- B: `FALSE`
- C: `undefined`
- D: `TypeError`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

#### جواب: D

بریکٹ سنکیتن، یا ڈاٹ سنکیتن: جاوا اسکرپٹ میں، ہم کسی چیز پر خواص تک رسائی حاصل کرنے کے دو طریقے ہیں. اس مثال میں، ہم ڈاٹ سنکیتن ( `colorConfig.colors`) کی بجائے بریکٹ سنکیتن (` colorConfig [ "رنگ"] `) استعمال کرتے ہیں.

ڈاٹ سنکیتن کے ساتھ، جاوا کہ عین مطابق نام کے ساتھ اعتراض پر جائیداد کو تلاش کرنے کی کوشش کرتا ہے. اس مثال میں، جاوا `` colorConfig` اعتراض پر colors` نامی ایک جائیداد کو تلاش کرنے کی کوشش کرتا ہے. `colorConfig` نامی کوئی proprety نہیں ہے، تو یہ` undefined` واپس. اس کے بعد، ہم استعمال کر کے پہلے عنصر کی قدر تک رسائی حاصل کرنے کی کوشش کریں `[1]`. undefined` کے `جائیداد نہیں پڑھ سکتا '1': ہم` undefined` ہے کہ ایک قیمت پر ایسا نہیں کر سکتے ہیں، تو یہ ایک `TypeError` ڈالی ہے.

جاوا ترجمانی کرتا ہے (یا unboxes) کے بیانات. ہم بریکٹ سنکیتن کا استعمال کرتے ہیں تو، یہ سب سے پہلے افتتاحی بریکٹ `دیکھتا [` اور یہ اختتامی بریکٹ `پائے تک جا رکھتا]`. صرف اس صورت میں، یہ بیان اندازہ ہو گی. ہم `colorConfig استعمال کیا ہے چاہتے ہیں تو [رنگ [1]]`، یہ `red` جائیداد کی قدر` colorConfig` شئی پر واپس آ جاتا.

</ P>
</ تفصیلات>

---

###### 107. اس کی قیمت کیا ہے؟

`` `جاوا سکرپٹ
console.log کے ( '❤️' === '❤️')
`` `

- A: `TRUE`
- B: `FALSE`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: ایک

ہڈ کے تحت، emojis unicodes ہیں. دل emoji کے لئے unicodes `" U + 2764 U + FE0F "` ہے. یہ ہمیشہ ایک ہی emojis کے لئے ایک ہی ہیں، اس لیے ہم صحیح واپس جو ایک دوسرے کے لئے دو برابر ڈور کا موازنہ کر رہے.

</ P>
</ تفصیلات>

---

###### 108. اصل صف میں ترمیم ان طریقوں میں سے کون؟

`` `جاوا سکرپٹ
CONST = emojis [ '✨'، '🥑'، '😍']

emojis.map (X => X + '✨')
emojis.filter (X => X! == '🥑')
emojis.find (X => X! == '🥑')
emojis.reduce ((اے سی سی، رائج) => ایسیسی + '✨')
emojis.slice (1، 2، '✨') 
emojis.splice (1، 2، '✨')
`` `

- A: `them` کی تمام
- B: `map`` reduce` `slice`` splice`
- C: `map`` slice` `splice` 
- D: `splice`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

#### جواب: D

`splice` طریقہ کار کے ساتھ، ہم کو خارج کرنے کی جگہ یا عناصر شامل کرکے اصل صف پر نظر ثانی. اس صورت میں، ہم انڈیکس 1 (ہم ہٹا دیا ` '🥑'` اور`' 😍'`) سے 2 اشیاء کو ہٹا دیا اور اس کی بجائے ✨ emoji کے شامل کیا.

`map`،` filter` اور `ایک نئی صف` find` ایک عنصر واپس لوٹ آئے slice`، اور `reduce` ایک کم قیمت کے واپس.

</ P>
</ تفصیلات>

---

###### <a name=20191009> لئے 109. آؤٹ پٹ کیا ہے؟

`` `جاوا سکرپٹ
CONST خوراک = [ '🍕'، '🍫'، '🥑'، '🍔']
CONST معلومات = {favoriteFood: کھانا [0]}

info.favoriteFood = '🍝'

console.log کے (کھانے کے)
`` `

- A: `[ '🍕'، '🍫'، '🥑'، '🍔']`
- B: `[ '🍝'، '🍫'، '🥑'، '🍔']`
- C: `[ '🍝'، '🍕'، '🍫'، '🥑'، '🍔']` 
- D: `ReferenceError`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: ایک

ہم `پیزا کا emoji،` '🍕'` ساتھ سٹرنگ کے برابر اعتراض info` پر `favoriteFood` جائیداد کی قیمت مقرر کرتے ہیں. ایک سٹرنگ کے ایک آدم ڈیٹا کی قسم ہے. جاوا میں، آدم ڈیٹا کی اقسام ریفرنس کی طرف سے کام

جاوا میں، آدم ڈیٹا کی اقسام (کسی چیز میں نہیں ہے کہ سب کچھ) _value_ طرف تعامل کرتے ہیں. اس صورت میں، ہم پر `favoriteFood` جائیداد کی قیمت مقرر` `food` صف میں، اس صورت میں پیزا emoji کے (` کے ساتھ سٹرنگ 'پہلا عنصر کی قدر کے برابر اعتراض info` 🍕'` ). ایک سٹرنگ کے ایک آدم ڈیٹا کی قسم ہے، اور (قدر کی طرف سے تعامل میری [blogpost کے] دیکھیں (https://www.theavocoder.com/complete-javascript/2018/12/21/by-value-vs-by-reference) تو آپ سیکھنے میں دلچسپی رکھتے ہیں اس سے زیادہ)

اس کے بعد، ہم `info` اعتراض پر` favoriteFood` جائیداد کی قیمت میں تبدیلی. favoriteFood` `کی قدر محض صف میں پہلا عنصر کی قدر کی ایک _copy_ تھا کے بعد` food` صف، تبدیل نہیں کیا گیا ہے، اور `پر عنصر کے طور پر یاد میں ایک ہی جگہ پر ایک حوالہ نہیں ہے کھانے [0] `. ہم کھانے کو لاگ جب، یہ اب بھی اصل صف ہے، `[ '🍕'، '🍫'، '🥑'، '🍔']`.

</ P>
</ تفصیلات>

---

###### 110. اس طریقہ کار کیا کرتا ہے؟

`` `جاوا سکرپٹ
JSON.parse ()
`` `

- A: ایک جاوا اسکرپٹ ویلیو پر JSON parses ہے
- B: JSON کرنے کے لئے ایک جاوا اسکرپٹ اعتراض parses ہے
- C: JSON کے لئے کسی بھی جاوا قدر parses ہے
- D: ایک جاوا اسکرپٹ اعتراض کرنے JSON parses ہے صرف

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: ایک

`JSON.parse ()` طریقہ کار کے ساتھ، ہم نے ایک جاوا قدر میں JSON سٹرنگ کا تجزیہ کر سکتے ہیں. 

`` `جاوا سکرپٹ
// درست JSON میں ایک بڑی تعداد Stringifying، پھر ایک جاوا قدر میں JSON سٹرنگ کی تصریف:
CONST jsonNumber = JSON.stringify (4) // '4'
JSON.parse (jsonNumber) // 4

// درست JSON میں ایک صف قدر Stringifying، پھر ایک جاوا قدر میں JSON سٹرنگ کی تصریف:
CONST jsonArray = JSON.stringify ([1، 2، 3]) // '[1، 2، 3]'
JSON.parse (jsonArray) // [1، 2، 3]

// درست JSON میں کسی چیز Stringifying، پھر ایک جاوا قدر میں JSON سٹرنگ کی تصریف:
CONST jsonArray = JSON.stringify ({نام: "لڈا"}) // '{ "کا نام": "لڈا"}'
JSON.parse (jsonArray) // {نام: لڈا '}
`` `

</ P>
</ تفصیلات>

---

###### 111. پیداوار کیا ہے؟ 

`` `جاوا سکرپٹ
دو نام = 'لدیہ'

تقریب getName () {
 console.log کے (نام)
 دو نام = 'سارہ نے'
}

getName ()
`` `

- A: لڈا
- B: سارہ
- C: `undefined`
- D: `ReferenceError`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

#### جواب: D

ہر تقریب کا اپنا _execution context_ (یا _scope_) ہے. `getName` تقریب سے پہلے یہ متغیر` name` ہم تک رسائی حاصل کرنے کی کوشش کر رہے ہیں پر مشتمل ہے تو دیکھنے کے لئے اس کے اپنے سیاق و سباق (گنجائش) کے اندر اندر لگ رہا ہے. اس صورت میں، `getName` تقریب کا اپنا` name` متغیر پر مشتمل ہے: ہم `let` مطلوبہ الفاظ کے ساتھ متغیر` name` اعلان، اور `کی 'Sarah'` قیمت کے ساتھ.

`let` مطلوبہ الفاظ کی (اور` const`) کے ساتھ متغیر کشائی کی ہیں، لیکن var` `برعکس ملے <i> کے initialized نہیں کرتے </ i> کے. وہ قابل رسائی نہیں ہیں اس سے پہلے کی لکیر ہم اعلان (ابتدا) ان. یہ "دنیاوی مردہ زون" کہا جاتا ہے. ہم وہ اعلان کر رہے ہیں اس سے پہلے متغیر تک رسائی حاصل کرنے کی کوشش کرتے ہیں، جاوا سکرپٹ کو ایک `ReferenceError` ڈالی ہے.

ہم `getName` تقریب کے اندر` name` متغیر کا اعلان کر دیا ہے نہیں کرے گا تو، جاوا سکرپٹ کے انجن _scope chain_ نیچے دیکھا جاتا. بیرونی گنجائش `Lydia`` کی قدر کے ساتھ name` نامی ایک متغیر ہے. اس صورت میں، یہ ریکارڈ ہے گی `Lydia`.

`` `جاوا سکرپٹ
دو نام = 'لدیہ'

تقریب getName () {
 console.log کے (نام)
}

getName () // لڈا
`` `

</ P>
</ تفصیلات>

---

###### 112. پیداوار کیا ہے؟

`` `جاوا سکرپٹ
تقریب * generatorOne () {
 برآمد [ 'ایک'، 'بی'، 'سی']؛
}

تقریب * generatorTwo () {
 پیداوار * [ 'ایک'، 'بی'، 'سی']؛
}

CONST سے ایک = generatorOne ()
CONST دو = generatorTwo ()

console.log کے (one.next (). قیمت)
console.log کے (two.next (). قیمت)
`` `

- A: `A` اور` A`
- B: `A` اور` undefined`
- C: `[ 'ایک'، 'بی'، 'سی']` اور `A`
- D: `A` اور` [ 'ایک'، 'بی'، 'سی'] `

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: C

`yield` مطلوبہ الفاظ کے ساتھ، ہم` ایک جنریٹر تقریب میں اقدار yield`. `پیداوار *` مطلوبہ الفاظ کے ساتھ، ہم ایک اور جنریٹر تقریب، یا iterable اعتراض ہے (مثلا ایک صف) سے اقدار حاصل کر سکتے ہیں.

generatorOne` `میں، ہم پوری صف` [ 'ایک'، 'بی'، 'سی'] `` yield` مطلوبہ لفظ استعمال کر سامنے آرہے ہیں. اعتراض پر قدر` جائیداد `کی قدر (` one.next (). قدر`) `one` پر` next` طریقہ کی طرف لوٹائے پوری صف `[ 'ایک'، 'بی'، 'سی کے برابر ہے '] `.

`` `جاوا سکرپٹ
console.log کے (one.next (). قدر) // [ 'ایک'، 'بی'، 'سی']
console.log کے (one.next (). قدر) // غیروضاحتی
`` `

generatorTwo` `میں، ہم` پیداوار * `مطلوبہ لفظ استعمال کرتے ہیں. اس کا مطلب یہ two` `کے پہلے نکلا قدر تکرار کنندہ میں پہلی نکلا قیمت کے برابر ہے. تکرار کنندہ صف `[ 'ایک'، 'بی'، 'سی']` ہے. سب سے پہلے نکلا قدر ہے `A`، تو ہم` two.next (). قدر`، کال پہلی بار `A` واپس آ جاتا ہے.

`` `جاوا سکرپٹ
console.log کے (two.next (). قدر) // 'A'
console.log کے (two.next (). قدر) // 'B'
console.log کے (two.next (). قدر) // 'سی'
console.log کے (two.next (). قدر) // غیروضاحتی
`` `

</ P>
</ تفصیلات>

---

###### 113. پیداوار کیا ہے؟

`` `جاوا سکرپٹ
console.log کے ( `$ {(X => X) ( 'میں نے پیار')} program` کرنے کے لئے)
`` `

- A: `میں program` لئے محبت کرتا ہوں
- B: `program` کو جانچ
- C: `$ {(X => X) ( 'میں نے پیار') program` کو
- D: `TypeError`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: ایک

سانچے لاٹرالس اندر اظہار سب سے پہلے تعین کیا جاتا ہے. اس کا مطلب ہے کہ سٹرنگ اظہار کی واپس آ قیمت، فوری طور پر لاگو تقریب `مشتمل ہوگا (X => X) ( 'میں نے پیار')` اس معاملے میں. ہم قدر ` 'مجھے` X => x` تیر تقریب کے لئے ایک دلیل کے طور پر love'` گزر. `x`` 'میں واپس آ جاتا ہے، جس love'` کے برابر ہے. یہ `میں مجھے program` لئے محبت کرتا ہوں اس کے نتائج.

</ P>
</ تفصیلات>

---

###### 114. کیا ہوگا؟

`` `جاوا سکرپٹ
دو تشکیل = {
 الرٹ: setInterval (() => {
 console.log کے ( 'انتباہ!')
 }، 1000)
}

تشکیل نل =
`` `

- A: `setInterval` کال بیک ومباحثہ نہیں کیا جائے گا
- B: `setInterval` کال بیک ایک بار لاگو کیا جاتا ہے
- C: `setInterval` کال بیک اب بھی ہر دوسرے پکارا جائے گا
- D: ہم ومباحثہ کبھی نہیں `config.alert ()` تشکیل ہے `null`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: C

عام طور پر ہم null` `برابر اشیاء مقرر کرتے وقت، کوئی ریفرنس ہے کہ اعتراض کرنے اب نہیں ہے کے طور پر ان اشیاء _garbage collected_ ملتا ہے. تاہم، `setInterval` اندر اندر کال بیک تقریب کو ایک تیر تقریب (یوں` config` اعتراض کرنے کی پابند) کے ہے، کال بیک تقریب کو اب بھی `config` اعتراض کے لئے ایک ریفرنس کا انعقاد. جب تک ایک حوالہ ہے کے طور پر، اعتراض ردی کی ٹوکری میں جمع کیا نہیں ہو گی. یہ ردی کی ٹوکری میں جمع نہیں ہے کے بعد سے، `setInterval` کال بیک تقریب کو اب بھی ہر 1000ms (1S) لاگو ہو جائے گا.

</ P>
</ تفصیلات>

---

###### 115. کون سا طریقہ (ے) قیمت واپس کرے گا ` 'ہیلو دنیا!' '؟

`` `جاوا سکرپٹ
CONST myMap = نیا نقشہ ()
CONST myFunc = () => 'سلام'

myMap.set (myFunc، 'ہیلو دنیا!')

// 1
myMap.get ( 'سلام')
// 2
myMap.get (myFunc)
// 3
myMap.get (() => 'سلام')
`` `

- A: 1
- B: 2
- C: 2 اور 3
- D: ان میں سے سب

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: بی

`set` طریقہ استعمال کرتے ہوئے ایک اہم / قدر جوڑی کا اضافہ کرتے ہیں، اہم` set` تقریب میں منظور پہلی دلیل کی قدر ہو جائے گا، اور قدر `set` تقریب میں منظور دوسری دلیل ہو جائے گا. کلید _function_ `() => 'اس کیس میں greeting'`، اور قدر`' ہیلو world'` ہے. `اب myMap` ہے` {() => 'سلام' => 'ہیلو دنیا!' } `.

کلید ` 'greeting'` لیکن` () =>' greeting'` نہیں ہے کے بعد 1، غلط ہے.
ہم `get` طریقہ کار کے لئے ایک پیرامیٹر کے طور پر گزر کی طرف سے ایک نیا فعل پیدا کر رہے ہیں کے بعد سے 3، غلط ہے. آبجیکٹ _reference_ طرف تعامل کرتے ہیں. افعال، اشیاء ہیں جس میں دو افعال کو کبھی نہیں سختی برابر ہیں یہی وجہ ہے کہ وہ ایک جیسی ہیں یہاں تک کہ اگر: وہ یاد میں ایک مختلف جگہ پر ایک حوالہ ہے.

</ P>
</ تفصیلات>

---

###### 116. پیداوار کیا ہے؟

`` `جاوا سکرپٹ
CONST شخص = {
 نام: "لڈا"،
 عمر: 21
}

CONST changeAge = (X = {... شخص}) => x.age + = 1
CONST changeAgeAndName = (X = {... شخص}) => {
 x.age + = 1
 x.name = "سارہ"
}

changeAge (شخص)
changeAgeAndName ()

console.log کے (شخص)
`` `

- A: `{نام:" سارہ "، عمر: 22}`
- B: `{نام:" سارہ "، عمر: 23}`
- C: `{نام:" لڈا "، عمر: 22}`
- D: `{نام:" لڈا "، عمر: 23}`

<تفصیلات> <سمری> <b> کے جواب میں </ b> </ سمری>
<P>

جواب ####: C

دونوں `changeAge` اور` changeAgeAndName` افعال ڈیفالٹ پیرامیٹر، یعنی ایک _newly_ پیدا اعتراض `{... شخص}` ہے. یہ اعتراض `person` اعتراض میں تمام اہم / اقدار کی کاپیاں ہیں.

سب سے پہلے، ہم `changeAge` تقریب پکارتے اور اس کی دلیل کے طور پر` person` اعتراض گزر. `یہ فنکشن اب` {: "لڈا"، عمر 22 نام} ہے 1. `person` طرف` age` جائیداد کی قدر بڑھاتا ہے.

اس کے بعد، ہم `changeAgeAndName` تقریب پکارتے، تاہم ہم ایک پیرامیٹر کے پاس نہیں ہے. اس کے بجائے، x` `کی قدر ایک _new_ اعتراض کے برابر ہے:` {... شخص} `. یہ ایک نئی چیز ہے کے بعد سے، یہ `person` اعتراض پر خصوصیات کی اقدار کو متاثر نہیں کرتا. `` person` اب بھی `کرنے {:" لڈا "، عمر 22 نام} کے برابر ہے.

</ P>
</ تفصیلات>