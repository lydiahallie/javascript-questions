<div align="center">
  <img height="60" src="https://img.icons8.com/color/344/javascript.png">
  <h1>Pytania dotyczÄ…ce JavaScript</h1>

---

<span>PublikujÄ™ pytania wielokrotnego wyboru dotyczÄ…ce JavaScriptu na swoich [Instagram](https://www.instagram.com/theavocoder) **stories**, ktÃ³re rÃ³wnieÅ¼ zamieszczÄ™ tutaj! Ostatnia aktualizacja:<a href=#20200612><b>12 Czerwca</b></a>

Od podstawowych do zaawansowanych: sprawdÅº, jak dobrze znasz JavaScript, odÅ›wieÅ¼ swojÄ… wiedzÄ™ lub przygotuj siÄ™ do rozmowy kwalifikacyjnej! :muscle: :rocket: Regularnie aktualizujÄ™ to repozytorium nowymi pytaniami. Odpowiedzi znajdujÄ… siÄ™ w ukrytych zakÅ‚adkach poniÅ¼ej pytaÅ„ - po prostu kliknij, aby je rozwiniÄ™Ä‡. To dla zabawy, powodzenia! :heart:</span>

Nie krÄ™puj siÄ™ ze mnÄ… kontaktowaÄ‡! ğŸ˜Š <br />
<a href="https://www.instagram.com/theavocoder">Instagram</a> || <a href="https://www.twitter.com/lydiahallie">Twitter</a> || <a href="https://www.linkedin.com/in/lydia-hallie">LinkedIn</a> || <a href="https://www.lydiahallie.dev">Blog</a>
</div>

| ÅšmiaÅ‚o uÅ¼ywaj ich w projekcie! ğŸ˜ƒ  ByÅ‚abym _bardzo_ wdziÄ™czna za referencje do tego repozytorium, tworzÄ™ pytania i wyjaÅ›nienia (tak, jestem smutna lol) i spoÅ‚ecznoÅ›Ä‡ bardzo mi pomaga w utrzymaniu i ulepszaniu go! ğŸ’ªğŸ¼ DziÄ™kujÄ™ i baw siÄ™ dobrze!   |
|---|

---

<details><summary><b> Zobacz 19 dostÄ™pnych tÅ‚umaczeÅ„ ğŸ‡¸ğŸ‡¦ğŸ‡ªğŸ‡¬ğŸ‡§ğŸ‡¦ğŸ‡©ğŸ‡ªğŸ‡ªğŸ‡¸ğŸ‡«ğŸ‡·ğŸ‡®ğŸ‡©ğŸ‡¯ğŸ‡µğŸ‡°ğŸ‡·ğŸ‡³ğŸ‡±ğŸ‡§ğŸ‡·ğŸ‡·ğŸ‡ºğŸ‡¹ğŸ‡­ğŸ‡¹ğŸ‡·ğŸ‡ºğŸ‡¦ğŸ‡»ğŸ‡³ğŸ‡¨ğŸ‡³ğŸ‡¹ğŸ‡¼</b></summary>
<p>

- [ğŸ‡¸ğŸ‡¦ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©](./ar-AR/README_AR.md)
- [ğŸ‡ªğŸ‡¬ Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø§Ù…ÙŠØ©](./ar-EG/README_ar-EG.md)
- [ğŸ‡§ğŸ‡¦ Bosanski](./bs-BS/README-bs_BS.md)
- [ğŸ‡©ğŸ‡ª Deutsch](./de-DE/README.md)
- [ğŸ‡ªğŸ‡¸ EspaÃ±ol](./es-ES/README-ES.md)
- [ğŸ‡«ğŸ‡· FranÃ§ais](./fr-FR/README_fr-FR.md)
- [ğŸ‡®ğŸ‡© Indonesia](./id-ID/README.md)
- [ğŸ‡®ğŸ‡¹ Italiano](./it-IT/README.md)
- [ğŸ‡¯ğŸ‡µ æ—¥æœ¬èª](./ja-JA/README-ja_JA.md)
- [ğŸ‡°ğŸ‡· í•œêµ­ì–´](./ko-KR/README-ko_KR.md)
- [ğŸ‡³ğŸ‡± Nederlands](./nl-NL/README.md)
- [ğŸ‡§ğŸ‡· PortuguÃªs Brasil](./pt-BR/README_pt_BR.md)
- [ğŸ‡·ğŸ‡º Ğ ÑƒÑÑĞºĞ¸Ğ¹](./ru-RU/README.md)
- [ğŸ‡¹ğŸ‡­ à¹„à¸—à¸¢](./th-TH/README-th_TH.md)
- [ğŸ‡¹ğŸ‡· TÃ¼rkÃ§e](./tr-TR/README-tr_TR.md)
- [ğŸ‡ºğŸ‡¦ Ğ£ĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°](./uk-UA/README.md)
- [ğŸ‡»ğŸ‡³ Tiáº¿ng Viá»‡t](./vi-VI/README-vi.md)
- [ğŸ‡¨ğŸ‡³ ç®€ä½“ä¸­æ–‡](./zh-CN/README-zh_CN.md)
- [ğŸ‡¹ğŸ‡¼ ç¹é«”ä¸­æ–‡](./zh-TW/README_zh-TW.md)

</p>
</details>

---

###### 1. Jaki jest wynik?

```javascript
function sayHi() {
  console.log(name);
  console.log(age);
  var name = 'Lydia';
  let age = 21;
}

sayHi();
```

- A: `Lydia` and `undefined`
- B: `Lydia` and `ReferenceError`
- C: `ReferenceError` and `21`
- D: `undefined` and `ReferenceError`

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: D

WewnÄ…trz funkcji najpierw deklarujemy zmiennÄ… `name` za pomocÄ… sÅ‚owa kluczowego `var`. Oznacza to, Å¼e zmienna jest "wyciÄ…gana" (przestrzeÅ„ pamiÄ™ci jest tworzona) z domyÅ›lnÄ… wartoÅ›ciÄ… `undefined` podczas fazy tworzenia, aÅ¼ do momentu, gdy naprawdÄ™ definiujemy zmiennÄ…. W linii, w ktÃ³rej prÃ³bujemy wyÅ›wietliÄ‡ w konsoli zmiennÄ… `name`, jeszcze jej nie zdefiniowaliÅ›my, wiÄ™c nadal przechowuje wartoÅ›Ä‡ `undefined`.

Zmienne zadeklarowane za pomocÄ… sÅ‚owa kluczowego `let` (i `const`) sÄ… wyciÄ…gane, ale w przeciwieÅ„stwie do `var`, nie sÄ… <i>inicjalizowane</i>. Nie sÄ… dostÄ™pne przed liniÄ…, na ktÃ³rej je deklarujemy (inicjalizujemy). Nazywa siÄ™ to "czasowÄ… strefÄ… martwÄ…" (temporal dead zone). Gdy prÃ³bujemy uzyskaÄ‡ dostÄ™p do zmiennych przed ich zadeklarowaniem, JavaScript generuje bÅ‚Ä…d `ReferenceError`.

</p>
</details>

---

###### 2. Jaki jest wynik?

```javascript
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 1);
}

for (let i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 1);
}
```

- A: `0 1 2` and `0 1 2`
- B: `0 1 2` and `3 3 3`
- C: `3 3 3` and `0 1 2`

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: C

Ze wzglÄ™du na kolejkÄ™ zdarzeÅ„ w JavaScript, funkcja zwrotna `setTimeout` jest wywoÅ‚ywana _po_ wykonaniu pÄ™tli. PoniewaÅ¼ zmienna `i` w pierwszej pÄ™tli zostaÅ‚a zadeklarowana za pomocÄ… sÅ‚owa kluczowego `var`, jej wartoÅ›Ä‡ byÅ‚a globalna. Podczas pÄ™tli inkrementowaliÅ›my wartoÅ›Ä‡ `i` o `1` za kaÅ¼dym razem, uÅ¼ywajÄ…c operatora jednoargumentowego `++`. W momencie wywoÅ‚ania funkcji zwrotnej `setTimeout`, `i` miaÅ‚o wartoÅ›Ä‡ `3` w pierwszym przykÅ‚adzie.

W drugiej pÄ™tli zmienna `i` zostaÅ‚a zadeklarowana za pomocÄ… sÅ‚owa kluczowego `let`: zmienne zadeklarowane za pomocÄ… sÅ‚owa kluczowego `let` (i `const`) majÄ… zakres blokowy (blokiem jest cokolwiek miÄ™dzy `{ }`). Podczas kaÅ¼dej iteracji `i` bÄ™dzie miaÅ‚o nowÄ… wartoÅ›Ä‡, a kaÅ¼da wartoÅ›Ä‡ bÄ™dzie miaÅ‚a zakres wewnÄ…trz pÄ™tli.

</p>
</details>

---

###### 3. Jaki jest wynik?

```javascript
const shape = {
  radius: 10,
  diameter() {
    return this.radius * 2;
  },
  perimeter: () => 2 * Math.PI * this.radius,
};

console.log(shape.diameter());
console.log(shape.perimeter());
```

- A: `20` and `62.83185307179586`
- B: `20` and `NaN`
- C: `20` and `63`
- D: `NaN` and `63`

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: B

ZwrÃ³Ä‡ uwagÄ™, Å¼e wartoÅ›Ä‡ `diameter` jest zwykÅ‚Ä… funkcjÄ…, podczas gdy wartoÅ›Ä‡ `perimeter` jest funkcjÄ… strzaÅ‚kowÄ….

W przypadku funkcji strzaÅ‚kowych, sÅ‚owo kluczowe `this` odnosi siÄ™ do bieÅ¼Ä…cego otaczajÄ…cego zakresu, w przeciwieÅ„stwie do zwykÅ‚ych funkcji! Oznacza to, Å¼e gdy wywoÅ‚ujemy `perimeter`, nie odnosi siÄ™ ono do obiektu shape, ale do swojego otaczajÄ…cego zakresu (np. okna).

Na tym obiekcie nie ma wartoÅ›ci `radius`, co powoduje zwrÃ³cenie `NaN` (Not a Number).

</p>
</details>

---

###### 4. Jaki jest wynik?

```javascript
+true;
!'Lydia';
```

- A: `1` and `false`
- B: `false` and `NaN`
- C: `false` and `false`

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: A

Operator jednoargumentowy plus prÃ³buje przekonwertowaÄ‡ operand na liczbÄ™. `true` jest rÃ³wnowaÅ¼ne `1`, a `false` jest rÃ³wnowaÅ¼ne `0`.

ÅaÅ„cuch znakÃ³w `'Lydia'` jest wartoÅ›ciÄ… prawdziwÄ…. Tak naprawdÄ™ pytamy, "czy ta wartoÅ›Ä‡ prawdziwa jest faÅ‚szywa?". To zwraca `false`.

</p>
</details>

---

###### 5. KtÃ³re jest prawdziwe?

```javascript
const bird = {
  size: 'small',
};

const mouse = {
  name: 'Mickey',
  small: true,
};
```

- A: `mouse.bird.size` is not valid
- B: `mouse[bird.size]` is not valid
- C: `mouse[bird["size"]]` is not valid
- D: All of them are valid

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: A

W JavaScript wszystkie klucze obiektÃ³w sÄ… stringami (chyba Å¼e sÄ… to symbole). Nawet jeÅ›li nie wpisujemy ich jako stringi, zawsze sÄ… one konwertowane na stringi wewnÄ…trz.

JavaScript interpretuje (lub "odpakuowuje") instrukcje. Gdy uÅ¼ywamy notacji nawiasÃ³w kwadratowych, interpreter widzi pierwszy otwierajÄ…cy nawias `[` i kontynuuje do momentu znalezienia zamykajÄ…cego nawiasu `]`. Dopiero wtedy ocenia tÄ™ instrukcjÄ™.

`mouse[bird.size]`: Najpierw ocenia `bird.size`, ktÃ³re wynosi `"small"`. `mouse["small"]` zwraca `true`.

JednakÅ¼e, w przypadku notacji kropkowej, to siÄ™ nie dzieje. `mouse` nie ma klucza o nazwie `bird`, co oznacza, Å¼e `mouse.bird` jest `undefined`. NastÄ™pnie pytamy o `size` uÅ¼ywajÄ…c notacji kropkowej: `mouse.bird.size`. PoniewaÅ¼ `mouse.bird` jest `undefined`, tak naprawdÄ™ pytamy o `undefined.size`. To nie jest poprawne i spowoduje bÅ‚Ä…d podobny do `Cannot read property "size" of undefined` (Nie moÅ¼na odczytaÄ‡ wÅ‚aÅ›ciwoÅ›ci "size" z undefined).

</p>
</details>

---

###### 6. Jaki jest wynik?

```javascript
let c = { greeting: 'Hey!' };
let d;

d = c;
c.greeting = 'Hello';
console.log(d.greeting);
```

- A: `Hello`
- B: `Hey!`
- C: `undefined`
- D: `ReferenceError`
- E: `TypeError`

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: A

W JavaScript wszystkie obiekty komunikujÄ… siÄ™ ze sobÄ… przez _referencje_, gdy sÄ… sobie przypisywane.

Na poczÄ…tku zmienna `c` przechowuje referencjÄ™ do obiektu. PÃ³Åºniej przypisujemy zmiennej `d` tÄ™ samÄ… referencjÄ™, ktÃ³rÄ… ma `c`, do tego obiektu.

<img src="https://i.imgur.com/ko5k0fs.png" width="200">

Kiedy zmieniasz jeden obiekt, zmieniasz je wszystkie.

</p>
</details>

---

###### 7. Jaki jest wynik?

```javascript
let a = 3;
let b = new Number(3);
let c = 3;

console.log(a == b);
console.log(a === b);
console.log(b === c);
```

- A: `true` `false` `true`
- B: `false` `false` `true`
- C: `true` `false` `false`
- D: `false` `true` `true`

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: C

`new Number()` jest wbudowanym konstruktorem funkcji. ChociaÅ¼ wyglÄ…da jak liczba, nie jest faktycznie liczbÄ…: ma wiele dodatkowych funkcji i jest obiektem.

Gdy uÅ¼ywamy operatora `==` (operator rÃ³wnoÅ›ci), sprawdza on jedynie, czy majÄ… tÄ… samÄ… _wartoÅ›Ä‡_. Oba majÄ… wartoÅ›Ä‡ `3`, wiÄ™c zwraca `true`.

Jednak gdy uÅ¼ywamy operatora `===` (operator Å›cisÅ‚ej rÃ³wnoÅ›ci), zarÃ³wno wartoÅ›Ä‡, jak i typ powinny byÄ‡ takie same. Tutaj nie sÄ…: `new Number()` nie jest liczbÄ…, lecz **obiektem**. Oba zwracajÄ… `false`.

</p>
</details>

---

###### 8. Jaki jest wynik?

```javascript
class Chameleon {
  static colorChange(newColor) {
    this.newColor = newColor;
    return this.newColor;
  }

  constructor({ newColor = 'green' } = {}) {
    this.newColor = newColor;
  }
}

const freddie = new Chameleon({ newColor: 'purple' });
console.log(freddie.colorChange('orange'));
```

- A: `orange`
- B: `purple`
- C: `green`
- D: `TypeError`

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: D

Funkcja `colorChange` jest statyczna. Metody statyczne sÄ… zaprojektowane tak, aby istniaÅ‚y tylko w konstruktorze, w ktÃ³rym zostaÅ‚y utworzone, i nie mogÄ… byÄ‡ przekazywane do Å¼adnych potomkÃ³w (children) ani wywoÅ‚ywane na instancjach klasy. PoniewaÅ¼ `freddie` jest instancjÄ… klasy Chameleon, funkcja nie moÅ¼e byÄ‡ na niej wywoÅ‚ana. Otrzymujemy bÅ‚Ä…d `TypeError`.

</p>
</details>

---

###### 9. Jaki jest wynik?

```javascript
let greeting;
greetign = {}; // Celowa LiterÃ³wka!
console.log(greetign);
```

- A: `{}`
- B: `ReferenceError: greetign is not defined`
- C: `undefined`

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: A

Kod wypisuje w konsoli obiekt, poniewaÅ¼ wÅ‚aÅ›nie utworzyliÅ›my pusty obiekt w obiekcie globalnym! Gdy pomyÅ‚kowo wpisaliÅ›my `greeting` jako `greetign`, interpreter JavaScript faktycznie zobaczyÅ‚ to jako:

1. `global.greetign = {}` w Node.js.
2. `window.greetign = {}`, `frames.greetign = {}` i `self.greetign` w przeglÄ…darkach.
3. `self.greetign` w web workerach.
4. `globalThis.greetign` we wszystkich Å›rodowiskach.

Aby temu zapobiec, moÅ¼emy uÅ¼yÄ‡ `"use strict"`. Powoduje to, Å¼e musisz zadeklarowaÄ‡ zmiennÄ… przed jej przypisaniem.

</p>
</details>

---

###### 10. Co siÄ™ dzieje, gdy to zrobimy?

```javascript
function bark() {
  console.log('Woof!');
}

bark.animal = 'dog';
```

- A: Nothing, this is totally fine!
- B: `SyntaxError`. You cannot add properties to a function this way.
- C: `"Woof"` gets logged.
- D: `ReferenceError`

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: A

Jest to moÅ¼liwe w JavaScript, poniewaÅ¼ funkcje sÄ… obiektami! (Wszystko oprÃ³cz typÃ³w prymitywnych jest obiektem)

Funkcja jest specjalnym rodzajem obiektu. Kod, ktÃ³ry sam piszesz, nie jest wÅ‚aÅ›ciwÄ… funkcjÄ…. Funkcja jest obiektem posiadajÄ…cym wÅ‚aÅ›ciwoÅ›Ä‡, ktÃ³ra jest wywoÅ‚ywalna.

</p>
</details>
