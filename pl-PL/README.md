<div align="center">
  <img height="60" src="https://img.icons8.com/color/344/javascript.png">
  <h1>Pytania dotyczÄ…ce JavaScript</h1>

---

<span>PublikujÄ™ pytania wielokrotnego wyboru dotyczÄ…ce JavaScriptu na swoich [Instagram](https://www.instagram.com/theavocoder) **stories**, ktÃ³re rÃ³wnieÅ¼ zamieszczÄ™ tutaj! Ostatnia aktualizacja: <a href=#20200612><b>27 Czerwca</b></a>

Od podstawowych do zaawansowanych: sprawdÅº, jak dobrze znasz JavaScript, odÅ›wieÅ¼ swojÄ… wiedzÄ™ lub przygotuj siÄ™ do rozmowy kwalifikacyjnej! :muscle: :rocket: Regularnie aktualizujÄ™ to repozytorium nowymi pytaniami. Odpowiedzi znajdujÄ… siÄ™ w ukrytych zakÅ‚adkach poniÅ¼ej pytaÅ„ - po prostu kliknij, aby je rozwiniÄ™Ä‡. To dla zabawy, powodzenia! :heart:</span>

Nie krÄ™puj siÄ™ ze mnÄ… kontaktowaÄ‡! ğŸ˜Š <br />
<a href="https://www.instagram.com/theavocoder">Instagram</a> || <a href="https://www.twitter.com/lydiahallie">Twitter</a> || <a href="https://www.linkedin.com/in/lydia-hallie">LinkedIn</a> || <a href="https://www.lydiahallie.dev">Blog</a>
</div>

| ÅšmiaÅ‚o uÅ¼ywaj ich w projekcie! ğŸ˜ƒ  ByÅ‚abym _bardzo_ wdziÄ™czna za referencje do tego repozytorium, tworzÄ™ pytania i wyjaÅ›nienia (tak, jestem smutna lol) i spoÅ‚ecznoÅ›Ä‡ bardzo mi pomaga w utrzymaniu i ulepszaniu go! ğŸ’ªğŸ¼ DziÄ™kujÄ™ i baw siÄ™ dobrze!   |
|---|

---

<details><summary><b> Zobacz 19 dostÄ™pnych tÅ‚umaczeÅ„ ğŸ‡¸ğŸ‡¦ğŸ‡ªğŸ‡¬ğŸ‡§ğŸ‡¦ğŸ‡©ğŸ‡ªğŸ‡ªğŸ‡¸ğŸ‡«ğŸ‡·ğŸ‡®ğŸ‡©ğŸ‡¯ğŸ‡µğŸ‡°ğŸ‡·ğŸ‡³ğŸ‡±ğŸ‡§ğŸ‡·ğŸ‡·ğŸ‡ºğŸ‡¹ğŸ‡­ğŸ‡¹ğŸ‡·ğŸ‡ºğŸ‡¦ğŸ‡»ğŸ‡³ğŸ‡¨ğŸ‡³ğŸ‡¹ğŸ‡¼</b></summary>
<p>

- [ğŸ‡¸ğŸ‡¦ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©](./ar-AR/README_AR.md)
- [ğŸ‡ªğŸ‡¬ Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø§Ù…ÙŠØ©](./ar-EG/README_ar-EG.md)
- [ğŸ‡§ğŸ‡¦ Bosanski](./bs-BS/README-bs_BS.md)
- [ğŸ‡©ğŸ‡ª Deutsch](./de-DE/README.md)
- [ğŸ‡ªğŸ‡¸ EspaÃ±ol](./es-ES/README-ES.md)
- [ğŸ‡«ğŸ‡· FranÃ§ais](./fr-FR/README_fr-FR.md)
- [ğŸ‡®ğŸ‡© Indonesia](./id-ID/README.md)
- [ğŸ‡®ğŸ‡¹ Italiano](./it-IT/README.md)
- [ğŸ‡¯ğŸ‡µ æ—¥æœ¬èª](./ja-JA/README-ja_JA.md)
- [ğŸ‡°ğŸ‡· í•œêµ­ì–´](./ko-KR/README-ko_KR.md)
- [ğŸ‡³ğŸ‡± Nederlands](./nl-NL/README.md)
- [ğŸ‡§ğŸ‡· PortuguÃªs Brasil](./pt-BR/README_pt_BR.md)
- [ğŸ‡·ğŸ‡º Ğ ÑƒÑÑĞºĞ¸Ğ¹](./ru-RU/README.md)
- [ğŸ‡¹ğŸ‡­ à¹„à¸—à¸¢](./th-TH/README-th_TH.md)
- [ğŸ‡¹ğŸ‡· TÃ¼rkÃ§e](./tr-TR/README-tr_TR.md)
- [ğŸ‡ºğŸ‡¦ Ğ£ĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°](./uk-UA/README.md)
- [ğŸ‡»ğŸ‡³ Tiáº¿ng Viá»‡t](./vi-VI/README-vi.md)
- [ğŸ‡¨ğŸ‡³ ç®€ä½“ä¸­æ–‡](./zh-CN/README-zh_CN.md)
- [ğŸ‡¹ğŸ‡¼ ç¹é«”ä¸­æ–‡](./zh-TW/README_zh-TW.md)

</p>
</details>

---

###### 1. Jaki jest wynik?

```javascript
function sayHi() {
  console.log(name);
  console.log(age);
  var name = 'Lydia';
  let age = 21;
}

sayHi();
```

- A: `Lydia` and `undefined`
- B: `Lydia` and `ReferenceError`
- C: `ReferenceError` and `21`
- D: `undefined` and `ReferenceError`

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: D

WewnÄ…trz funkcji najpierw deklarujemy zmiennÄ… `name` za pomocÄ… sÅ‚owa kluczowego `var`. Oznacza to, Å¼e zmienna jest "wyciÄ…gana" (przestrzeÅ„ pamiÄ™ci jest tworzona) z domyÅ›lnÄ… wartoÅ›ciÄ… `undefined` podczas fazy tworzenia, aÅ¼ do momentu, gdy naprawdÄ™ definiujemy zmiennÄ…. W linii, w ktÃ³rej prÃ³bujemy wyÅ›wietliÄ‡ w konsoli zmiennÄ… `name`, jeszcze jej nie zdefiniowaliÅ›my, wiÄ™c nadal przechowuje wartoÅ›Ä‡ `undefined`.

Zmienne zadeklarowane za pomocÄ… sÅ‚owa kluczowego `let` (i `const`) sÄ… wyciÄ…gane, ale w przeciwieÅ„stwie do `var`, nie sÄ… <i>inicjalizowane</i>. Nie sÄ… dostÄ™pne przed liniÄ…, na ktÃ³rej je deklarujemy (inicjalizujemy). Nazywa siÄ™ to "czasowÄ… strefÄ… martwÄ…" (temporal dead zone). Gdy prÃ³bujemy uzyskaÄ‡ dostÄ™p do zmiennych przed ich zadeklarowaniem, JavaScript generuje bÅ‚Ä…d `ReferenceError`.

</p>
</details>

---

###### 2. Jaki jest wynik?

```javascript
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 1);
}

for (let i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 1);
}
```

- A: `0 1 2` and `0 1 2`
- B: `0 1 2` and `3 3 3`
- C: `3 3 3` and `0 1 2`

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: C

Ze wzglÄ™du na kolejkÄ™ zdarzeÅ„ w JavaScript, funkcja zwrotna `setTimeout` jest wywoÅ‚ywana _po_ wykonaniu pÄ™tli. PoniewaÅ¼ zmienna `i` w pierwszej pÄ™tli zostaÅ‚a zadeklarowana za pomocÄ… sÅ‚owa kluczowego `var`, jej wartoÅ›Ä‡ byÅ‚a globalna. Podczas pÄ™tli inkrementowaliÅ›my wartoÅ›Ä‡ `i` o `1` za kaÅ¼dym razem, uÅ¼ywajÄ…c operatora jednoargumentowego `++`. W momencie wywoÅ‚ania funkcji zwrotnej `setTimeout`, `i` miaÅ‚o wartoÅ›Ä‡ `3` w pierwszym przykÅ‚adzie.

W drugiej pÄ™tli zmienna `i` zostaÅ‚a zadeklarowana za pomocÄ… sÅ‚owa kluczowego `let`: zmienne zadeklarowane za pomocÄ… sÅ‚owa kluczowego `let` (i `const`) majÄ… zakres blokowy (blokiem jest cokolwiek miÄ™dzy `{ }`). Podczas kaÅ¼dej iteracji `i` bÄ™dzie miaÅ‚o nowÄ… wartoÅ›Ä‡, a kaÅ¼da wartoÅ›Ä‡ bÄ™dzie miaÅ‚a zakres wewnÄ…trz pÄ™tli.

</p>
</details>

---

###### 3. Jaki jest wynik?

```javascript
const shape = {
  radius: 10,
  diameter() {
    return this.radius * 2;
  },
  perimeter: () => 2 * Math.PI * this.radius,
};

console.log(shape.diameter());
console.log(shape.perimeter());
```

- A: `20` and `62.83185307179586`
- B: `20` and `NaN`
- C: `20` and `63`
- D: `NaN` and `63`

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: B

ZwrÃ³Ä‡ uwagÄ™, Å¼e wartoÅ›Ä‡ `diameter` jest zwykÅ‚Ä… funkcjÄ…, podczas gdy wartoÅ›Ä‡ `perimeter` jest funkcjÄ… strzaÅ‚kowÄ….

W przypadku funkcji strzaÅ‚kowych, sÅ‚owo kluczowe `this` odnosi siÄ™ do bieÅ¼Ä…cego otaczajÄ…cego zakresu, w przeciwieÅ„stwie do zwykÅ‚ych funkcji! Oznacza to, Å¼e gdy wywoÅ‚ujemy `perimeter`, nie odnosi siÄ™ ono do obiektu shape, ale do swojego otaczajÄ…cego zakresu (np. okna).

Na tym obiekcie nie ma wartoÅ›ci `radius`, co powoduje zwrÃ³cenie `NaN` (Not a Number).

</p>
</details>

---

###### 4. Jaki jest wynik?

```javascript
+true;
!'Lydia';
```

- A: `1` and `false`
- B: `false` and `NaN`
- C: `false` and `false`

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: A

Operator jednoargumentowy plus prÃ³buje przekonwertowaÄ‡ operand na liczbÄ™. `true` jest rÃ³wnowaÅ¼ne `1`, a `false` jest rÃ³wnowaÅ¼ne `0`.

ÅaÅ„cuch znakÃ³w `'Lydia'` jest wartoÅ›ciÄ… prawdziwÄ…. Tak naprawdÄ™ pytamy, "czy ta wartoÅ›Ä‡ prawdziwa jest faÅ‚szywa?". To zwraca `false`.

</p>
</details>

---

###### 5. KtÃ³re jest prawdziwe?

```javascript
const bird = {
  size: 'small',
};

const mouse = {
  name: 'Mickey',
  small: true,
};
```

- A: `mouse.bird.size` is not valid
- B: `mouse[bird.size]` is not valid
- C: `mouse[bird["size"]]` is not valid
- D: All of them are valid

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: A

W JavaScript wszystkie klucze obiektÃ³w sÄ… stringami (chyba Å¼e sÄ… to symbole). Nawet jeÅ›li nie wpisujemy ich jako stringi, zawsze sÄ… one konwertowane na stringi wewnÄ…trz.

JavaScript interpretuje (lub "odpakuowuje") instrukcje. Gdy uÅ¼ywamy notacji nawiasÃ³w kwadratowych, interpreter widzi pierwszy otwierajÄ…cy nawias `[` i kontynuuje do momentu znalezienia zamykajÄ…cego nawiasu `]`. Dopiero wtedy ocenia tÄ™ instrukcjÄ™.

`mouse[bird.size]`: Najpierw ocenia `bird.size`, ktÃ³re wynosi `"small"`. `mouse["small"]` zwraca `true`.

JednakÅ¼e, w przypadku notacji kropkowej, to siÄ™ nie dzieje. `mouse` nie ma klucza o nazwie `bird`, co oznacza, Å¼e `mouse.bird` jest `undefined`. NastÄ™pnie pytamy o `size` uÅ¼ywajÄ…c notacji kropkowej: `mouse.bird.size`. PoniewaÅ¼ `mouse.bird` jest `undefined`, tak naprawdÄ™ pytamy o `undefined.size`. To nie jest poprawne i spowoduje bÅ‚Ä…d podobny do `Cannot read property "size" of undefined` (Nie moÅ¼na odczytaÄ‡ wÅ‚aÅ›ciwoÅ›ci "size" z undefined).

</p>
</details>

---

###### 6. Jaki jest wynik?

```javascript
let c = { greeting: 'Hey!' };
let d;

d = c;
c.greeting = 'Hello';
console.log(d.greeting);
```

- A: `Hello`
- B: `Hey!`
- C: `undefined`
- D: `ReferenceError`
- E: `TypeError`

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: A

W JavaScript wszystkie obiekty komunikujÄ… siÄ™ ze sobÄ… przez _referencje_, gdy sÄ… sobie przypisywane.

Na poczÄ…tku zmienna `c` przechowuje referencjÄ™ do obiektu. PÃ³Åºniej przypisujemy zmiennej `d` tÄ™ samÄ… referencjÄ™, ktÃ³rÄ… ma `c`, do tego obiektu.

<img src="https://i.imgur.com/ko5k0fs.png" width="200">

Kiedy zmieniasz jeden obiekt, zmieniasz je wszystkie.

</p>
</details>

---

###### 7. Jaki jest wynik?

```javascript
let a = 3;
let b = new Number(3);
let c = 3;

console.log(a == b);
console.log(a === b);
console.log(b === c);
```

- A: `true` `false` `true`
- B: `false` `false` `true`
- C: `true` `false` `false`
- D: `false` `true` `true`

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: C

`new Number()` jest wbudowanym konstruktorem funkcji. ChociaÅ¼ wyglÄ…da jak liczba, nie jest faktycznie liczbÄ…: ma wiele dodatkowych funkcji i jest obiektem.

Gdy uÅ¼ywamy operatora `==` (operator rÃ³wnoÅ›ci), sprawdza on jedynie, czy majÄ… tÄ… samÄ… _wartoÅ›Ä‡_. Oba majÄ… wartoÅ›Ä‡ `3`, wiÄ™c zwraca `true`.

Jednak gdy uÅ¼ywamy operatora `===` (operator Å›cisÅ‚ej rÃ³wnoÅ›ci), zarÃ³wno wartoÅ›Ä‡, jak i typ powinny byÄ‡ takie same. Tutaj nie sÄ…: `new Number()` nie jest liczbÄ…, lecz **obiektem**. Oba zwracajÄ… `false`.

</p>
</details>

---

###### 8. Jaki jest wynik?

```javascript
class Chameleon {
  static colorChange(newColor) {
    this.newColor = newColor;
    return this.newColor;
  }

  constructor({ newColor = 'green' } = {}) {
    this.newColor = newColor;
  }
}

const freddie = new Chameleon({ newColor: 'purple' });
console.log(freddie.colorChange('orange'));
```

- A: `orange`
- B: `purple`
- C: `green`
- D: `TypeError`

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: D

Funkcja `colorChange` jest statyczna. Metody statyczne sÄ… zaprojektowane tak, aby istniaÅ‚y tylko w konstruktorze, w ktÃ³rym zostaÅ‚y utworzone, i nie mogÄ… byÄ‡ przekazywane do Å¼adnych potomkÃ³w (children) ani wywoÅ‚ywane na instancjach klasy. PoniewaÅ¼ `freddie` jest instancjÄ… klasy Chameleon, funkcja nie moÅ¼e byÄ‡ na niej wywoÅ‚ana. Otrzymujemy bÅ‚Ä…d `TypeError`.

</p>
</details>

---

###### 9. Jaki jest wynik?

```javascript
let greeting;
greetign = {}; // Celowa LiterÃ³wka!
console.log(greetign);
```

- A: `{}`
- B: `ReferenceError: greetign is not defined`
- C: `undefined`

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: A

Kod wypisuje w konsoli obiekt, poniewaÅ¼ wÅ‚aÅ›nie utworzyliÅ›my pusty obiekt w obiekcie globalnym! Gdy pomyÅ‚kowo wpisaliÅ›my `greeting` jako `greetign`, interpreter JavaScript faktycznie zobaczyÅ‚ to jako:

1. `global.greetign = {}` w Node.js.
2. `window.greetign = {}`, `frames.greetign = {}` i `self.greetign` w przeglÄ…darkach.
3. `self.greetign` w web workerach.
4. `globalThis.greetign` we wszystkich Å›rodowiskach.

Aby temu zapobiec, moÅ¼emy uÅ¼yÄ‡ `"use strict"`. Powoduje to, Å¼e musisz zadeklarowaÄ‡ zmiennÄ… przed jej przypisaniem.

</p>
</details>

---

###### 10. Co siÄ™ dzieje, gdy to zrobimy?

```javascript
function bark() {
  console.log('Woof!');
}

bark.animal = 'dog';
```

- A: Nothing, this is totally fine!
- B: `SyntaxError`. You cannot add properties to a function this way.
- C: `"Woof"` gets logged.
- D: `ReferenceError`

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: A

Jest to moÅ¼liwe w JavaScript, poniewaÅ¼ funkcje sÄ… obiektami! (Wszystko oprÃ³cz typÃ³w prymitywnych jest obiektem)

Funkcja jest specjalnym rodzajem obiektu. Kod, ktÃ³ry sam piszesz, nie jest wÅ‚aÅ›ciwÄ… funkcjÄ…. Funkcja jest obiektem posiadajÄ…cym wÅ‚aÅ›ciwoÅ›Ä‡, ktÃ³ra jest wywoÅ‚ywalna.

</p>
</details>

---

###### 11. Jaki jest wynik?

```javascript
function Person(firstName, lastName) {
  this.firstName = firstName;
  this.lastName = lastName;
}

const member = new Person('Lydia', 'Hallie');
Person.getFullName = function() {
  return `${this.firstName} ${this.lastName}`;
};

console.log(member.getFullName());
```

- A: `TypeError`
- B: `SyntaxError`
- C: `Lydia Hallie`
- D: `undefined` `undefined`

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: A

W JavaScript funkcje sÄ… obiektami, wiÄ™c metoda `getFullName` jest dodawana do samego obiektu funkcji konstruktora. Dlatego moÅ¼emy wywoÅ‚aÄ‡ `Person.getFullName()`, ale `member.getFullName` zwraca bÅ‚Ä…d `TypeError`.

JeÅ›li chcesz, aby metoda byÅ‚a dostÄ™pna dla wszystkich instancji obiektÃ³w, musisz dodaÄ‡ jÄ… do wÅ‚aÅ›ciwoÅ›ci prototype:

```js
Person.prototype.getFullName = function() {
  return `${this.firstName} ${this.lastName}`;
};
```

</p>
</details>

---

###### 12. Jaki jest wynik?

```javascript
function Person(firstName, lastName) {
  this.firstName = firstName;
  this.lastName = lastName;
}

const lydia = new Person('Lydia', 'Hallie');
const sarah = Person('Sarah', 'Smith');

console.log(lydia);
console.log(sarah);
```

- A: `Person {firstName: "Lydia", lastName: "Hallie"}` and `undefined`
- B: `Person {firstName: "Lydia", lastName: "Hallie"}` and `Person {firstName: "Sarah", lastName: "Smith"}`
- C: `Person {firstName: "Lydia", lastName: "Hallie"}` and `{}`
- D: `Person {firstName: "Lydia", lastName: "Hallie"}` and `ReferenceError`

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: A

Dla `sarah`, nie uÅ¼yliÅ›my sÅ‚owa kluczowego `new`. Kiedy uÅ¼ywamy `new`, `this` odwoÅ‚uje siÄ™ do nowego pustego obiektu, ktÃ³ry tworzymy. Jednak jeÅ›li nie dodajemy `new`, `this` odwoÅ‚uje siÄ™ do **globalnego obiektu**!

MÃ³wiliÅ›my, Å¼e `this.firstName` rÃ³wna siÄ™ `"Sarah"`, a `this.lastName` rÃ³wna siÄ™ `"Smith"`. Czyli faktycznie zdefiniowaliÅ›my `global.firstName = 'Sarah'` i `global.lastName = 'Smith'`. `sarah` pozostaje `undefined`, poniewaÅ¼ nie zwracaliÅ›my Å¼adnej wartoÅ›ci z funkcji `Person`.

</p>
</details>

---

###### 13. Jakie sÄ… trzy fazy propagacji zdarzeÅ„?

- A: Target > Capturing > Bubbling
- B: Bubbling > Target > Capturing
- C: Target > Bubbling > Capturing
- D: Capturing > Target > Bubbling

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: D

W fazie **capturing (przechwytywanie)**, zdarzenie przechodzi przez elementy nadrzÄ™dne w doÅ‚ do elementu docelowego. NastÄ™pnie dociera do elementu **target (cel)** i rozpoczyna siÄ™ **bubbling (bÄ…belkowanie)**.

<img src="https://i.imgur.com/N18oRgd.png" width="200">

</p>
</details>

---

###### 14. Wszystkie obiekty majÄ… prototypy.

- A: true
- B: false

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: B

Wszystkie obiekty majÄ… prototypy, z wyjÄ…tkiem **obiektu bazowego**. Obiekt bazowy jest obiektem utworzonym przez uÅ¼ytkownika lub obiektem utworzonym przy uÅ¼yciu sÅ‚owa kluczowego `new`. Obiekt bazowy ma dostÄ™p do niektÃ³rych metod i wÅ‚aÅ›ciwoÅ›ci, takich jak `.toString`. Jest to powÃ³d, dla ktÃ³rego moÅ¼na uÅ¼ywaÄ‡ wbudowanych metod JavaScript! Wszystkie takie metody sÄ… dostÄ™pne w prototypie. ChociaÅ¼ JavaScript nie moÅ¼e znaleÅºÄ‡ ich bezpoÅ›rednio w twoim obiekcie, przechodzi w dÃ³Å‚ Å‚aÅ„cucha prototypÃ³w i je tam znajduje, co czyni je dostÄ™pnymi dla ciebie.

</p>
</details>

---

###### 15. Jaki jest wynik?

```javascript
function sum(a, b) {
  return a + b;
}

sum(1, '2');
```

- A: `NaN`
- B: `TypeError`
- C: `"12"`
- D: `3`

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: C

JavaScript jest jÄ™zykiem **dynamicznie typowanym**: nie okreÅ›lamy typÃ³w niektÃ³rych zmiennych. WartoÅ›ci mogÄ… byÄ‡ automatycznie konwertowane na inny typ bez wiedzy uÅ¼ytkownika, co nazywa siÄ™ _implicit type coercion_. **Koercja (Wymuszenie)** to konwersja z jednego typu na inny.

W tym przykÅ‚adzie JavaScript konwertuje liczbÄ™ `1` na string, aby funkcja miaÅ‚a sens i zwrÃ³ciÅ‚a wartoÅ›Ä‡. Podczas dodawania typu liczbowego (`1`) i typu Å‚aÅ„cuchowego (`'2'`), liczba traktowana jest jako string. MoÅ¼emy Å‚Ä…czyÄ‡ stringi takie jak `"Hello" + "World"`, wiÄ™c to co siÄ™ tutaj dzieje to `"1" + "2"`, ktÃ³re zwraca `"12"`.

</p>
</details>

---

###### 16. Jaki jest wynik?

```javascript
let number = 0;
console.log(number++);
console.log(++number);
console.log(number);
```

- A: `1` `1` `2`
- B: `1` `2` `2`
- C: `0` `2` `2`
- D: `0` `1` `2`

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: C

Operator jednoargumentowy **Postfix** `++`:

1. Zwraca wartoÅ›Ä‡ (ten zwraca `0`)
2. ZwiÄ™ksza wartoÅ›Ä‡ (liczba wynosi teraz `1`)

Operator jednoargumentowy **Prefix**  `++`:

1. ZwiÄ™ksza wartoÅ›Ä‡ (liczba wynosi teraz `2`)
2. Zwraca wartoÅ›Ä‡ (to zwraca `2`)

number zwraca `0 2 2`.

</p>
</details>

---

###### 17. Jaki jest wynik?

```javascript
function getPersonInfo(one, two, three) {
  console.log(one);
  console.log(two);
  console.log(three);
}

const person = 'Lydia';
const age = 21;

getPersonInfo`${person} is ${age} years old`;
```

- A: `"Lydia"` `21` `["", " is ", " years old"]`
- B: `["", " is ", " years old"]` `"Lydia"` `21`
- C: `"Lydia"` `["", " is ", " years old"]` `21`

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: B

W przypadku uÅ¼ycia `template strings`, wartoÅ›ciÄ… pierwszego argumentu jest zawsze tablica wartoÅ›ci Å‚aÅ„cuchowych (string). PozostaÅ‚e argumenty otrzymujÄ… wartoÅ›ci przekazanych wyraÅ¼eÅ„!

</p>
</details>

---

###### 18. Jaki jest wynik?

```javascript
function checkAge(data) {
  if (data === { age: 18 }) {
    console.log('You are an adult!');
  } else if (data == { age: 18 }) {
    console.log('You are still an adult.');
  } else {
    console.log(`Hmm.. You don't have an age I guess`);
  }
}

checkAge({ age: 18 });
```

- A: `You are an adult!`
- B: `You are still an adult.`
- C: `Hmm.. You don't have an age I guess`

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: C

Podczas testowania rÃ³wnoÅ›ci, liczby i ciÄ…gi znakÃ³w sÄ… porÃ³wnywane przez ich _wartoÅ›ci_, a obiekty sÄ… porÃ³wnywane przez ich _referencjÄ™_. JavaScript sprawdza, czy obiekty majÄ… odwoÅ‚anie do tej samej lokalizacji w pamiÄ™ci.

Dwa obiekty, ktÃ³re porÃ³wnujemy, nie majÄ… tej samej lokalizacji w pamiÄ™ci: obiekt, ktÃ³ry przekazujemy jako parametr, odwoÅ‚uje siÄ™ do innej lokalizacji w pamiÄ™ci niÅ¼ obiekt, ktÃ³rego uÅ¼yliÅ›my do sprawdzenia rÃ³wnoÅ›ci.

Dlatego teÅ¼ zarÃ³wno `{ age: 18 } == { age: 18 }` i `{ age: 18 } == { age: 18 }` zwracajÄ… `false`.

</p>
</details>

---

###### 19. Jaki jest wynik?

```javascript
function getAge(...args) {
  console.log(typeof args);
}

getAge(21);
```

- A: `"number"`
- B: `"array"`
- C: `"object"`
- D: `"NaN"`

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: C

Parametr reszty (`...args`) pozwala nam "zbieraÄ‡" wszystkie pozostaÅ‚e argumenty do tablicy. Tablica to obiekt, wiÄ™c `typeof args` zwraca `"object"`.

</p>
</details>

---

###### 20. Jaki jest wynik?

```javascript
function getAge() {
  'use strict';
  age = 21;
  console.log(age);
}

getAge();
```

- A: `21`
- B: `undefined`
- C: `ReferenceError`
- D: `TypeError`

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: C

DziÄ™ki `"use strict"` moÅ¼esz upewniÄ‡ siÄ™, Å¼e przypadkowo nie zadeklarujesz zmiennych globalnych. Nigdy nie zadeklarowaliÅ›my zmiennej `age`, a poniewaÅ¼ uÅ¼ywamy `"use strict"`, zostanie zgÅ‚oszony bÅ‚Ä…d referencji. GdybyÅ›my nie uÅ¼yli `"use strict"`, to by zadziaÅ‚aÅ‚o, poniewaÅ¼ wÅ‚aÅ›ciwoÅ›Ä‡ `age` zostaÅ‚aby dodana do obiektu globalnego.

</p>
</details>

---

###### 21. Jaka jest wartoÅ›Ä‡ `sum`?

```javascript
const sum = eval('10*10+5');
```

- A: `105`
- B: `"105"`
- C: `TypeError`
- D: `"10*10+5"`

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: A

`eval` oblicza kod, ktÃ³ry przekazywany jest jako ciÄ…g znakÃ³w. JeÅ›li jest to wyraÅ¼enie, tak jak w tym przypadku, oblicza ono wyraÅ¼enie. WyraÅ¼enie to `10 * 10 + 5`. Zwraca liczbÄ™ `105`.

</p>
</details>

---

###### 22. Jak dÅ‚ugo cool_secret jest dostÄ™pny?

```javascript
sessionStorage.setItem('cool_secret', 123);
```

- A: Dane nigdy nie zostanÄ… utracone.
- B: Gdy uÅ¼ytkownik zamyka kartÄ™.
- C: Gdy uÅ¼ytkownik zamyka caÅ‚y przeglÄ…darkÄ™, a nie tylko kartÄ™.
- D: Gdy uÅ¼ytkownik wyÅ‚Ä…cza swÃ³j komputer.

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: B

Dane przechowywane w `sessionStorage` sÄ… usuwane po zamkniÄ™ciu _zakÅ‚adki_.

GdybyÅ› uÅ¼yÅ‚ `localStorage`, dane pozostaÅ‚yby tam na zawsze, chyba Å¼e na przykÅ‚ad wywoÅ‚ano by `localStorage.clear()`.

</p>
</details>

---

###### 23. Jaki jest wynik?

```javascript
var num = 8;
var num = 10;

console.log(num);
```

- A: `8`
- B: `10`
- C: `SyntaxError`
- D: `ReferenceError`

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: B

Za pomocÄ… sÅ‚owa kluczowego `var` moÅ¼na zadeklarowaÄ‡ wiele zmiennych o tej samej nazwie. Zmienna bÄ™dzie wtedy przechowywaÄ‡ najnowszÄ… wartoÅ›Ä‡.

Nie moÅ¼na tego zrobiÄ‡ za pomocÄ… `let` lub `const`, poniewaÅ¼ sÄ… one blokowe.

</p>
</details>

---

###### 24. Jaki jest wynik?

```javascript
const obj = { 1: 'a', 2: 'b', 3: 'c' };
const set = new Set([1, 2, 3, 4, 5]);

obj.hasOwnProperty('1');
obj.hasOwnProperty(1);
set.has('1');
set.has(1);
```

- A: `false` `true` `false` `true`
- B: `false` `true` `true` `true`
- C: `true` `true` `false` `true`
- D: `true` `true` `true` `true`

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: C

Wszystkie klucze obiektÃ³w (z wyjÄ…tkiem symboli) sÄ… Å‚aÅ„cuchami znakÃ³w pod wzglÄ™dem samego obiektu, nawet jeÅ›li nie napiszesz ich samodzielnie jako Å‚aÅ„cucha znakÃ³w. Dlatego `obj.hasOwnProperty('1')` rÃ³wnieÅ¼ zwraca true.

Nie dziaÅ‚a to w ten sam sposÃ³b dla zbioru. W zbiorze nie ma klucza `'1'`:`set.has('1')`, dlatego zwraca wartoÅ›Ä‡ false. Zawiera on liczbÄ™ caÅ‚kowitÄ… `1`, `set.has(1)` zwraca wartoÅ›Ä‡ true.

</p>
</details>

---

###### 25. Jaki jest wynik?

```javascript
const obj = { a: 'one', b: 'two', a: 'three' };
console.log(obj);
```

- A: `{ a: "one", b: "two" }`
- B: `{ b: "two", a: "three" }`
- C: `{ a: "three", b: "two" }`
- D: `SyntaxError`

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: C

JeÅ›li masz dwa klucze o takiej samej nazwie, zostanie on zastÄ…piony. Nadal bÄ™dzie umieszczony na pierwszej pozycji, ale z ostatniÄ… zdefiniowanÄ… wartoÅ›ciÄ….

</p>
</details>

---

###### 26. Globalny kontekst wykonania JavaScript tworzy dwie rzeczy: obiekt globalny i sÅ‚owo kluczowe "this".

- A: true
- B: false
- C: it depends

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: A

Globalny kontekst wykonania jest dostÄ™pny wszÄ™dzie w kodzie.

</p>
</details>

---

###### 27. Jaki jest wynik?

```javascript
for (let i = 1; i < 5; i++) {
  if (i === 3) continue;
  console.log(i);
}
```

- A: `1` `2`
- B: `1` `2` `3`
- C: `1` `2` `4`
- D: `1` `3` `4`

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: C

Instrukcja `continue` pomija iteracjÄ™, jeÅ›li okreÅ›lony warunek zwrÃ³ci `true`.

</p>
</details>

---

###### 28. Jaki jest wynik?

```javascript
String.prototype.giveLydiaPizza = () => {
  return 'Just give Lydia pizza already!';
};

const name = 'Lydia';

console.log(name.giveLydiaPizza())
```

- A: `"Just give Lydia pizza already!"`
- B: `TypeError: not a function`
- C: `SyntaxError`
- D: `undefined`

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: A

`String` jest wbudowanym konstruktorem, do ktÃ³rego moÅ¼emy dodawaÄ‡ wÅ‚aÅ›ciwoÅ›ci. Dodana zostaÅ‚a metoda do jego prototypu. Prymitywne ciÄ…gi znakÃ³w sÄ… automatycznie konwertowane na obiekt typu string, generowany przez funkcjÄ™ prototypu ciÄ…gu znakÃ³w. Tak wiÄ™c wszystkie ciÄ…gi (obiekty typu string) majÄ… dostÄ™p do tej metody!

</p>
</details>

---

###### 29. Jaki jest wynik?

```javascript
const a = {};
const b = { key: 'b' };
const c = { key: 'c' };

a[b] = 123;
a[c] = 456;

console.log(a[b]);
```

- A: `123`
- B: `456`
- C: `undefined`
- D: `ReferenceError`

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: B

Klucze obiektÃ³w sÄ… automatycznie konwertowane na ciÄ…gi znakÃ³w. PrÃ³bujemy ustawiÄ‡ obiekt jako klucz do obiektu `a`, z wartoÅ›ciÄ… `123`.

JednakÅ¼e, kiedy stringujemy obiekt, staje siÄ™ on `"[obiekt Object]"`. MÃ³wimy wiÄ™c, Å¼e `a["[obiekt Object]"] = 123`. NastÄ™pnie prÃ³bujemy zrobiÄ‡ to samo. `c` jest kolejnym obiektem, ktÃ³ry niejawnie stringujemy. Zatem `a["[obiekt Object]"] = 456`.

NastÄ™pnie wyÅ›wietlamy w konsoli `a[b]`, co w rzeczywistoÅ›ci jest `a["[obiekt Object]"]`, ustawiony wczeÅ›niej na `456`, wiÄ™c zwraca `456`.

</p>
</details>

---

###### 30. Jaki jest wynik?

```javascript
const foo = () => console.log('First');
const bar = () => setTimeout(() => console.log('Second'));
const baz = () => console.log('Third');

bar();
foo();
baz();
```

- A: `First` `Second` `Third`
- B: `First` `Third` `Second`
- C: `Second` `First` `Third`
- D: `Second` `Third` `First`

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: B

Mamy funkcjÄ™ `setTimeout` i wywoÅ‚aliÅ›my jÄ… jako pierwszÄ…. ZostaÅ‚a jednak wyÅ›wietlona jako ostatnia.

Dzieje siÄ™ tak, poniewaÅ¼ w przeglÄ…darkach mamy nie tylko silnik wykonawczy, ale takÅ¼e coÅ›, co nazywa siÄ™ `WebAPI`. Interfejs `WebAPI` daje nam na poczÄ…tek funkcjÄ™ `setTimeout`.

Po przesÅ‚aniu _callback_ do WebAPI, sama funkcja `setTimeout` (ale nie callback!) jest usuwana ze stosu.

<img src="https://i.imgur.com/X5wsHOg.png" width="200">

Teraz, `foo` jest wywoÅ‚ywane, a `"First"` jest wyÅ›wietlane.

<img src="https://i.imgur.com/Pvc0dGq.png" width="200">

`foo` jest zdejmowane ze stosu, a `baz` jest wywoÅ‚ywane. "Third" zostaje wyÅ›wietlony.

<img src="https://i.imgur.com/WhA2bCP.png" width="200">

WebAPI nie moÅ¼e dodawaÄ‡ rzeczy do stosu, gdy jest gotowy. Zamiast tego przesuwa funkcjÄ™ zwrotnÄ… do czegoÅ› zwanego _kolejkÄ…_.

<img src="https://i.imgur.com/NSnDZmU.png" width="200">

W tym miejscu zaczyna dziaÅ‚aÄ‡ pÄ™tla zdarzeÅ„. **PÄ™tla zdarzeÅ„** patrzy na stos i kolejkÄ™ zadaÅ„. JeÅ›li stos jest pusty, pobiera pierwszÄ… rzecz z kolejki i przesuwa jÄ… na stos.

<img src="https://i.imgur.com/uyiScAI.png" width="200">

`bar` zostaje wywoÅ‚any, `"Second"` zostaje wyÅ›wietlony i zdjÄ™ty ze stosu.

</p>
</details>