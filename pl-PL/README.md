<div align="center">
  <img height="60" src="https://img.icons8.com/color/344/javascript.png">
  <h1>Pytania dotyczÄ…ce JavaScript</h1>

---

<span>PublikujÄ™ pytania wielokrotnego wyboru dotyczÄ…ce JavaScriptu na swoich [Instagram](https://www.instagram.com/theavocoder) **stories**, ktÃ³re rÃ³wnieÅ¼ zamieszczÄ™ tutaj! Ostatnia aktualizacja: <a href=#20200612><b>27 Czerwca</b></a>

Od podstawowych do zaawansowanych: sprawdÅº, jak dobrze znasz JavaScript, odÅ›wieÅ¼ swojÄ… wiedzÄ™ lub przygotuj siÄ™ do rozmowy kwalifikacyjnej! :muscle: :rocket: Regularnie aktualizujÄ™ to repozytorium nowymi pytaniami. Odpowiedzi znajdujÄ… siÄ™ w ukrytych zakÅ‚adkach poniÅ¼ej pytaÅ„ - po prostu kliknij, aby je rozwiniÄ™Ä‡. To dla zabawy, powodzenia! :heart:</span>

Nie krÄ™puj siÄ™ ze mnÄ… kontaktowaÄ‡! ğŸ˜Š <br />
<a href="https://www.instagram.com/theavocoder">Instagram</a> || <a href="https://www.twitter.com/lydiahallie">Twitter</a> || <a href="https://www.linkedin.com/in/lydia-hallie">LinkedIn</a> || <a href="https://www.lydiahallie.dev">Blog</a>
</div>

| ÅšmiaÅ‚o uÅ¼ywaj ich w projekcie! ğŸ˜ƒ  ByÅ‚abym _bardzo_ wdziÄ™czna za referencje do tego repozytorium, tworzÄ™ pytania i wyjaÅ›nienia (tak, jestem smutna lol) i spoÅ‚ecznoÅ›Ä‡ bardzo mi pomaga w utrzymaniu i ulepszaniu go! ğŸ’ªğŸ¼ DziÄ™kujÄ™ i baw siÄ™ dobrze!   |
|---|

---

<details><summary><b> Zobacz 20 dostÄ™pnych tÅ‚umaczeÅ„ ğŸ‡¸ğŸ‡¦ğŸ‡ªğŸ‡¬ğŸ‡§ğŸ‡¦ğŸ‡©ğŸ‡ªğŸ‡ªğŸ‡¸ğŸ‡«ğŸ‡·ğŸ‡®ğŸ‡©ğŸ‡¯ğŸ‡µğŸ‡°ğŸ‡·ğŸ‡³ğŸ‡±ğŸ‡§ğŸ‡·ğŸ‡·ğŸ‡ºğŸ‡¹ğŸ‡­ğŸ‡¹ğŸ‡·ğŸ‡ºğŸ‡¦ğŸ‡»ğŸ‡³ğŸ‡¨ğŸ‡³ğŸ‡¹ğŸ‡¼ğŸ‡½ğŸ‡°</b></summary>
<p>

- [ğŸ‡¸ğŸ‡¦ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©](./ar-AR/README_AR.md)
- [ğŸ‡ªğŸ‡¬ Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø§Ù…ÙŠØ©](./ar-EG/README_ar-EG.md)
- [ğŸ‡§ğŸ‡¦ Bosanski](./bs-BS/README-bs_BS.md)
- [ğŸ‡©ğŸ‡ª Deutsch](./de-DE/README.md)
- [ğŸ‡ªğŸ‡¸ EspaÃ±ol](./es-ES/README-ES.md)
- [ğŸ‡«ğŸ‡· FranÃ§ais](./fr-FR/README_fr-FR.md)
- [ğŸ‡®ğŸ‡© Indonesia](./id-ID/README.md)
- [ğŸ‡®ğŸ‡¹ Italiano](./it-IT/README.md)
- [ğŸ‡¯ğŸ‡µ æ—¥æœ¬èª](./ja-JA/README-ja_JA.md)
- [ğŸ‡°ğŸ‡· í•œêµ­ì–´](./ko-KR/README-ko_KR.md)
- [ğŸ‡³ğŸ‡± Nederlands](./nl-NL/README.md)
- [ğŸ‡§ğŸ‡· PortuguÃªs Brasil](./pt-BR/README_pt_BR.md)
- [ğŸ‡·ğŸ‡º Ğ ÑƒÑÑĞºĞ¸Ğ¹](./ru-RU/README.md)
- [ğŸ‡½ğŸ‡° Shqip](../sq-KS/README_sq_KS.md)
- [ğŸ‡¹ğŸ‡­ à¹„à¸—à¸¢](./th-TH/README-th_TH.md)
- [ğŸ‡¹ğŸ‡· TÃ¼rkÃ§e](./tr-TR/README-tr_TR.md)
- [ğŸ‡ºğŸ‡¦ Ğ£ĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°](./uk-UA/README.md)
- [ğŸ‡»ğŸ‡³ Tiáº¿ng Viá»‡t](./vi-VI/README-vi.md)
- [ğŸ‡¨ğŸ‡³ ç®€ä½“ä¸­æ–‡](./zh-CN/README-zh_CN.md)
- [ğŸ‡¹ğŸ‡¼ ç¹é«”ä¸­æ–‡](./zh-TW/README_zh-TW.md)

</p>
</details>

---

###### 1. Jaki jest wynik?

```javascript
function sayHi() {
  console.log(name);
  console.log(age);
  var name = 'Lydia';
  let age = 21;
}

sayHi();
```

- A: `Lydia` and `undefined`
- B: `Lydia` and `ReferenceError`
- C: `ReferenceError` and `21`
- D: `undefined` and `ReferenceError`

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: D

WewnÄ…trz funkcji najpierw deklarujemy zmiennÄ… `name` za pomocÄ… sÅ‚owa kluczowego `var`. Oznacza to, Å¼e zmienna jest "wyciÄ…gana" (przestrzeÅ„ pamiÄ™ci jest tworzona) z domyÅ›lnÄ… wartoÅ›ciÄ… `undefined` podczas fazy tworzenia, aÅ¼ do momentu, gdy naprawdÄ™ definiujemy zmiennÄ…. W linii, w ktÃ³rej prÃ³bujemy wyÅ›wietliÄ‡ w konsoli zmiennÄ… `name`, jeszcze jej nie zdefiniowaliÅ›my, wiÄ™c nadal przechowuje wartoÅ›Ä‡ `undefined`.

Zmienne zadeklarowane za pomocÄ… sÅ‚owa kluczowego `let` (i `const`) sÄ… wyciÄ…gane, ale w przeciwieÅ„stwie do `var`, nie sÄ… <i>inicjalizowane</i>. Nie sÄ… dostÄ™pne przed liniÄ…, na ktÃ³rej je deklarujemy (inicjalizujemy). Nazywa siÄ™ to "czasowÄ… strefÄ… martwÄ…" (temporal dead zone). Gdy prÃ³bujemy uzyskaÄ‡ dostÄ™p do zmiennych przed ich zadeklarowaniem, JavaScript generuje bÅ‚Ä…d `ReferenceError`.

</p>
</details>

---

###### 2. Jaki jest wynik?

```javascript
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 1);
}

for (let i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 1);
}
```

- A: `0 1 2` and `0 1 2`
- B: `0 1 2` and `3 3 3`
- C: `3 3 3` and `0 1 2`

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: C

Ze wzglÄ™du na kolejkÄ™ zdarzeÅ„ w JavaScript, funkcja zwrotna `setTimeout` jest wywoÅ‚ywana _po_ wykonaniu pÄ™tli. PoniewaÅ¼ zmienna `i` w pierwszej pÄ™tli zostaÅ‚a zadeklarowana za pomocÄ… sÅ‚owa kluczowego `var`, jej wartoÅ›Ä‡ byÅ‚a globalna. Podczas pÄ™tli inkrementowaliÅ›my wartoÅ›Ä‡ `i` o `1` za kaÅ¼dym razem, uÅ¼ywajÄ…c operatora jednoargumentowego `++`. W momencie wywoÅ‚ania funkcji zwrotnej `setTimeout`, `i` miaÅ‚o wartoÅ›Ä‡ `3` w pierwszym przykÅ‚adzie.

W drugiej pÄ™tli zmienna `i` zostaÅ‚a zadeklarowana za pomocÄ… sÅ‚owa kluczowego `let`: zmienne zadeklarowane za pomocÄ… sÅ‚owa kluczowego `let` (i `const`) majÄ… zakres blokowy (blokiem jest cokolwiek miÄ™dzy `{ }`). Podczas kaÅ¼dej iteracji `i` bÄ™dzie miaÅ‚o nowÄ… wartoÅ›Ä‡, a kaÅ¼da wartoÅ›Ä‡ bÄ™dzie miaÅ‚a zakres wewnÄ…trz pÄ™tli.

</p>
</details>

---

###### 3. Jaki jest wynik?

```javascript
const shape = {
  radius: 10,
  diameter() {
    return this.radius * 2;
  },
  perimeter: () => 2 * Math.PI * this.radius,
};

console.log(shape.diameter());
console.log(shape.perimeter());
```

- A: `20` and `62.83185307179586`
- B: `20` and `NaN`
- C: `20` and `63`
- D: `NaN` and `63`

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: B

ZwrÃ³Ä‡ uwagÄ™, Å¼e wartoÅ›Ä‡ `diameter` jest zwykÅ‚Ä… funkcjÄ…, podczas gdy wartoÅ›Ä‡ `perimeter` jest funkcjÄ… strzaÅ‚kowÄ….

W przypadku funkcji strzaÅ‚kowych, sÅ‚owo kluczowe `this` odnosi siÄ™ do bieÅ¼Ä…cego otaczajÄ…cego zakresu, w przeciwieÅ„stwie do zwykÅ‚ych funkcji! Oznacza to, Å¼e gdy wywoÅ‚ujemy `perimeter`, nie odnosi siÄ™ ono do obiektu shape, ale do swojego otaczajÄ…cego zakresu (np. okna).

Na tym obiekcie nie ma wartoÅ›ci `radius`, co powoduje zwrÃ³cenie `NaN` (Not a Number).

</p>
</details>

---

###### 4. Jaki jest wynik?

```javascript
+true;
!'Lydia';
```

- A: `1` and `false`
- B: `false` and `NaN`
- C: `false` and `false`

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: A

Operator jednoargumentowy plus prÃ³buje przekonwertowaÄ‡ operand na liczbÄ™. `true` jest rÃ³wnowaÅ¼ne `1`, a `false` jest rÃ³wnowaÅ¼ne `0`.

ÅaÅ„cuch znakÃ³w `'Lydia'` jest wartoÅ›ciÄ… prawdziwÄ…. Tak naprawdÄ™ pytamy, "czy ta wartoÅ›Ä‡ prawdziwa jest faÅ‚szywa?". To zwraca `false`.

</p>
</details>

---

###### 5. KtÃ³re jest prawdziwe?

```javascript
const bird = {
  size: 'small',
};

const mouse = {
  name: 'Mickey',
  small: true,
};
```

- A: `mouse.bird.size` is not valid
- B: `mouse[bird.size]` is not valid
- C: `mouse[bird["size"]]` is not valid
- D: All of them are valid

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: A

W JavaScript wszystkie klucze obiektÃ³w sÄ… stringami (chyba Å¼e sÄ… to symbole). Nawet jeÅ›li nie wpisujemy ich jako stringi, zawsze sÄ… one konwertowane na stringi wewnÄ…trz.

JavaScript interpretuje (lub "odpakuowuje") instrukcje. Gdy uÅ¼ywamy notacji nawiasÃ³w kwadratowych, interpreter widzi pierwszy otwierajÄ…cy nawias `[` i kontynuuje do momentu znalezienia zamykajÄ…cego nawiasu `]`. Dopiero wtedy ocenia tÄ™ instrukcjÄ™.

`mouse[bird.size]`: Najpierw ocenia `bird.size`, ktÃ³re wynosi `"small"`. `mouse["small"]` zwraca `true`.

JednakÅ¼e, w przypadku notacji kropkowej, to siÄ™ nie dzieje. `mouse` nie ma klucza o nazwie `bird`, co oznacza, Å¼e `mouse.bird` jest `undefined`. NastÄ™pnie pytamy o `size` uÅ¼ywajÄ…c notacji kropkowej: `mouse.bird.size`. PoniewaÅ¼ `mouse.bird` jest `undefined`, tak naprawdÄ™ pytamy o `undefined.size`. To nie jest poprawne i spowoduje bÅ‚Ä…d podobny do `Cannot read property "size" of undefined` (Nie moÅ¼na odczytaÄ‡ wÅ‚aÅ›ciwoÅ›ci "size" z undefined).

</p>
</details>

---

###### 6. Jaki jest wynik?

```javascript
let c = { greeting: 'Hey!' };
let d;

d = c;
c.greeting = 'Hello';
console.log(d.greeting);
```

- A: `Hello`
- B: `Hey!`
- C: `undefined`
- D: `ReferenceError`
- E: `TypeError`

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: A

W JavaScript wszystkie obiekty komunikujÄ… siÄ™ ze sobÄ… przez _referencje_, gdy sÄ… sobie przypisywane.

Na poczÄ…tku zmienna `c` przechowuje referencjÄ™ do obiektu. PÃ³Åºniej przypisujemy zmiennej `d` tÄ™ samÄ… referencjÄ™, ktÃ³rÄ… ma `c`, do tego obiektu.

<img src="https://i.imgur.com/ko5k0fs.png" width="200">

Kiedy zmieniasz jeden obiekt, zmieniasz je wszystkie.

</p>
</details>

---

###### 7. Jaki jest wynik?

```javascript
let a = 3;
let b = new Number(3);
let c = 3;

console.log(a == b);
console.log(a === b);
console.log(b === c);
```

- A: `true` `false` `true`
- B: `false` `false` `true`
- C: `true` `false` `false`
- D: `false` `true` `true`

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: C

`new Number()` jest wbudowanym konstruktorem funkcji. ChociaÅ¼ wyglÄ…da jak liczba, nie jest faktycznie liczbÄ…: ma wiele dodatkowych funkcji i jest obiektem.

Gdy uÅ¼ywamy operatora `==` (operator rÃ³wnoÅ›ci), sprawdza on jedynie, czy majÄ… tÄ… samÄ… _wartoÅ›Ä‡_. Oba majÄ… wartoÅ›Ä‡ `3`, wiÄ™c zwraca `true`.

Jednak gdy uÅ¼ywamy operatora `===` (operator Å›cisÅ‚ej rÃ³wnoÅ›ci), zarÃ³wno wartoÅ›Ä‡, jak i typ powinny byÄ‡ takie same. Tutaj nie sÄ…: `new Number()` nie jest liczbÄ…, lecz **obiektem**. Oba zwracajÄ… `false`.

</p>
</details>

---

###### 8. Jaki jest wynik?

```javascript
class Chameleon {
  static colorChange(newColor) {
    this.newColor = newColor;
    return this.newColor;
  }

  constructor({ newColor = 'green' } = {}) {
    this.newColor = newColor;
  }
}

const freddie = new Chameleon({ newColor: 'purple' });
console.log(freddie.colorChange('orange'));
```

- A: `orange`
- B: `purple`
- C: `green`
- D: `TypeError`

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: D

Funkcja `colorChange` jest statyczna. Metody statyczne sÄ… zaprojektowane tak, aby istniaÅ‚y tylko w konstruktorze, w ktÃ³rym zostaÅ‚y utworzone, i nie mogÄ… byÄ‡ przekazywane do Å¼adnych potomkÃ³w (children) ani wywoÅ‚ywane na instancjach klasy. PoniewaÅ¼ `freddie` jest instancjÄ… klasy Chameleon, funkcja nie moÅ¼e byÄ‡ na niej wywoÅ‚ana. Otrzymujemy bÅ‚Ä…d `TypeError`.

</p>
</details>

---

###### 9. Jaki jest wynik?

```javascript
let greeting;
greetign = {}; // Celowa LiterÃ³wka!
console.log(greetign);
```

- A: `{}`
- B: `ReferenceError: greetign is not defined`
- C: `undefined`

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: A

Kod wypisuje w konsoli obiekt, poniewaÅ¼ wÅ‚aÅ›nie utworzyliÅ›my pusty obiekt w obiekcie globalnym! Gdy pomyÅ‚kowo wpisaliÅ›my `greeting` jako `greetign`, interpreter JavaScript faktycznie zobaczyÅ‚ to jako:

1. `global.greetign = {}` w Node.js.
2. `window.greetign = {}`, `frames.greetign = {}` i `self.greetign` w przeglÄ…darkach.
3. `self.greetign` w web workerach.
4. `globalThis.greetign` we wszystkich Å›rodowiskach.

Aby temu zapobiec, moÅ¼emy uÅ¼yÄ‡ `"use strict"`. Powoduje to, Å¼e musisz zadeklarowaÄ‡ zmiennÄ… przed jej przypisaniem.

</p>
</details>

---

###### 10. Co siÄ™ dzieje, gdy to zrobimy?

```javascript
function bark() {
  console.log('Woof!');
}

bark.animal = 'dog';
```

- A: Nothing, this is totally fine!
- B: `SyntaxError`. You cannot add properties to a function this way.
- C: `"Woof"` gets logged.
- D: `ReferenceError`

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: A

Jest to moÅ¼liwe w JavaScript, poniewaÅ¼ funkcje sÄ… obiektami! (Wszystko oprÃ³cz typÃ³w prymitywnych jest obiektem)

Funkcja jest specjalnym rodzajem obiektu. Kod, ktÃ³ry sam piszesz, nie jest wÅ‚aÅ›ciwÄ… funkcjÄ…. Funkcja jest obiektem posiadajÄ…cym wÅ‚aÅ›ciwoÅ›Ä‡, ktÃ³ra jest wywoÅ‚ywalna.

</p>
</details>

---

###### 11. Jaki jest wynik?

```javascript
function Person(firstName, lastName) {
  this.firstName = firstName;
  this.lastName = lastName;
}

const member = new Person('Lydia', 'Hallie');
Person.getFullName = function() {
  return `${this.firstName} ${this.lastName}`;
};

console.log(member.getFullName());
```

- A: `TypeError`
- B: `SyntaxError`
- C: `Lydia Hallie`
- D: `undefined` `undefined`

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: A

W JavaScript funkcje sÄ… obiektami, wiÄ™c metoda `getFullName` jest dodawana do samego obiektu funkcji konstruktora. Dlatego moÅ¼emy wywoÅ‚aÄ‡ `Person.getFullName()`, ale `member.getFullName` zwraca bÅ‚Ä…d `TypeError`.

JeÅ›li chcesz, aby metoda byÅ‚a dostÄ™pna dla wszystkich instancji obiektÃ³w, musisz dodaÄ‡ jÄ… do wÅ‚aÅ›ciwoÅ›ci prototype:

```js
Person.prototype.getFullName = function() {
  return `${this.firstName} ${this.lastName}`;
};
```

</p>
</details>

---

###### 12. Jaki jest wynik?

```javascript
function Person(firstName, lastName) {
  this.firstName = firstName;
  this.lastName = lastName;
}

const lydia = new Person('Lydia', 'Hallie');
const sarah = Person('Sarah', 'Smith');

console.log(lydia);
console.log(sarah);
```

- A: `Person {firstName: "Lydia", lastName: "Hallie"}` and `undefined`
- B: `Person {firstName: "Lydia", lastName: "Hallie"}` and `Person {firstName: "Sarah", lastName: "Smith"}`
- C: `Person {firstName: "Lydia", lastName: "Hallie"}` and `{}`
- D: `Person {firstName: "Lydia", lastName: "Hallie"}` and `ReferenceError`

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: A

Dla `sarah`, nie uÅ¼yliÅ›my sÅ‚owa kluczowego `new`. Kiedy uÅ¼ywamy `new`, `this` odwoÅ‚uje siÄ™ do nowego pustego obiektu, ktÃ³ry tworzymy. Jednak jeÅ›li nie dodajemy `new`, `this` odwoÅ‚uje siÄ™ do **globalnego obiektu**!

MÃ³wiliÅ›my, Å¼e `this.firstName` rÃ³wna siÄ™ `"Sarah"`, a `this.lastName` rÃ³wna siÄ™ `"Smith"`. Czyli faktycznie zdefiniowaliÅ›my `global.firstName = 'Sarah'` i `global.lastName = 'Smith'`. `sarah` pozostaje `undefined`, poniewaÅ¼ nie zwracaliÅ›my Å¼adnej wartoÅ›ci z funkcji `Person`.

</p>
</details>

---

###### 13. Jakie sÄ… trzy fazy propagacji zdarzeÅ„?

- A: Target > Capturing > Bubbling
- B: Bubbling > Target > Capturing
- C: Target > Bubbling > Capturing
- D: Capturing > Target > Bubbling

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: D

W fazie **capturing (przechwytywanie)**, zdarzenie przechodzi przez elementy nadrzÄ™dne w doÅ‚ do elementu docelowego. NastÄ™pnie dociera do elementu **target (cel)** i rozpoczyna siÄ™ **bubbling (bÄ…belkowanie)**.

<img src="https://i.imgur.com/N18oRgd.png" width="200">

</p>
</details>

---

###### 14. Wszystkie obiekty majÄ… prototypy.

- A: true
- B: false

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: B

Wszystkie obiekty majÄ… prototypy, z wyjÄ…tkiem **obiektu bazowego**. Obiekt bazowy jest obiektem utworzonym przez uÅ¼ytkownika lub obiektem utworzonym przy uÅ¼yciu sÅ‚owa kluczowego `new`. Obiekt bazowy ma dostÄ™p do niektÃ³rych metod i wÅ‚aÅ›ciwoÅ›ci, takich jak `.toString`. Jest to powÃ³d, dla ktÃ³rego moÅ¼na uÅ¼ywaÄ‡ wbudowanych metod JavaScript! Wszystkie takie metody sÄ… dostÄ™pne w prototypie. ChociaÅ¼ JavaScript nie moÅ¼e znaleÅºÄ‡ ich bezpoÅ›rednio w twoim obiekcie, przechodzi w dÃ³Å‚ Å‚aÅ„cucha prototypÃ³w i je tam znajduje, co czyni je dostÄ™pnymi dla ciebie.

</p>
</details>

---

###### 15. Jaki jest wynik?

```javascript
function sum(a, b) {
  return a + b;
}

sum(1, '2');
```

- A: `NaN`
- B: `TypeError`
- C: `"12"`
- D: `3`

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: C

JavaScript jest jÄ™zykiem **dynamicznie typowanym**: nie okreÅ›lamy typÃ³w niektÃ³rych zmiennych. WartoÅ›ci mogÄ… byÄ‡ automatycznie konwertowane na inny typ bez wiedzy uÅ¼ytkownika, co nazywa siÄ™ _implicit type coercion_. **Koercja (Wymuszenie)** to konwersja z jednego typu na inny.

W tym przykÅ‚adzie JavaScript konwertuje liczbÄ™ `1` na string, aby funkcja miaÅ‚a sens i zwrÃ³ciÅ‚a wartoÅ›Ä‡. Podczas dodawania typu liczbowego (`1`) i typu Å‚aÅ„cuchowego (`'2'`), liczba traktowana jest jako string. MoÅ¼emy Å‚Ä…czyÄ‡ stringi takie jak `"Hello" + "World"`, wiÄ™c to co siÄ™ tutaj dzieje to `"1" + "2"`, ktÃ³re zwraca `"12"`.

</p>
</details>

---

###### 16. Jaki jest wynik?

```javascript
let number = 0;
console.log(number++);
console.log(++number);
console.log(number);
```

- A: `1` `1` `2`
- B: `1` `2` `2`
- C: `0` `2` `2`
- D: `0` `1` `2`

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: C

Operator jednoargumentowy **Postfix** `++`:

1. Zwraca wartoÅ›Ä‡ (ten zwraca `0`)
2. ZwiÄ™ksza wartoÅ›Ä‡ (liczba wynosi teraz `1`)

Operator jednoargumentowy **Prefix**  `++`:

1. ZwiÄ™ksza wartoÅ›Ä‡ (liczba wynosi teraz `2`)
2. Zwraca wartoÅ›Ä‡ (to zwraca `2`)

number zwraca `0 2 2`.

</p>
</details>

---

###### 17. Jaki jest wynik?

```javascript
function getPersonInfo(one, two, three) {
  console.log(one);
  console.log(two);
  console.log(three);
}

const person = 'Lydia';
const age = 21;

getPersonInfo`${person} is ${age} years old`;
```

- A: `"Lydia"` `21` `["", " is ", " years old"]`
- B: `["", " is ", " years old"]` `"Lydia"` `21`
- C: `"Lydia"` `["", " is ", " years old"]` `21`

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: B

W przypadku uÅ¼ycia `template strings`, wartoÅ›ciÄ… pierwszego argumentu jest zawsze tablica wartoÅ›ci Å‚aÅ„cuchowych (string). PozostaÅ‚e argumenty otrzymujÄ… wartoÅ›ci przekazanych wyraÅ¼eÅ„!

</p>
</details>

---

###### 18. Jaki jest wynik?

```javascript
function checkAge(data) {
  if (data === { age: 18 }) {
    console.log('You are an adult!');
  } else if (data == { age: 18 }) {
    console.log('You are still an adult.');
  } else {
    console.log(`Hmm.. You don't have an age I guess`);
  }
}

checkAge({ age: 18 });
```

- A: `You are an adult!`
- B: `You are still an adult.`
- C: `Hmm.. You don't have an age I guess`

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: C

Podczas testowania rÃ³wnoÅ›ci, liczby i ciÄ…gi znakÃ³w sÄ… porÃ³wnywane przez ich _wartoÅ›ci_, a obiekty sÄ… porÃ³wnywane przez ich _referencjÄ™_. JavaScript sprawdza, czy obiekty majÄ… odwoÅ‚anie do tej samej lokalizacji w pamiÄ™ci.

Dwa obiekty, ktÃ³re porÃ³wnujemy, nie majÄ… tej samej lokalizacji w pamiÄ™ci: obiekt, ktÃ³ry przekazujemy jako parametr, odwoÅ‚uje siÄ™ do innej lokalizacji w pamiÄ™ci niÅ¼ obiekt, ktÃ³rego uÅ¼yliÅ›my do sprawdzenia rÃ³wnoÅ›ci.

Dlatego teÅ¼ zarÃ³wno `{ age: 18 } == { age: 18 }` i `{ age: 18 } == { age: 18 }` zwracajÄ… `false`.

</p>
</details>

---

###### 19. Jaki jest wynik?

```javascript
function getAge(...args) {
  console.log(typeof args);
}

getAge(21);
```

- A: `"number"`
- B: `"array"`
- C: `"object"`
- D: `"NaN"`

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: C

Parametr reszty (`...args`) pozwala nam "zbieraÄ‡" wszystkie pozostaÅ‚e argumenty do tablicy. Tablica to obiekt, wiÄ™c `typeof args` zwraca `"object"`.

</p>
</details>

---

###### 20. Jaki jest wynik?

```javascript
function getAge() {
  'use strict';
  age = 21;
  console.log(age);
}

getAge();
```

- A: `21`
- B: `undefined`
- C: `ReferenceError`
- D: `TypeError`

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: C

DziÄ™ki `"use strict"` moÅ¼esz upewniÄ‡ siÄ™, Å¼e przypadkowo nie zadeklarujesz zmiennych globalnych. Nigdy nie zadeklarowaliÅ›my zmiennej `age`, a poniewaÅ¼ uÅ¼ywamy `"use strict"`, zostanie zgÅ‚oszony bÅ‚Ä…d referencji. GdybyÅ›my nie uÅ¼yli `"use strict"`, to by zadziaÅ‚aÅ‚o, poniewaÅ¼ wÅ‚aÅ›ciwoÅ›Ä‡ `age` zostaÅ‚aby dodana do obiektu globalnego.

</p>
</details>

---

###### 21. Jaka jest wartoÅ›Ä‡ `sum`?

```javascript
const sum = eval('10*10+5');
```

- A: `105`
- B: `"105"`
- C: `TypeError`
- D: `"10*10+5"`

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: A

`eval` oblicza kod, ktÃ³ry przekazywany jest jako ciÄ…g znakÃ³w. JeÅ›li jest to wyraÅ¼enie, tak jak w tym przypadku, oblicza ono wyraÅ¼enie. WyraÅ¼enie to `10 * 10 + 5`. Zwraca liczbÄ™ `105`.

</p>
</details>

---

###### 22. Jak dÅ‚ugo cool_secret jest dostÄ™pny?

```javascript
sessionStorage.setItem('cool_secret', 123);
```

- A: Dane nigdy nie zostanÄ… utracone.
- B: Gdy uÅ¼ytkownik zamyka kartÄ™.
- C: Gdy uÅ¼ytkownik zamyka caÅ‚y przeglÄ…darkÄ™, a nie tylko kartÄ™.
- D: Gdy uÅ¼ytkownik wyÅ‚Ä…cza swÃ³j komputer.

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: B

Dane przechowywane w `sessionStorage` sÄ… usuwane po zamkniÄ™ciu _zakÅ‚adki_.

GdybyÅ› uÅ¼yÅ‚ `localStorage`, dane pozostaÅ‚yby tam na zawsze, chyba Å¼e na przykÅ‚ad wywoÅ‚ano by `localStorage.clear()`.

</p>
</details>

---

###### 23. Jaki jest wynik?

```javascript
var num = 8;
var num = 10;

console.log(num);
```

- A: `8`
- B: `10`
- C: `SyntaxError`
- D: `ReferenceError`

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: B

Za pomocÄ… sÅ‚owa kluczowego `var` moÅ¼na zadeklarowaÄ‡ wiele zmiennych o tej samej nazwie. Zmienna bÄ™dzie wtedy przechowywaÄ‡ najnowszÄ… wartoÅ›Ä‡.

Nie moÅ¼na tego zrobiÄ‡ za pomocÄ… `let` lub `const`, poniewaÅ¼ sÄ… one blokowe.

</p>
</details>

---

###### 24. Jaki jest wynik?

```javascript
const obj = { 1: 'a', 2: 'b', 3: 'c' };
const set = new Set([1, 2, 3, 4, 5]);

obj.hasOwnProperty('1');
obj.hasOwnProperty(1);
set.has('1');
set.has(1);
```

- A: `false` `true` `false` `true`
- B: `false` `true` `true` `true`
- C: `true` `true` `false` `true`
- D: `true` `true` `true` `true`

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: C

Wszystkie klucze obiektÃ³w (z wyjÄ…tkiem symboli) sÄ… Å‚aÅ„cuchami znakÃ³w pod wzglÄ™dem samego obiektu, nawet jeÅ›li nie napiszesz ich samodzielnie jako Å‚aÅ„cucha znakÃ³w. Dlatego `obj.hasOwnProperty('1')` rÃ³wnieÅ¼ zwraca true.

Nie dziaÅ‚a to w ten sam sposÃ³b dla zbioru. W zbiorze nie ma klucza `'1'`:`set.has('1')`, dlatego zwraca wartoÅ›Ä‡ false. Zawiera on liczbÄ™ caÅ‚kowitÄ… `1`, `set.has(1)` zwraca wartoÅ›Ä‡ true.

</p>
</details>

---

###### 25. Jaki jest wynik?

```javascript
const obj = { a: 'one', b: 'two', a: 'three' };
console.log(obj);
```

- A: `{ a: "one", b: "two" }`
- B: `{ b: "two", a: "three" }`
- C: `{ a: "three", b: "two" }`
- D: `SyntaxError`

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: C

JeÅ›li masz dwa klucze o takiej samej nazwie, zostanie on zastÄ…piony. Nadal bÄ™dzie umieszczony na pierwszej pozycji, ale z ostatniÄ… zdefiniowanÄ… wartoÅ›ciÄ….

</p>
</details>

---

###### 26. Globalny kontekst wykonania JavaScript tworzy dwie rzeczy: obiekt globalny i sÅ‚owo kluczowe "this".

- A: true
- B: false
- C: it depends

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: A

Globalny kontekst wykonania jest dostÄ™pny wszÄ™dzie w kodzie.

</p>
</details>

---

###### 27. Jaki jest wynik?

```javascript
for (let i = 1; i < 5; i++) {
  if (i === 3) continue;
  console.log(i);
}
```

- A: `1` `2`
- B: `1` `2` `3`
- C: `1` `2` `4`
- D: `1` `3` `4`

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: C

Instrukcja `continue` pomija iteracjÄ™, jeÅ›li okreÅ›lony warunek zwrÃ³ci `true`.

</p>
</details>

---

###### 28. Jaki jest wynik?

```javascript
String.prototype.giveLydiaPizza = () => {
  return 'Just give Lydia pizza already!';
};

const name = 'Lydia';

console.log(name.giveLydiaPizza())
```

- A: `"Just give Lydia pizza already!"`
- B: `TypeError: not a function`
- C: `SyntaxError`
- D: `undefined`

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: A

`String` jest wbudowanym konstruktorem, do ktÃ³rego moÅ¼emy dodawaÄ‡ wÅ‚aÅ›ciwoÅ›ci. Dodana zostaÅ‚a metoda do jego prototypu. Prymitywne ciÄ…gi znakÃ³w sÄ… automatycznie konwertowane na obiekt typu string, generowany przez funkcjÄ™ prototypu ciÄ…gu znakÃ³w. Tak wiÄ™c wszystkie ciÄ…gi (obiekty typu string) majÄ… dostÄ™p do tej metody!

</p>
</details>

---

###### 29. Jaki jest wynik?

```javascript
const a = {};
const b = { key: 'b' };
const c = { key: 'c' };

a[b] = 123;
a[c] = 456;

console.log(a[b]);
```

- A: `123`
- B: `456`
- C: `undefined`
- D: `ReferenceError`

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: B

Klucze obiektÃ³w sÄ… automatycznie konwertowane na ciÄ…gi znakÃ³w. PrÃ³bujemy ustawiÄ‡ obiekt jako klucz do obiektu `a`, z wartoÅ›ciÄ… `123`.

JednakÅ¼e, kiedy stringujemy obiekt, staje siÄ™ on `"[obiekt Object]"`. MÃ³wimy wiÄ™c, Å¼e `a["[obiekt Object]"] = 123`. NastÄ™pnie prÃ³bujemy zrobiÄ‡ to samo. `c` jest kolejnym obiektem, ktÃ³ry niejawnie stringujemy. Zatem `a["[obiekt Object]"] = 456`.

NastÄ™pnie wyÅ›wietlamy w konsoli `a[b]`, co w rzeczywistoÅ›ci jest `a["[obiekt Object]"]`, ustawiony wczeÅ›niej na `456`, wiÄ™c zwraca `456`.

</p>
</details>

---

###### 30. Jaki jest wynik?

```javascript
const foo = () => console.log('First');
const bar = () => setTimeout(() => console.log('Second'));
const baz = () => console.log('Third');

bar();
foo();
baz();
```

- A: `First` `Second` `Third`
- B: `First` `Third` `Second`
- C: `Second` `First` `Third`
- D: `Second` `Third` `First`

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: B

Mamy funkcjÄ™ `setTimeout` i wywoÅ‚aliÅ›my jÄ… jako pierwszÄ…. ZostaÅ‚a jednak wyÅ›wietlona jako ostatnia.

Dzieje siÄ™ tak, poniewaÅ¼ w przeglÄ…darkach mamy nie tylko silnik wykonawczy, ale takÅ¼e coÅ›, co nazywa siÄ™ `WebAPI`. Interfejs `WebAPI` daje nam na poczÄ…tek funkcjÄ™ `setTimeout`.

Po przesÅ‚aniu _callback_ do WebAPI, sama funkcja `setTimeout` (ale nie callback!) jest usuwana ze stosu.

<img src="https://i.imgur.com/X5wsHOg.png" width="200">

Teraz, `foo` jest wywoÅ‚ywane, a `"First"` jest wyÅ›wietlane.

<img src="https://i.imgur.com/Pvc0dGq.png" width="200">

`foo` jest zdejmowane ze stosu, a `baz` jest wywoÅ‚ywane. "Third" zostaje wyÅ›wietlony.

<img src="https://i.imgur.com/WhA2bCP.png" width="200">

WebAPI nie moÅ¼e dodawaÄ‡ rzeczy do stosu, gdy jest gotowy. Zamiast tego przesuwa funkcjÄ™ zwrotnÄ… do czegoÅ› zwanego _kolejkÄ…_.

<img src="https://i.imgur.com/NSnDZmU.png" width="200">

W tym miejscu zaczyna dziaÅ‚aÄ‡ pÄ™tla zdarzeÅ„. **PÄ™tla zdarzeÅ„** patrzy na stos i kolejkÄ™ zadaÅ„. JeÅ›li stos jest pusty, pobiera pierwszÄ… rzecz z kolejki i przesuwa jÄ… na stos.

<img src="https://i.imgur.com/uyiScAI.png" width="200">

`bar` zostaje wywoÅ‚any, `"Second"` zostaje wyÅ›wietlony i zdjÄ™ty ze stosu.

</p>
</details>

---

###### 31. Co zostanie wyÅ›wietlone w konsoli po klikniÄ™ciu przycisku?

```html
<div onclick="console.log('first div')">
  <div onclick="console.log('second div')">
    <button onclick="console.log('button')">
      Click!
    </button>
  </div>
</div>
```

- A: ZewnÄ™trzny `div`
- B: WewnÄ™trzny `div`
- C: `button`
- D: Tablica wszystkich zagnieÅ¼dÅ¼onych elementÃ³w.

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: C

NajgÅ‚Ä™biej zagnieÅ¼dÅ¼ony element, ktÃ³ry spowodowaÅ‚ zdarzenie jest celem zdarzenia. MoÅ¼esz zatrzymaÄ‡ bÄ…belkowanie poprzez `event.stopPropagation`

</p>
</details>

---

###### 32. Co zostanie wyÅ›wietlone w konsoli po klikniÄ™ciu akapitu?

```html
<div onclick="console.log('div')">
  <p onclick="console.log('p')">
    Click here!
  </p>
</div>
```

- A: `p` `div`
- B: `div` `p`
- C: `p`
- D: `div`

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: A

JeÅ›li klikniemy `p`, zobaczymy dwa logi: `p` i `div`. Podczas propagacji zdarzeÅ„ istniejÄ… 3 fazy: przechwytywanie, cel i bÄ…belkowanie (capturing, target, and bubbling). DomyÅ›lnie, event handlery sÄ… wykonywane w fazie bÄ…belkowania (chyba Å¼e ustawisz `useCapture` na `true`). Przebiega ona od najgÅ‚Ä™biej zagnieÅ¼dÅ¼onego elementu na zewnÄ…trz.

</p>
</details>

---

###### 33. Jaki jest wynik?

```javascript
const person = { name: 'Lydia' };

function sayHi(age) {
  return `${this.name} is ${age}`;
}

console.log(sayHi.call(person, 21));
console.log(sayHi.bind(person, 21));
```

- A: `undefined is 21` `Lydia is 21`
- B: `function` `function`
- C: `Lydia is 21` `Lydia is 21`
- D: `Lydia is 21` `function`

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: D

W obu przypadkach moÅ¼emy przekazaÄ‡ obiekt, do ktÃ³rego ma siÄ™ odnosiÄ‡ sÅ‚owo kluczowe `this`. JednakÅ¼e, `.call` jest _wykonywane natychmiast_!

`.bind.` zwraca _kopiÄ™_ funkcji, ale z powiÄ…zanym kontekstem! Nie jest ona wykonywana natychmiast.

</p>
</details>

---

###### 34. Jaki jest wynik?

```javascript
function sayHi() {
  return (() => 0)();
}

console.log(typeof sayHi());
```

- A: `"object"`
- B: `"number"`
- C: `"function"`
- D: `"undefined"`

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: B

Funkcja `sayHi` zwraca zwrÃ³conÄ… wartoÅ›Ä‡ natychmiast wywoÅ‚anego wyraÅ¼enia funkcyjnego (IIFE). Ta funkcja zwrÃ³ciÅ‚a wartoÅ›Ä‡ `0`, ktÃ³ra jest typu `"number"`.
	
FYI: `typeof` moÅ¼e zwrÃ³ciÄ‡ nastÄ™pujÄ…cÄ… listÄ™ wartoÅ›ci: `undefined`, `boolean`, `number`, `bigint`, `string`, `symbol`, `function` i `object`. ZauwaÅ¼, Å¼e `typeof null` zwraca `"object"`.

</p>
</details>

---

###### 35. KtÃ³re z tych wartoÅ›ci sÄ… faÅ‚szywe?

```javascript
0;
new Number(0);
('');
(' ');
new Boolean(false);
undefined;
```

- A: `0`, `''`, `undefined`
- B: `0`, `new Number(0)`, `''`, `new Boolean(false)`, `undefined`
- C: `0`, `''`, `new Boolean(false)`, `undefined`
- D: Wszystkie sÄ… faÅ‚szywe

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: A

Istnieje 8 faÅ‚szywych wartoÅ›ci:

- `undefined`
- `null`
- `NaN`
- `false`
- `''` (pusty ciÄ…g)
- `0`
- `-0`
- `0n` (BigInt(0))

Konstruktory funkcji, takie jak `new Number` i `new Boolean` sÄ… prawdziwe.

</p>
</details>

---

###### 36. Jaki jest wynik?

```javascript
console.log(typeof typeof 1);
```

- A: `"number"`
- B: `"string"`
- C: `"object"`
- D: `"undefined"`

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: B

`typeof 1` zwraca `"number"`.
`typeof "number"` zwraca `"string"`.

</p>
</details>

---

###### 37. Jaki jest wynik?

```javascript
const numbers = [1, 2, 3];
numbers[10] = 11;
console.log(numbers);
```

- A: `[1, 2, 3, null x 7, 11]`
- B: `[1, 2, 3, 11]`
- C: `[1, 2, 3, empty x 7, 11]`
- D: `SyntaxError`

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: C

Po ustawieniu wartoÅ›ci elementu w tablicy, ktÃ³ra przekracza dÅ‚ugoÅ›Ä‡ tablicy, JavaScript tworzy coÅ›, co nazywa siÄ™ "pustymi slotami". W rzeczywistoÅ›ci majÄ… one wartoÅ›Ä‡ `undefined`, ale zobaczysz coÅ› takiego jak:

`[1, 2, 3, puste x 7, 11]`.

w zaleÅ¼noÅ›ci od tego, gdzie go uruchomisz (jest inny dla kaÅ¼dej przeglÄ…darki, node itp.).

</p>
</details>

---

###### 38. Jaki jest wynik?

```javascript
(() => {
  let x, y;
  try {
    throw new Error();
  } catch (x) {
    (x = 1), (y = 2);
    console.log(x);
  }
  console.log(x);
  console.log(y);
})();
```

- A: `1` `undefined` `2`
- B: `undefined` `undefined` `undefined`
- C: `1` `1` `2`
- D: `1` `undefined` `undefined`

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: A

Blok `catch` otrzymuje argument `x`. Nie jest to ten sam `x` co zmienna, gdy przekazujemy argumenty. Ta zmienna `x` jest blokowa.

PÃ³Åºniej, ustawiamy tÄ™ blokowÄ… zmiennÄ… rÃ³wnÄ… `1` i ustawiamy wartoÅ›Ä‡ zmiennej `y`. Teraz wyÅ›wietlamy w konsoli zmiennÄ… blokowÄ… `x`, ktÃ³ra jest rÃ³wna `1`.

Poza blokiem `catch`, `x` jest wciÄ…Å¼ `undefined`, a `y` wynosi `2`. Gdy chcemy wykonaÄ‡ `console.log(x)` poza blokiem `catch`, zwraca on `undefined`, a `y` zwraca `2`.

</p>
</details>

---

###### 39. Wszystko w JavaScript jest...

- A: prymitywem lub obiektem
- B: funkcjÄ… lub obiektem
- C: podchwytliwe pytanie! tylko obiektem
- D: numerem lub obiektem

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: A

JavaScript ma tylko prymitywne typy i obiekty.

Typy prymitywne to `boolean`, `null`, `undefined`, `bigint`, `number`, `string` i `symbol`.

To, co odrÃ³Å¼nia prymityw od obiektu, to fakt, Å¼e prymitywy nie majÄ… Å¼adnych wÅ‚aÅ›ciwoÅ›ci ani metod; zauwaÅ¼ysz jednak, Å¼e `'foo'.toUpperCase()` wylicza `'FOO'` i nie powoduje `TypeError`. Dzieje siÄ™ tak dlatego, Å¼e gdy prÃ³bujesz uzyskaÄ‡ dostÄ™p do wÅ‚aÅ›ciwoÅ›ci lub metody na prymitywie takim jak ciÄ…g znakÃ³w, JavaScript niejawnie opakuje prymitywny typ za pomocÄ… jednej z klas opakowujÄ…cych, tj. `String`, a nastÄ™pnie natychmiast odrzuci opakowanie po ocenie wyraÅ¼enia. Wszystkie prymitywy z wyjÄ…tkiem `null` i `undefined` wykazujÄ… to zachowanie.

</p>
</details>

---

###### 40. Jaki jest wynik?

```javascript
[[0, 1], [2, 3]].reduce(
  (acc, cur) => {
    return acc.concat(cur);
  },
  [1, 2],
);
```

- A: `[0, 1, 2, 3, 1, 2]`
- B: `[6, 1, 2]`
- C: `[1, 2, 0, 1, 2, 3]`
- D: `[1, 2, 6]`

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: C

`[1, 2]` jest naszÄ… wartoÅ›ciÄ… poczÄ…tkowÄ…. Jest to wartoÅ›Ä‡, z ktÃ³rÄ… zaczynamy i wartoÅ›Ä‡ pierwszego `acc`.Podczas pierwszej rundy, `acc` to `[1, 2]`, a `cur` to `[0, 1]`.ÅÄ…czymy je, co daje `[1, 2, 0, 1]`.

NastÄ™pnie `[1, 2, 0, 1]` to `acc`, a `[2, 3]` to `cur`. ÅÄ…czymy je i otrzymujemy `[1, 2, 0, 1, 2, 3]`.

</p>
</details>

---

###### 41. Jaki jest wynik?

```javascript
!!null;
!!'';
!!1;
```

- A: `false` `true` `false`
- B: `false` `false` `true`
- C: `false` `true` `true`
- D: `true` `true` `false`

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: B

`null` jest faÅ‚szywe. `!null` zwraca `true`. `!true` zwraca `false`.

`""` jest faÅ‚szywe. `!""` zwraca `true`. `!true` zwraca `false`.

`1` jest prawdziwe. `!1` zwraca `false`. `!false` zwraca `true`.

</p>
</details>

---

###### 42. Co zwraca metoda `setInterval` w przeglÄ…darce?

```javascript
setInterval(() => console.log('Hi'), 1000);
```

- A: unikalny identyfikator
- B: okreÅ›lona iloÅ›Ä‡ milisekund
- C: przekazana funkcja
- D: `undefined`

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: A

Zwraca unikalny identyfikator. Ten identyfikator moÅ¼e byÄ‡ uÅ¼yty do wyczyszczenia tego interwaÅ‚u za pomocÄ… funkcji `clearInterval()`.

</p>
</details>

---

###### 43. Co to zwrÃ³ci?

```javascript
[...'Lydia'];
```

- A: `["L", "y", "d", "i", "a"]`
- B: `["Lydia"]`
- C: `[[], "Lydia"]`
- D: `[["L", "y", "d", "i", "a"]]`

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: A

ÅaÅ„cuch znakÃ³w jest iterowalny. Operator spread odwzorowuje kaÅ¼dy znak iterable na jeden element.

</p>
</details>

---

###### 44. Jaki jest wynik?

```javascript
function* generator(i) {
  yield i;
  yield i * 2;
}

const gen = generator(10);

console.log(gen.next().value);
console.log(gen.next().value);
```

- A: `[0, 10], [10, 20]`
- B: `20, 20`
- C: `10, 20`
- D: `0, 10 and 10, 20`

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: C

ZwykÅ‚e funkcje nie mogÄ… zostaÄ‡ zatrzymane w poÅ‚owie wywoÅ‚ywania. Jednak funkcja generatora moÅ¼e zostaÄ‡ "zatrzymana" w poÅ‚owie, a nastÄ™pnie kontynuowaÄ‡ od miejsca, w ktÃ³rym siÄ™ zatrzymaÅ‚a. Za kaÅ¼dym razem, gdy funkcja generujÄ…ca napotka sÅ‚owo kluczowe `yield`, funkcja zwraca wartoÅ›Ä‡ okreÅ›lonÄ… po nim.

Najpierw inicjalizujemy funkcjÄ™ generatora z `i` rÃ³wnym `10`. WywoÅ‚ujemy funkcjÄ™ generatora za pomocÄ… metody `next()`. Przy pierwszym wywoÅ‚aniu funkcji generatora, `i` jest rÃ³wne `10`. Funkcja napotyka pierwsze sÅ‚owo kluczowe `yield`: zwraca wartoÅ›Ä‡ `i`. Generator jest teraz "wstrzymany", a wartoÅ›Ä‡ `10` zostaje zarejestrowana.

NastÄ™pnie ponownie wywoÅ‚ujemy funkcjÄ™ za pomocÄ… metody `next()`. Kontynuuje ona tam, gdzie zatrzymaÅ‚a siÄ™ poprzednio, wciÄ…Å¼ z `i` rÃ³wnym `10`. Teraz napotyka nastÄ™pne sÅ‚owo kluczowe `yield` i zwraca `i * 2`. `i` jest rÃ³wne `10`, wiÄ™c zwraca `10 * 2`, czyli `20`. Wynikiem jest `10, 20`.

</p>
</details>

---

###### 45. Co to zwrÃ³ci?

```javascript
const firstPromise = new Promise((res, rej) => {
  setTimeout(res, 500, 'one');
});

const secondPromise = new Promise((res, rej) => {
  setTimeout(res, 100, 'two');
});

Promise.race([firstPromise, secondPromise]).then(res => console.log(res));
```

- A: `"one"`
- B: `"two"`
- C: `"two" "one"`
- D: `"one" "two"`

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: B

Kiedy przekazujemy wiele 'promise' do metody `Promise.race`, rozwiÄ…zuje ona/odrzuca _pierwszÄ…_ 'promise'. Do metody `setTimeout` przekazujemy timer: 500ms dla `firstPromise` i 100ms dla `secondPromise`. Oznacza to, Å¼e `secondPromise` zostanie rozwiÄ…zana jako pierwsza z wartoÅ›ciÄ… `'two'`. `res` przechowuje teraz wartoÅ›Ä‡ `'two'`, ktÃ³ra jest wyÅ›wietlona w konsoli.

</p>
</details>

---

###### 46. Jaki jest wynik?

```javascript
let person = { name: 'Lydia' };
const members = [person];
person = null;

console.log(members);
```

- A: `null`
- B: `[null]`
- C: `[{}]`
- D: `[{ name: "Lydia" }]`

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: D

Najpierw deklarujemy zmiennÄ… `person` z wartoÅ›ciÄ… obiektu, ktÃ³ry ma wÅ‚aÅ›ciwoÅ›Ä‡ `name`.

<img src="https://i.imgur.com/TML1MbS.png" width="200">

NastÄ™pnie deklarujemy zmiennÄ… o nazwie `members`. Ustawiamy pierwszy element tej tablicy rÃ³wny wartoÅ›ci zmiennej `person`. Obiekty oddziaÅ‚ujÄ… na siebie poprzez _referencjÄ™_, gdy ustawiamy je rÃ³wne sobie. Kiedy przypisujesz referencjÄ™ z jednej zmiennej do drugiej, tworzysz _kopiÄ™_ tej referencji. (ZauwaÅ¼, Å¼e nie majÄ… one _tej samej_ referencji!).

<img src="https://i.imgur.com/FSG5K3F.png" width="300">

NastÄ™pnie ustawiamy zmiennÄ… `person` rÃ³wnÄ… `null`.

<img src="https://i.imgur.com/sYjcsMT.png" width="300">

Modyfikujemy tylko wartoÅ›Ä‡ zmiennej `person`, a nie pierwszy element w tablicy, poniewaÅ¼ ten element ma innÄ… (skopiowanÄ…) referencjÄ™ do obiektu. Pierwszy element w `members` wciÄ…Å¼ posiada referencjÄ™ do oryginalnego obiektu. Kiedy wyÅ›wietlamy tablicÄ™ `members`, pierwszy element nadal przechowuje wartoÅ›Ä‡ obiektu, ktÃ³ry jest wyÅ›wietlany.

</p>
</details>

---

###### 47. Jaki jest wynik?

```javascript
const person = {
  name: 'Lydia',
  age: 21,
};

for (const item in person) {
  console.log(item);
}
```

- A: `{ name: "Lydia" }, { age: 21 }`
- B: `"name", "age"`
- C: `"Lydia", 21`
- D: `["name", "Lydia"], ["age", 21]`

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: B

Za pomocÄ… pÄ™tli `for-in` moÅ¼emy iterowaÄ‡ po kluczach obiektÃ³w, w tym przypadku `name` i `age`. Klucze obiektÃ³w sÄ… Å‚aÅ„cuchami (jeÅ›li nie sÄ… symbolami). W kaÅ¼dej pÄ™tli ustawiamy wartoÅ›Ä‡ `item` rÃ³wnÄ… bieÅ¼Ä…cemu kluczowi, ktÃ³ry iterujemy. Najpierw `item` jest rÃ³wny `name`. NastÄ™pnie, `item` jest rÃ³wny `age`.

</p>
</details>

---

###### 48. Jaki jest wynik?

```javascript
console.log(3 + 4 + '5');
```

- A: `"345"`
- B: `"75"`
- C: `12`
- D: `"12"`

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: B

AsocjatywnoÅ›Ä‡ operatorÃ³w to kolejnoÅ›Ä‡, w jakiej kompilator ocenia wyraÅ¼enia, od lewej do prawej lub od prawej do lewej. Dzieje siÄ™ tak tylko wtedy, gdy wszystkie operatory majÄ… _takie samo_ pierwszeÅ„stwo. Mamy tylko jeden typ operatora: `+`. Dla dodawania, asocjatywnoÅ›Ä‡ jest od lewej do prawej.

`3 + 4` jest obliczane jako pierwsze. Wynikiem jest liczba `7`.

`7 + '5'` skutkuje `"75"` z powodu przymusu. JavaScript konwertuje liczbÄ™ `7` na ciÄ…g znakÃ³w, patrz pytanie 15. MoÅ¼emy poÅ‚Ä…czyÄ‡ dwa ciÄ…gi znakÃ³w za pomocÄ… operatora `+`. "7" + "5"` daje w wyniku "75"`.

</p>
</details>

---

###### 49. Jaka jest wartoÅ›Ä‡ `num`?

```javascript
const num = parseInt('7*6', 10);
```

- A: `42`
- B: `"42"`
- C: `7`
- D: `NaN`

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: C

Zwracana jest tylko pierwsza liczba w Å‚aÅ„cuchu. W oparciu o _radix_ (drugi argument w celu okreÅ›lenia typu liczby, ktÃ³rÄ… chcemy przetworzyÄ‡: podstawa 10, szesnastkowy, Ã³semkowy, binarny itp.), `parseInt` sprawdza, czy znaki w Å‚aÅ„cuchu sÄ… prawidÅ‚owe. Gdy napotka znak, ktÃ³ry nie jest prawidÅ‚owÄ… liczbÄ… w radix, zatrzymuje parsowanie i ignoruje nastÄ™pujÄ…ce znaki.

`*` nie jest prawidÅ‚owÄ… liczbÄ…. Przetwarza tylko `"7"` na dziesiÄ™tne `7`. `num` posiada teraz wartoÅ›Ä‡ `7`.

</p>
</details>

---

###### 50. Jaki jest wynik?

```javascript
[1, 2, 3].map(num => {
  if (typeof num === 'number') return;
  return num * 2;
});
```

- A: `[]`
- B: `[null, null, null]`
- C: `[undefined, undefined, undefined]`
- D: `[ 3 x empty ]`

<details><summary><b>OdpowiedÅº</b></summary>
<p>

#### OdpowiedÅº: C

Podczas mapowania tablicy, wartoÅ›Ä‡ `num` jest rÃ³wna elementowi, nad ktÃ³rym aktualnie wykonywana jest pÄ™tla. W tym przypadku elementami sÄ… liczby, wiÄ™c warunek instrukcji if `typeof num == "number"` zwraca `true`. Funkcja map tworzy nowÄ… tablicÄ™ i wstawia do niej wartoÅ›ci zwrÃ³cone przez funkcjÄ™.

Nie zwracamy jednak Å¼adnej wartoÅ›ci. Gdy nie zwracamy wartoÅ›ci z funkcji, funkcja zwraca `undefined`. Dla kaÅ¼dego elementu w tablicy wywoÅ‚ywany jest blok funkcji, wiÄ™c dla kaÅ¼dego elementu zwracamy `undefined`.

</p>
</details>