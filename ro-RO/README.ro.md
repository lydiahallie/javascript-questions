<div align="center">
  <img height="60" src="https://img.icons8.com/color/344/javascript.png">
  <h1>ÃntrebÄƒri JavaScript</h1>

---

<span>Postez Ã®ntrebÄƒri JavaScript cu opÈ›iuni multiple pe [Instagram](https://www.instagram.com/theavocoder) **stories**, pe care le voi posta È™i aici! Ultima actualizare: <a href=#20200612><b>12 Iunie</b></a>

De la nivel de bazÄƒ la avansat: testeazÄƒ cÃ¢t de bine cunoÈ™ti JavaScript, reÃ®mprospÄƒteazÄƒ-È›i puÈ›in cunoÈ™tinÈ›ele sau pregÄƒteÈ™te-te pentru interviul tÄƒu de codare! :muscle: :rocket: Actualizez acest depozit Ã®n mod regulat cu Ã®ntrebÄƒri noi. Am adÄƒugat rÄƒspunsurile Ã®n **secÈ›iunile restrÃ¢nse** de sub Ã®ntrebÄƒri, pur È™i simplu dÄƒ clic pe ele pentru a le extinde. Este doar pentru distracÈ›ie, mult noroc! :heart:</span>

Nu ezita sÄƒ mÄƒ contactezi! ğŸ˜Š <br />
<a href="https://www.instagram.com/theavocoder">Instagram</a> || <a href="https://www.twitter.com/lydiahallie">Twitter</a> || <a href="https://www.linkedin.com/in/lydia-hallie">LinkedIn</a> || <a href="https://www.lydiahallie.dev">Blog</a>

</div>

| Simte-te liber sÄƒ le foloseÈ™ti Ã®ntr-un proiect! ğŸ˜ƒ AÈ™ aprecia _cu adevÄƒrat_ o referinÈ›Äƒ la acest depozit, eu creez Ã®ntrebÄƒrile È™i explicaÈ›iile (da, sunt tristÄƒ lol) È™i comunitatea mÄƒ ajutÄƒ foarte mult sÄƒ Ã®l menÈ›in È™i sÄƒ Ã®l Ã®mbunÄƒtÄƒÈ›esc! ğŸ’ªğŸ¼ MulÈ›umesc È™i distracÈ›ie plÄƒcutÄƒ! |
|---|

---

<details><summary><b> Vezi 20 de traduceri disponibile ğŸ‡¸ğŸ‡¦ğŸ‡ªğŸ‡¬ğŸ‡§ğŸ‡¦ğŸ‡©ğŸ‡ªğŸ‡ªğŸ‡¸ğŸ‡«ğŸ‡·ğŸ‡®ğŸ‡©ğŸ‡¯ğŸ‡µğŸ‡°ğŸ‡·ğŸ‡³ğŸ‡±ğŸ‡§ğŸ‡·ğŸ‡·ğŸ‡ºğŸ‡¹ğŸ‡­ğŸ‡¹ğŸ‡·ğŸ‡ºğŸ‡¦ğŸ‡»ğŸ‡³ğŸ‡¨ğŸ‡³ğŸ‡¹ğŸ‡¼ğŸ‡½ğŸ‡°</b></summary>
<p>

- [ğŸ‡¸ğŸ‡¦ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©](./ar-AR/README_AR.md)
- [ğŸ‡ªğŸ‡¬ Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø§Ù…ÙŠØ©](./ar-EG/README_ar-EG.md)
- [ğŸ‡§ğŸ‡¦ Bosanski](./bs-BS/README-bs_BS.md)
- [ğŸ‡©ğŸ‡ª Deutsch](./de-DE/README.md)
- [ğŸ‡ªğŸ‡¸ EspaÃ±ol](./es-ES/README-ES.md)
- [ğŸ‡«ğŸ‡· FranÃ§ais](./fr-FR/README_fr-FR.md)
- [ğŸ‡®ğŸ‡© Indonesia](./id-ID/README.md)
- [ğŸ‡®ğŸ‡¹ Italiano](./it-IT/README.md)
- [ğŸ‡¯ğŸ‡µ æ—¥æœ¬èª](./ja-JA/README-ja_JA.md)
- [ğŸ‡°ğŸ‡· í•œêµ­ì–´](./ko-KR/README-ko_KR.md)
- [ğŸ‡³ğŸ‡± Nederlands](./nl-NL/README.md)
- [ğŸ‡µğŸ‡± Polski](./pl-PL/README.md)
- [ğŸ‡§ğŸ‡· PortuguÃªs Brasil](./pt-BR/README_pt_BR.md)
- [ğŸ‡·ğŸ‡º Ğ ÑƒÑÑĞºĞ¸Ğ¹](./ru-RU/README.md)
- [ğŸ‡½ğŸ‡° Shqip](./sq-KS/README_sq_KS.md)
- [ğŸ‡¹ğŸ‡­ à¹„à¸—à¸¢](./th-TH/README-th_TH.md)
- [ğŸ‡¹ğŸ‡· TÃ¼rkÃ§e](./tr-TR/README-tr_TR.md)
- [ğŸ‡ºğŸ‡¦ Ğ£ĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°](./uk-UA/README.md)
- [ğŸ‡»ğŸ‡³ Tiáº¿ng Viá»‡t](./vi-VI/README-vi.md)
- [ğŸ‡¨ğŸ‡³ ç®€ä½“ä¸­æ–‡](./zh-CN/README-zh_CN.md)
- [ğŸ‡¹ğŸ‡¼ ç¹é«”ä¸­æ–‡](./zh-TW/README_zh-TW.md)

</p>
</details>

---

###### 1. Care este rezultatul?

```javascript
function sayHi() {
  console.log(name);
  console.log(age);
  var name = 'Lydia';
  let age = 21;
}

sayHi();
```

- A: `Lydia` È™i `undefined`
- B: `Lydia` È™i `ReferenceError`
- C: `ReferenceError` È™i `21`
- D: `undefined` È™i `ReferenceError`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: D

Ãn interiorul funcÈ›iei, mai Ã®ntÃ¢i declarÄƒm variabila `name` cu cuvÃ¢ntul cheie `var`. Acest lucru Ã®nseamnÄƒ cÄƒ variabila este hoisted (spaÈ›iul de memorie este configurat Ã®n faza de creare) cu valoarea implicitÄƒ `undefined`, pÃ¢nÄƒ cÃ¢nd ajungem efectiv la linia Ã®n care definim variabila. Nu am definit Ã®ncÄƒ variabila pe linia Ã®n care Ã®ncercÄƒm sÄƒ Ã®nregistrÄƒm variabila `name`, aÈ™a cÄƒ aceasta pÄƒstreazÄƒ Ã®ncÄƒ valoarea `undefined`.

Variabilele create cu cuvÃ¢ntul cheie `let` (È™i `const`) sunt hoisted, dar, spre deosebire de `var`, nu sunt <i>iniÈ›ializate</i>. Acestea nu sunt accesibile Ã®nainte de linia Ã®n care le declarÄƒm (initializÄƒm). Aceasta se numeÈ™te zona moartÄƒ temporalÄƒ (temporal dead zone). Atunci cÃ¢nd Ã®ncercÄƒm sÄƒ accesÄƒm variabilele Ã®nainte de a fi declarate, JavaScript aruncÄƒ o excepÈ›ie de tip `ReferenceError`.

</p>
</details>

---

###### 2. Care este rezultatul?

```javascript
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 1);
}

for (let i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 1);
}
```

- A: `0 1 2` È™i `0 1 2`
- B: `0 1 2` È™i `3 3 3`
- C: `3 3 3` È™i `0 1 2`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: C

DatoritÄƒ cozii de evenimente din JavaScript, funcÈ›ia de callback `setTimeout` este apelatÄƒ _dupÄƒ_ ce bucla a fost executatÄƒ. Deoarece variabila `i` din prima buclÄƒ a fost declaratÄƒ folosind cuvÃ¢ntul cheie `var`, aceastÄƒ valoare a fost globalÄƒ. Ãn timpul buclei, am incrementat valoarea lui `i` cu `1` de fiecare datÄƒ, folosind operatorul unary `++`. PÃ¢nÄƒ cÃ¢nd funcÈ›ia de callback `setTimeout` a fost invocatÄƒ, `i` era egal cu `3` Ã®n primul exemplu.

Ãn cea de-a doua buclÄƒ, variabila `i` a fost declaratÄƒ folosind cuvÃ¢ntul cheie `let`: variabilele declarate cu cuvÃ¢ntul cheie `let` (È™i `const`) sunt cu scop la nivel de bloc (un bloc este orice Ã®ntre `{ }`). Ãn fiecare iteraÈ›ie, `i` va avea o valoare nouÄƒ, iar fiecare valoare este Ã®n cadrul buclei.

</p>
</details>

---

###### 3. Care este rezultatul?

```javascript
const shape = {
  radius: 10,
  diameter() {
    return this.radius * 2;
  },
  perimeter: () => 2 * Math.PI * this.radius,
};

console.log(shape.diameter());
console.log(shape.perimeter());
```

- A: `20` È™i `62.83185307179586`
- B: `20` È™i `NaN`
- C: `20` È™i `63`
- D: `NaN` È™i `63`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: B

ReÈ›ineÈ›i cÄƒ valoarea lui `diameter` este o funcÈ›ie obiÈ™nuitÄƒ, Ã®n timp ce valoarea lui `perimeter` este o funcÈ›ie arrow.

Cu funcÈ›iile arrow, cuvÃ¢ntul cheie `this` se referÄƒ la contextul sÄƒu curent de Ã®ncadrare, spre deosebire de funcÈ›iile obiÈ™nuite! Acest lucru Ã®nseamnÄƒ cÄƒ atunci cÃ¢nd apelÄƒm `perimeter`, acesta nu se referÄƒ la obiectul formei, ci la Ã®ncadrarea sa curentÄƒ (de exemplu, fereastra).

Nu existÄƒ nicio valoare `radius` pe acel obiect, ceea ce returneazÄƒ `NaN`.

</p>
</details>

---

###### 4. Care este rezultatul?

```javascript
+true;
!'Lydia';
```

- A: `1` È™i `false`
- B: `false` È™i `NaN`
- C: `false` È™i `false`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: A

Operatorul unary plus Ã®ncearcÄƒ sÄƒ converteascÄƒ un operand Ã®ntr-un numÄƒr. `true` este `1`, È™i `false` este `0`.

È˜irul de caractere `'Lydia'` este o valoare adevÄƒratÄƒ. Ceea ce Ã®ntrebÄƒm de fapt, este "este aceastÄƒ valoare adevÄƒratÄƒ falsÄƒ?". Acest lucru returneazÄƒ `false`.

</p>
</details>

---

###### 5. Care este rezultatul?

```javascript
const bird = {
  size: 'small',
};

const mouse = {
  name: 'Mickey',
  small: true,
};
```

- A: `mouse.bird.size` nu este valid
- B: `mouse[bird.size]` nu este valid
- C: `mouse[bird["size"]]` nu este valid
- D: Toate sunt valide

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: A

Ãn JavaScript, toate cheile obiectelor sunt È™iruri de caractere (cu excepÈ›ia simbolurilor). Chiar dacÄƒ nu le _tipizÄƒm_ ca È™iruri de caractere, ele sunt Ã®ntotdeauna convertite Ã®n È™iruri de caractere Ã®n fundal.

avaScript interpreteazÄƒ (sau dezambaleazÄƒ) instrucÈ›iunile. Atunci cÃ¢nd folosim notaÈ›ia cu paranteze pÄƒtrate, vede prima parantezÄƒ pÄƒtratÄƒ de deschidere `[` È™i continuÄƒ pÃ¢nÄƒ cÃ¢nd gÄƒseÈ™te paranteza pÄƒtratÄƒ de Ã®nchidere `]`. Doar atunci va evalua instrucÈ›iunea.

`mouse[bird.size]`: ÃntÃ¢i evalueazÄƒ `bird.size`, care este `"small"`. `mouse["small"]` returneazÄƒ `true`

Cu toate acestea, cu notaÈ›ia cu punct, acest lucru nu se Ã®ntÃ¢mplÄƒ. `mouse` nu are o cheie numitÄƒ `bird`, ceea ce Ã®nseamnÄƒ cÄƒ `mouse.bird` este `undefined`. Apoi, cerem `size` folosind notaÈ›ia cu punct: `mouse.bird.size`. Deoarece `mouse.bird` este `undefined`, de fapt cerem `undefined.size`. Acest lucru nu este valid È™i va arunca o eroare similarÄƒ cu `Cannot read property "size" of undefined` (Nu se poate citi proprietatea "size" a unei valori nedefinite).

</p>
</details>

---

###### 6. Care este rezultatul?

```javascript
let c = { greeting: 'Hey!' };
let d;

d = c;
c.greeting = 'Hello';
console.log(d.greeting);
```

- A: `Hello`
- B: `Hey!`
- C: `undefined`
- D: `ReferenceError`
- E: `TypeError`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: A

Ãn JavaScript, toate obiectele interacÈ›ioneazÄƒ prin _referinÈ›Äƒ_ atunci cÃ¢nd sunt setate ca egale Ã®ntre ele.

Mai Ã®ntÃ¢i, variabila `c` deÈ›ine o valoare care face referire la un obiect. Ulterior, atribuim variabilei `d` aceeaÈ™i referinÈ›Äƒ pe care o are `c` la obiect.

<img src="https://i.imgur.com/ko5k0fs.png" width="200">

CÃ¢nd modifici un obiect, le modifici pe toate.

</p>
</details>

---

###### 7. Care este rezultatul?

```javascript
let a = 3;
let b = new Number(3);
let c = 3;

console.log(a == b);
console.log(a === b);
console.log(b === c);
```

- A: `true` `false` `true`
- B: `false` `false` `true`
- C: `true` `false` `false`
- D: `false` `true` `true`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: C

`new Number()` este un constructor de funcÈ›ii Ã®ncorporat. DeÈ™i aratÄƒ ca un numÄƒr, nu este Ã®ntr-adevÄƒr un numÄƒr: are o mulÈ›ime de funcÈ›ionalitÄƒÈ›i suplimentare È™i este un obiect.

Atunci cÃ¢nd folosim operatorul `==` (operatorul de egalitate), acesta verificÄƒ doar dacÄƒ au aceeaÈ™i _valuare_. Ambele au valoarea `3`, È™a cÄƒ returneazÄƒ `true`.

Cu toate acestea, atunci cÃ¢nd folosim operatorul `===` (operatorul de egalitate strictÄƒ), atÃ¢t valoarea, cÃ¢t _È™i_ tipul trebuie sÄƒ fie la fel. Nu sunt: `new Number()` nu este un numÄƒr, este un **object**. Ambele returneazÄƒ `false.`

</p>
</details>

---

###### 8. Care este rezultatul?

```javascript
class Chameleon {
  static colorChange(newColor) {
    this.newColor = newColor;
    return this.newColor;
  }

  constructor({ newColor = 'green' } = {}) {
    this.newColor = newColor;
  }
}

const freddie = new Chameleon({ newColor: 'purple' });
console.log(freddie.colorChange('orange'));
```

- A: `orange`
- B: `purple`
- C: `green`
- D: `TypeError`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: D

FuncÈ›ia `colorChange` este staticÄƒ. Metodele statice sunt concepute sÄƒ existe doar pe constructorul Ã®n care sunt create È™i nu pot fi transmise cÄƒtre niciun copil sau apelate pe instanÈ›ele clasei. Deoarece `freddie` este o instanÈ›Äƒ a clasei Chameleon, funcÈ›ia nu poate fi apelatÄƒ pe aceasta. Se aruncÄƒ o eroare de tip `TypeError`.

</p>
</details>

---

###### 9. Care este rezultatul?

```javascript
let greeting;
greetign = {}; // Typo!
console.log(greetign);
```

- A: `{}`
- B: `ReferenceError: greetign is not defined`
- C: `undefined`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: A

Se afiÈ™eazÄƒ obiectul, deoarece tocmai am creat un obiect gol pe obiectul global! Atunci cÃ¢nd am greÈ™it È™i am scris `greeting` Ã®n loc de `greetign`, interpretorul JavaScript a vÄƒzut efectiv acest lucru ca:

1. `global.greetign = {}` Ã®n Node.js
2. `window.greetign = {}`, `frames.greetign = {}` È™i `self.greetign` Ã®n browser-e.
3. `self.greetign` Ã®n web workers.
4. `globalThis.greetign` Ã®n toate mediile.

Pentru a evita acest lucru, putem folosi `"use strict"`. Acest lucru se asigurÄƒ cÄƒ ai declarat o variabilÄƒ Ã®nainte de a-i atribui o valoare.

</p>
</details>

---

###### 10. Ce se Ã®ntÃ¢mplÄƒ cÃ¢nd facem asta?

```javascript
function bark() {
  console.log('Woof!');
}

bark.animal = 'dog';
```

- A: Nimic, este absolut Ã®n regulÄƒ!
- B: `SyntaxError`. Nu poÈ›i adÄƒuga proprietÄƒÈ›i la o funcÈ›ie Ã®n acest fel.
- C: `"Woof"` este Ã®nregistrat.
- D: `ReferenceError`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: A

Acest lucru este posibil Ã®n JavaScript, deoarece funcÈ›iile sunt obiecte! (Totul, Ã®n afarÄƒ de tipurile primitive, sunt obiecte)

O funcÈ›ie este un tip special de obiect. Codul pe care Ã®l scrii tu Ã®nsuÈ›i nu este funcÈ›ia efectivÄƒ. FuncÈ›ia este un obiect cu proprietÄƒÈ›i. AceastÄƒ proprietate este invocabilÄƒ.

</p>
</details>

---

###### 11. Care este rezultatul?

```javascript
function Person(firstName, lastName) {
  this.firstName = firstName;
  this.lastName = lastName;
}

const member = new Person('Lydia', 'Hallie');
Person.getFullName = function () {
  return `${this.firstName} ${this.lastName}`;
};

console.log(member.getFullName());
```

- A: `TypeError`
- B: `SyntaxError`
- C: `Lydia Hallie`
- D: `undefined` `undefined`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: A

Ãn JavaScript, funcÈ›iile sunt obiecte È™i, prin urmare, metoda `getFullName` este adÄƒugatÄƒ obiectului constructor al funcÈ›iei Ã®n sine. Din acest motiv, putem apela `Person.getFullName()`, dar `member.getFullName` aruncÄƒ o eroare de tip `TypeError`.

DacÄƒ doriÈ›i ca o metodÄƒ sÄƒ fie disponibilÄƒ pentru toate instanÈ›ele obiectului, trebuie sÄƒ o adÄƒugaÈ›i la proprietatea prototype:

```js
Person.prototype.getFullName = function () {
  return `${this.firstName} ${this.lastName}`;
};
```

</p>
</details>

---

###### 12. Care este rezultatul?

```javascript
function Person(firstName, lastName) {
  this.firstName = firstName;
  this.lastName = lastName;
}

const lydia = new Person('Lydia', 'Hallie');
const sarah = Person('Sarah', 'Smith');

console.log(lydia);
console.log(sarah);
```

- A: `Person {firstName: "Lydia", lastName: "Hallie"}` È™i `undefined`
- B: `Person {firstName: "Lydia", lastName: "Hallie"}` È™i `Person {firstName: "Sarah", lastName: "Smith"}`
- C: `Person {firstName: "Lydia", lastName: "Hallie"}` È™i `{}`
- D: `Person {firstName: "Lydia", lastName: "Hallie"}` È™i `ReferenceError`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: A

Pentru `sarah`, nu am folosit cuvÃ¢ntul cheie `new`. CÃ¢nd folosim `new`, `this` se referÄƒ la noul obiect gol pe care Ã®l creÄƒm. Cu toate acestea, dacÄƒ nu adÄƒugÄƒm `new`, `this` se referÄƒ la **obiectul global**!

Am spus cÄƒ `this.firstName` este egal cu `"Sarah"` È™i `this.lastName` este egal cu `"Smith"`. Ceea ce am fÄƒcut de fapt este sÄƒ definim `global.firstName = 'Sarah'` È™i `global.lastName = 'Smith'`. `sarah` Ã®n sine rÄƒmÃ¢ne `undefined`, deoarece nu returnÄƒm o valoare din funcÈ›ia `Person`.

</p>
</details>

---

###### 13. Care sunt cele trei faze ale propagÄƒrii evenimentelor?

- A: Target > Capturing > Bubbling
- B: Bubbling > Target > Capturing
- C: Target > Bubbling > Capturing
- D: Capturing > Target > Bubbling

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: D

Ãn timpul fazei de **capturing**, evenimentul trece prin elementele pÄƒrinte pÃ¢nÄƒ la elementul È›intÄƒ. Apoi ajunge la elementul **target**, È™i Ã®ncepe **bubbling**.

<img src="https://i.imgur.com/N18oRgd.png" width="200">

</p>
</details>

---

###### 14. Toate obiectele au prototipuri.

- A: true
- B: false

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: B

Toate obiectele au prototipuri, cu excepÈ›ia **obiectului de bazÄƒ**. Obiectul de bazÄƒ este obiectul creat de utilizator sau un obiect creat folosind cuvÃ¢ntul cheie `new`. Obiectul de bazÄƒ are acces la unele metode È™i proprietÄƒÈ›i, cum ar fi `.toString`. Acesta este motivul pentru care puteÈ›i utiliza metode JavaScript Ã®ncorporate! Toate aceste metode sunt disponibile Ã®n prototip. DeÈ™i JavaScript nu le poate gÄƒsi direct Ã®n obiectul dvs., merge Ã®n jos pe lanÈ›ul prototip È™i le gÄƒseÈ™te acolo, ceea ce le face accesibile pentru dvs.

</p>
</details>

---

###### 15. Care este rezultatul?

```javascript
function sum(a, b) {
  return a + b;
}

sum(1, '2');
```

- A: `NaN`
- B: `TypeError`
- C: `"12"`
- D: `3`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: C

JavaScript este un limbaj **dinamic tipizat**: nu specificÄƒm tipurile variabilelor. Valorile pot fi convertite automat Ã®n alt tip fÄƒrÄƒ sÄƒ È™tiÈ›i, ceea ce se numeÈ™te _coerÈ›ie de tip implicitÄƒ_. **CoerÈ›ia** este conversia dintr-un tip Ã®n altul.

Ãn acest exemplu, JavaScript converteÈ™te numÄƒrul `1` Ã®ntr-un È™ir de caractere, pentru ca funcÈ›ia sÄƒ aibÄƒ sens È™i sÄƒ returneze o valoare. Ãn timpul adunÄƒrii unui tip numeric (`1`) È™i unui tip È™ir de caractere (`'2'`), numÄƒrul este tratat ca un È™ir de caractere. Putem concatena È™iruri de caractere, aÈ™a cum facem cu `"Hello" + "World"`, deci ceea ce se Ã®ntÃ¢mplÄƒ aici este `"1" + "2"` care returneazÄƒ `"12"`.

</p>
</details>

---

###### 16. Care este rezultatul?

```javascript
let number = 0;
console.log(number++);
console.log(++number);
console.log(number);
```

- A: `1` `1` `2`
- B: `1` `2` `2`
- C: `0` `2` `2`
- D: `0` `1` `2`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: C

Operatorul unary **postfix** `++`:

1. ReturneazÄƒ valoarea (aceasta returneazÄƒ `0`)
2. IncrementeazÄƒ valoarea (numÄƒrul este acum `1`)

Operatorul unary **prefix** `++`:

1. IncrementeazÄƒ valoarea (numÄƒrul este acum `2`)
2. ReturneazÄƒ valoarea (aceasta returneazÄƒ `2`)

Aceasta returneazÄƒ `0 2 2`.

</p>
</details>

---

###### 17. Care este rezultatul?

```javascript
function getPersonInfo(one, two, three) {
  console.log(one);
  console.log(two);
  console.log(three);
}

const person = 'Lydia';
const age = 21;

getPersonInfo`${person} is ${age} years old`;
```

- A: `"Lydia"` `21` `["", " is ", " years old"]`
- B: `["", " is ", " years old"]` `"Lydia"` `21`
- C: `"Lydia"` `["", " is ", " years old"]` `21`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: B

DacÄƒ utilizaÈ›i È™iruri template etichetate, valoarea primului argument este Ã®ntotdeauna un È™ir de valori. Argumentele rÄƒmase primesc valorile expresiilor transmise!

</p>
</details>

---

###### 18. Care este rezultatul?

```javascript
function checkAge(data) {
  if (data === { age: 18 }) {
    console.log('You are an adult!');
  } else if (data == { age: 18 }) {
    console.log('You are still an adult.');
  } else {
    console.log(`Hmm.. You don't have an age I guess`);
  }
}

checkAge({ age: 18 });
```

- A: `You are an adult!`
- B: `You are still an adult.`
- C: `Hmm.. You don't have an age I guess`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: C

CÃ¢nd se testeazÄƒ egalitatea, primitivele sunt comparate Ã®n funcÈ›ie de valoarea lor, Ã®n timp ce obiectele sunt comparate Ã®n funcÈ›ie de _referinÈ›a_ lor. JavaScript verificÄƒ dacÄƒ obiectele au o referinÈ›Äƒ cÄƒtre aceeaÈ™i locaÈ›ie Ã®n memorie.

Cele douÄƒ obiecte pe care le comparÄƒm nu au aceeaÈ™i referinÈ›Äƒ: obiectul pe care l-am trecut ca parametru se referÄƒ la o altÄƒ locaÈ›ie Ã®n memorie decÃ¢t obiectul pe care l-am folosit pentru a verifica egalitatea.

Acesta este motivul pentru care ambele `{ age: 18 } === { age: 18 }` È™i `{ age: 18 } == { age: 18 }` returneazÄƒ `false`.

</p>
</details>

---

###### 19. Care este rezultatul?

```javascript
function getAge(...args) {
  console.log(typeof args);
}

getAge(21);
```

- A: `"number"`
- B: `"array"`
- C: `"object"`
- D: `"NaN"`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: C

Parametrul rest (`...args`) ne permite sÄƒ "colectÄƒm" toate argumentele rÄƒmase Ã®ntr-un array. Un array este un obiect, aÈ™a cÄƒ `typeof args` returneazÄƒ `"object"`

</p>
</details>

---

###### 20. Care este rezultatul?

```javascript
function getAge() {
  'use strict';
  age = 21;
  console.log(age);
}

getAge();
```

- A: `21`
- B: `undefined`
- C: `ReferenceError`
- D: `TypeError`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: C

Cu `"use strict"`, puteÈ›i asigura cÄƒ nu declaraÈ›i accidental variabile globale. NiciodatÄƒ nu am declarat variabila `age`, È™i deoarece folosim `"use strict"`, va arunca o eroare de referinÈ›Äƒ. DacÄƒ nu am fi folosit `"use strict"`, ar fi funcÈ›ionat, deoarece proprietatea `age` ar fi fost adÄƒugatÄƒ la obiectul global.

</p>
</details>

---

###### 21. Care este valoarea lui `sum`?

```javascript
const sum = eval('10*10+5');
```

- A: `105`
- B: `"105"`
- C: `TypeError`
- D: `"10*10+5"`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: A

`eval` evalueazÄƒ codul care este trecut ca un È™ir de caractere. DacÄƒ este o expresie, aÈ™a cum este Ã®n acest caz, evalueazÄƒ expresia. Expresia este `10 * 10 + 5`. Aceasta returneazÄƒ numÄƒrul `105`.

</p>
</details>

---

###### 22. CÃ¢t timp este accesibil cool_secret?

```javascript
sessionStorage.setItem('cool_secret', 123);
```

- A: Pentru totdeauna, datele nu se pierd.
- B: CÃ¢nd utilizatorul Ã®nchide fila.
- C: CÃ¢nd utilizatorul Ã®nchide Ã®ntregul browser, nu doar fila.
- D: CÃ¢nd utilizatorul opreÈ™te computerul.

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: B

Datele stocate Ã®n `sessionStorage` sunt eliminate dupÄƒ Ã®nchiderea _filei_.

DacÄƒ aÈ›i fi folosit `localStorage`, datele ar fi rÄƒmas acolo pentru totdeauna, cu excepÈ›ia cazului Ã®n care, de exemplu, este invocatÄƒ comanda `localStorage.clear()`.

</p>
</details>

---

###### 23. Care este rezultatul?

```javascript
var num = 8;
var num = 10;

console.log(num);
```

- A: `8`
- B: `10`
- C: `SyntaxError`
- D: `ReferenceError`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: B

Cu cuvÃ¢ntul cheie `var`, puteÈ›i declara mai multe variabile cu acelaÈ™i nume. Variabila va reÈ›ine apoi cea mai recentÄƒ valoare.

Nu puteÈ›i face acest lucru cu `let` sau `const` deoarece acestea sunt cu scop de bloc.

</p>
</details>

---

###### 24. Care este rezultatul?

```javascript
const obj = { 1: 'a', 2: 'b', 3: 'c' };
const set = new Set([1, 2, 3, 4, 5]);

obj.hasOwnProperty('1');
obj.hasOwnProperty(1);
set.has('1');
set.has(1);
```

- A: `false` `true` `false` `true`
- B: `false` `true` `true` `true`
- C: `true` `true` `false` `true`
- D: `true` `true` `true` `true`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: C

Toate cheile obiectelor (cu excepÈ›ia simbolurilor) sunt È™iruri de caractere Ã®n culise, chiar dacÄƒ nu le tastaÈ›i ca È™iruri de caractere. De aceea `obj.hasOwnProperty('1')` returneazÄƒ de asemenea `true`.

Acest lucru nu funcÈ›ioneazÄƒ Ã®n acelaÈ™i fel pentru un set. Nu existÄƒ `'1'` Ã®n setul nostru: `set.has('1')` returneazÄƒ `false`. Acesta are tipul numeric `1`, `set.has(1)` returneazÄƒ `true`.

</p>
</details>

---

###### 25. Care este rezultatul?

```javascript
const obj = { a: 'one', b: 'two', a: 'three' };
console.log(obj);
```

- A: `{ a: "one", b: "two" }`
- B: `{ b: "two", a: "three" }`
- C: `{ a: "three", b: "two" }`
- D: `SyntaxError`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: C

DacÄƒ aveÈ›i douÄƒ chei cu acelaÈ™i nume, cheia va fi Ã®nlocuitÄƒ. Va rÄƒmÃ¢ne totuÈ™i Ã®n prima sa poziÈ›ie, dar cu ultima valoare specificatÄƒ.

</p>
</details>

---

###### 26. Contextul global de execuÈ›ie JavaScript creeazÄƒ douÄƒ lucruri pentru dvs.: obiectul global È™i cuvÃ¢ntul cheie "this".

- A: true
- B: false
- C: it depends

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: A

Contextul de execuÈ›ie de bazÄƒ este contextul global de execuÈ›ie: este ceea ce este accesibil peste tot Ã®n codul dvs.

</p>
</details>

---

###### 27. Care este rezultatul?

```javascript
for (let i = 1; i < 5; i++) {
  if (i === 3) continue;
  console.log(i);
}
```

- A: `1` `2`
- B: `1` `2` `3`
- C: `1` `2` `4`
- D: `1` `3` `4`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: C

InstrucÈ›iunea `continue` sare peste o iteraÈ›ie dacÄƒ o anumitÄƒ condiÈ›ie returneazÄƒ `true`.

</p>
</details>

---

###### 28. Care este rezultatul?

```javascript
String.prototype.giveLydiaPizza = () => {
  return 'Just give Lydia pizza already!';
};

const name = 'Lydia';

console.log(name.giveLydiaPizza());
```

- A: `"Just give Lydia pizza already!"`
- B: `TypeError: not a function`
- C: `SyntaxError`
- D: `undefined`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: A

`String` este un constructor Ã®ncorporat, la care putem adÄƒuga proprietÄƒÈ›i. Am adÄƒugat doar o metodÄƒ la prototipul sÄƒu. È˜irurile primitive sunt convertite automat Ã®ntr-un obiect È™ir, generat de funcÈ›ia prototip a È™irului. Prin urmare, toate È™irurile (obiecte de È™ir) au acces la acea metodÄƒ!

</p>
</details>

---

###### 29. Care este rezultatul?

```javascript
const a = {};
const b = { key: 'b' };
const c = { key: 'c' };

a[b] = 123;
a[c] = 456;

console.log(a[b]);
```

- A: `123`
- B: `456`
- C: `undefined`
- D: `ReferenceError`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: B

Cheile obiectului sunt convertite automat Ã®n È™iruri de caractere. ÃncercÄƒm sÄƒ setÄƒm un obiect ca cheie pentru obiectul `a`, cu valoarea `123`.

Cu toate acestea, cÃ¢nd transformÄƒm Ã®n È™ir un obiect, acesta devine `"[object Object]"`. Deci ceea ce spunem aici este cÄƒ `a["[object Object]"] = 123`. Apoi, putem Ã®ncerca sÄƒ facem acelaÈ™i lucru din nou. `c` este un alt obiect pe care Ã®l transformÄƒm implicit Ã®n È™ir. AÈ™adar, `a["[object Object]"] = 456`.

Apoi, afiÈ™Äƒm Ã®nregistrarea `a[b]`, care de fapt este `a["[object Object]"]`. Am setat doar asta la `456`, deci returneazÄƒ `456`.

</p>
</details>

---

###### 30. Care este rezultatul?

```javascript
const foo = () => console.log('First');
const bar = () => setTimeout(() => console.log('Second'));
const baz = () => console.log('Third');

bar();
foo();
baz();
```

- A: `First` `Second` `Third`
- B: `First` `Third` `Second`
- C: `Second` `First` `Third`
- D: `Second` `Third` `First`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: B

Avem o funcÈ›ie `setTimeout` È™i am invocat-o mai Ã®ntÃ¢i. Cu toate acestea, a fost Ã®nregistratÄƒ Ã®n ultimul rÃ¢nd.

Acest lucru se datoreazÄƒ faptului cÄƒ Ã®n browsere, nu avem doar motorul de execuÈ›ie, avem È™i ceva numit `WebAPI`.`WebAPI` ne oferÄƒ funcÈ›ia `setTimeout` de exemplu, È™i DOM-ul.

DupÄƒ ce _callback_-ul este trimis cÄƒtre WebAPI, funcÈ›ia `setTimeout` Ã®n sine (dar nu È™i callback-ul!) este scos din stivÄƒ.

<img src="https://i.imgur.com/X5wsHOg.png" width="200">

Acum, `foo` este invocatÄƒ, iar`"First"` este Ã®nregistrat.

<img src="https://i.imgur.com/Pvc0dGq.png" width="200">

`foo` este scoasÄƒ din stivÄƒ, iar `baz` este invocatÄƒ. Se Ã®nregistreazÄƒ `"Third"`.

<img src="https://i.imgur.com/WhA2bCP.png" width="200">

WebAPI-ul nu poate adÄƒuga pur È™i simplu lucruri Ã®n stivÄƒ atunci cÃ¢nd este gata. Ãn schimb, Ã®mpinge funcÈ›ia de callback Ã®ntr-o structurÄƒ numitÄƒ _coadÄƒ_.

<img src="https://i.imgur.com/NSnDZmU.png" width="200">

Aici Ã®ncepe sÄƒ lucreze un event loop. Un **event loop** se uitÄƒ la stivÄƒ È™i la coada de sarcini. DacÄƒ stiva este goalÄƒ, ia primul lucru din coadÄƒ È™i-l adaugÄƒ Ã®n stivÄƒ.

<img src="https://i.imgur.com/uyiScAI.png" width="200">

`bar` este invocatÄƒ, `"Second"` este Ã®nregistrat È™i este scos din stivÄƒ.

</p>
</details>

---

###### 31. Ce reprezintÄƒ "event.target" atunci cÃ¢nd se face clic pe buton?

```html
<div onclick="console.log('first div')">
  <div onclick="console.log('second div')">
    <button onclick="console.log('button')">
      Click!
    </button>
  </div>
</div>
```

- A: Ãn afara `div`
- B: Ãn interior `div`
- C: `button`
- D: Un È™ir de toate elementele Ã®nglobate.

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: C

Cel mai profund element Ã®nglobat care a cauzat evenimentul este È›inta evenimentului. PuteÈ›i opri propagarea acestuia prin `event.stopPropagation`

</p>
</details>

---

###### 32. CÃ¢nd faceÈ›i clic pe paragraf, care este ieÈ™irea Ã®nregistratÄƒ?

```html
<div onclick="console.log('div')">
  <p onclick="console.log('p')">
    Click here!
  </p>
</div>
```

- A: `p` `div`
- B: `div` `p`
- C: `p`
- D: `div`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: A

DacÄƒ facem clic pe `p`, vom vedea douÄƒ Ã®nregistrÄƒri: `p` È™i `div`. Ãn timpul propagÄƒrii evenimentului, existÄƒ 3 faze: capturare, È›intÄƒ È™i propagare. Ãn mod implicit, gestionarii de evenimente sunt executaÈ›i Ã®n faza de propagare (cu excepÈ›ia cazului Ã®n care setaÈ›i `useCapture` la `true`). AceÈ™tia se executÄƒ de la cel mai profund element Ã®nglobat cÄƒtre exterior.

</p>
</details>

---

###### 33. Care este rezultatul?

```javascript
const person = { name: 'Lydia' };

function sayHi(age) {
  return `${this.name} is ${age}`;
}

console.log(sayHi.call(person, 21));
console.log(sayHi.bind(person, 21));
```

- A: `undefined is 21` `Lydia is 21`
- B: `function` `function`
- C: `Lydia is 21` `Lydia is 21`
- D: `Lydia is 21` `function`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: D

Cu ambele metode, putem transmite obiectul la care dorim sÄƒ se refere cuvÃ¢ntul cheie `this`. Cu toate acestea, `.call` este de asemenea _executat imediat_!

`.bind.` returneazÄƒ o _copie_ a funcÈ›iei, dar cu un context legat! Nu este executat imediat.

</p>
</details>

---

###### 34. Care este rezultatul?

```javascript
function sayHi() {
  return (() => 0)();
}

console.log(typeof sayHi());
```

- A: `"object"`
- B: `"number"`
- C: `"function"`
- D: `"undefined"`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: B

FuncÈ›ia `sayHi` returneazÄƒ valoarea returnatÄƒ de expresia funcÈ›iei invocate imediat (IIFE). This function returned `0`, care este de tip `"number"`.
	
InformaÈ›ie utilÄƒ: `typeof` poate returna urmÄƒtoarele valori: `undefined`, `boolean`, `number`, `bigint`, `string`, `symbol`, `function` È™i `object`. NotaÈ›i cÄƒ `typeof null` returneazÄƒ `"object"`.

</p>
</details>

---

###### 35. Care dintre aceste valori sunt considerate falsy?

```javascript
0;
new Number(0);
('');
(' ');
new Boolean(false);
undefined;
```

- A: `0`, `''`, `undefined`
- B: `0`, `new Number(0)`, `''`, `new Boolean(false)`, `undefined`
- C: `0`, `''`, `new Boolean(false)`, `undefined`
- D: Toate dintre ele sunt considerate falsy

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: A

ExistÄƒ 8 valori considerate falsy:

- `undefined`
- `null`
- `NaN`
- `false`
- `''` (È™ir de caractere gol)
- `0`
- `-0`
- `0n` (BigInt(0))

Constructorii de funcÈ›ii, cum ar fi `new Number` È™i `new Boolean` sunt consideraÈ›i truthy.

</p>
</details>

---

###### 36. Care este rezultatul?

```javascript
console.log(typeof typeof 1);
```

- A: `"number"`
- B: `"string"`
- C: `"object"`
- D: `"undefined"`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: B

`typeof 1` returneazÄƒ `"number"`.
`typeof "number"` returneazÄƒ `"string"`

</p>
</details>

---

###### 37. Care este rezultatul?

```javascript
const numbers = [1, 2, 3];
numbers[10] = 11;
console.log(numbers);
```

- A: `[1, 2, 3, null x 7, 11]`
- B: `[1, 2, 3, 11]`
- C: `[1, 2, 3, empty x 7, 11]`
- D: `SyntaxError`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: C

CÃ¢nd setaÈ›i o valoare pentru un element Ã®ntr-un array care depÄƒÈ™eÈ™te lungimea array-ului, JavaScript creeazÄƒ ceea ce se numeÈ™te "slot-uri goale" (empty slots). Acestea au de fapt valoarea `undefined`, dar veÈ›i vedea ceva de genul:

`[1, 2, 3, empty x 7, 11]`

Ã®n funcÈ›ie de locul Ã®n care Ã®l rulaÈ›i (este diferit pentru fiecare browser, Node.js, etc.)

</p>
</details>

---

###### 38. Care este rezultatul?

```javascript
(() => {
  let x, y;
  try {
    throw new Error();
  } catch (x) {
    (x = 1), (y = 2);
    console.log(x);
  }
  console.log(x);
  console.log(y);
})();
```

- A: `1` `undefined` `2`
- B: `undefined` `undefined` `undefined`
- C: `1` `1` `2`
- D: `1` `undefined` `undefined`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: A

Blocul `catch` primeÈ™te argumentul `x`. Acesta nu este acelaÈ™i `x` ca variabila cÃ¢nd transmitem argumente. AceastÄƒ variabilÄƒ `x` este avÃ¢nd domeniu de bloc (block-scoped).

Mai tÃ¢rziu, setÄƒm aceastÄƒ variabilÄƒ cu domeniu de bloc la valoarea `1`, È™i stabilim valoarea variabilei `y`. Acum, Ã®nregistrÄƒm Ã®n consolÄƒ variabila cu domeniu de bloc `x`, care este egalÄƒ cu `1`.

Ãn afara blocului `catch`, `x` rÄƒmÃ¢ne `undefined`, È™i `y` este `2`. Atunci cÃ¢nd dorim sÄƒ afiÈ™Äƒm Ã®n consolÄƒ `console.log(x)` Ã®n afara blocului `catch`, acesta returneazÄƒ `undefined`, È™i `y` returneazÄƒ `2`.

</p>
</details>

---

###### 39. Totul Ã®n JavaScript este fie un...

- A: primitiv sau obiect
- B: funcÈ›ie sau obiect
- C: Ã®ntrebare trucatÄƒ! doar obiecte
- D: numÄƒr sau obiect

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: A

JavaScript are doar tipuri primitive È™i obiecte.

Tipurile primitive sunt `boolean`, `null`, `undefined`, `bigint`, `number`, `string`, È™i `symbol`.

Ceea ce diferenÈ›iazÄƒ un tip primitiv de un obiect este faptul cÄƒ tipurile primitive nu au proprietÄƒÈ›i sau metode. Cu toate acestea, veÈ›i observa cÄƒ `'foo'.toUpperCase()` se evalueazÄƒ la `'FOO'` È™i nu duce la o eroare `TypeError`. Acest lucru se Ã®ntÃ¢mplÄƒ pentru cÄƒ atunci cÃ¢nd Ã®ncercaÈ›i sÄƒ accesaÈ›i o proprietate sau o metodÄƒ pe un tip primitiv, cum ar fi un È™ir de caractere (string), JavaScript va Ã®nconjura implicit tipul primitiv folosind una dintre clasele de Ã®nveliÈ™, adicÄƒ `String`, È™i apoi va renunÈ›a imediat la Ã®nveliÈ™ dupÄƒ ce expresia se evalueazÄƒ. Toate tipurile primitive, cu excepÈ›ia `null` È™i `undefined` prezintÄƒ acest comportament.

</p>
</details>

---

###### 40. Care este rezultatul?

```javascript
[[0, 1], [2, 3]].reduce(
  (acc, cur) => {
    return acc.concat(cur);
  },
  [1, 2],
);
```

- A: `[0, 1, 2, 3, 1, 2]`
- B: `[6, 1, 2]`
- C: `[1, 2, 0, 1, 2, 3]`
- D: `[1, 2, 6]`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: C

`[1, 2]` este valoarea noastrÄƒ iniÈ›ialÄƒ. Aceasta este valoarea cu care Ã®ncepem È™i valoarea primului `acc`. Ãn prima rundÄƒ, `acc` este `[1,2]`, È™i `cur` este `[0, 1]`. Le concatenÄƒm, ceea ce duce la rezultatul `[1, 2, 0, 1]`.

Atunci, `[1, 2, 0, 1]` este `acc` È™i `[2, 3]` este `cur`. Le concatenÄƒm È™i obÈ›inem `[1, 2, 0, 1, 2, 3]`

</p>
</details>

---