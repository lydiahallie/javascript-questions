<div align="center">
  <img height="60" src="https://img.icons8.com/color/344/javascript.png">
  <h1>ÃntrebÄƒri JavaScript</h1>

---

<span>Postez Ã®ntrebÄƒri JavaScript cu opÈ›iuni multiple pe [Instagram](https://www.instagram.com/theavocoder) **stories**, pe care le voi posta È™i aici! Ultima actualizare: <a href=#20200612><b>12 Iunie</b></a>

De la nivel de bazÄƒ la avansat: testeazÄƒ cÃ¢t de bine cunoÈ™ti JavaScript, reÃ®mprospÄƒteazÄƒ-È›i puÈ›in cunoÈ™tinÈ›ele sau pregÄƒteÈ™te-te pentru interviul tÄƒu de codare! :muscle: :rocket: Actualizez acest depozit Ã®n mod regulat cu Ã®ntrebÄƒri noi. Am adÄƒugat rÄƒspunsurile Ã®n **secÈ›iunile restrÃ¢nse** de sub Ã®ntrebÄƒri, pur È™i simplu dÄƒ clic pe ele pentru a le extinde. Este doar pentru distracÈ›ie, mult noroc! :heart:</span>

Nu ezita sÄƒ mÄƒ contactezi! ğŸ˜Š <br />
<a href="https://www.instagram.com/theavocoder">Instagram</a> || <a href="https://www.twitter.com/lydiahallie">Twitter</a> || <a href="https://www.linkedin.com/in/lydia-hallie">LinkedIn</a> || <a href="https://www.lydiahallie.dev">Blog</a>

</div>

| Simte-te liber sÄƒ le foloseÈ™ti Ã®ntr-un proiect! ğŸ˜ƒ AÈ™ aprecia _cu adevÄƒrat_ o referinÈ›Äƒ la acest depozit, eu creez Ã®ntrebÄƒrile È™i explicaÈ›iile (da, sunt tristÄƒ lol) È™i comunitatea mÄƒ ajutÄƒ foarte mult sÄƒ Ã®l menÈ›in È™i sÄƒ Ã®l Ã®mbunÄƒtÄƒÈ›esc! ğŸ’ªğŸ¼ MulÈ›umesc È™i distracÈ›ie plÄƒcutÄƒ! |
|---|

---

<details><summary><b> Vezi 20 de traduceri disponibile ğŸ‡¸ğŸ‡¦ğŸ‡ªğŸ‡¬ğŸ‡§ğŸ‡¦ğŸ‡©ğŸ‡ªğŸ‡ªğŸ‡¸ğŸ‡«ğŸ‡·ğŸ‡®ğŸ‡©ğŸ‡¯ğŸ‡µğŸ‡°ğŸ‡·ğŸ‡³ğŸ‡±ğŸ‡§ğŸ‡·ğŸ‡·ğŸ‡ºğŸ‡¹ğŸ‡­ğŸ‡¹ğŸ‡·ğŸ‡ºğŸ‡¦ğŸ‡»ğŸ‡³ğŸ‡¨ğŸ‡³ğŸ‡¹ğŸ‡¼ğŸ‡½ğŸ‡°</b></summary>
<p>

- [ğŸ‡¸ğŸ‡¦ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©](./ar-AR/README_AR.md)
- [ğŸ‡ªğŸ‡¬ Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø§Ù…ÙŠØ©](./ar-EG/README_ar-EG.md)
- [ğŸ‡§ğŸ‡¦ Bosanski](./bs-BS/README-bs_BS.md)
- [ğŸ‡©ğŸ‡ª Deutsch](./de-DE/README.md)
- [ğŸ‡ªğŸ‡¸ EspaÃ±ol](./es-ES/README-ES.md)
- [ğŸ‡«ğŸ‡· FranÃ§ais](./fr-FR/README_fr-FR.md)
- [ğŸ‡®ğŸ‡© Indonesia](./id-ID/README.md)
- [ğŸ‡®ğŸ‡¹ Italiano](./it-IT/README.md)
- [ğŸ‡¯ğŸ‡µ æ—¥æœ¬èª](./ja-JA/README-ja_JA.md)
- [ğŸ‡°ğŸ‡· í•œêµ­ì–´](./ko-KR/README-ko_KR.md)
- [ğŸ‡³ğŸ‡± Nederlands](./nl-NL/README.md)
- [ğŸ‡µğŸ‡± Polski](./pl-PL/README.md)
- [ğŸ‡§ğŸ‡· PortuguÃªs Brasil](./pt-BR/README_pt_BR.md)
- [ğŸ‡·ğŸ‡º Ğ ÑƒÑÑĞºĞ¸Ğ¹](./ru-RU/README.md)
- [ğŸ‡½ğŸ‡° Shqip](./sq-KS/README_sq_KS.md)
- [ğŸ‡¹ğŸ‡­ à¹„à¸—à¸¢](./th-TH/README-th_TH.md)
- [ğŸ‡¹ğŸ‡· TÃ¼rkÃ§e](./tr-TR/README-tr_TR.md)
- [ğŸ‡ºğŸ‡¦ Ğ£ĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°](./uk-UA/README.md)
- [ğŸ‡»ğŸ‡³ Tiáº¿ng Viá»‡t](./vi-VI/README-vi.md)
- [ğŸ‡¨ğŸ‡³ ç®€ä½“ä¸­æ–‡](./zh-CN/README-zh_CN.md)
- [ğŸ‡¹ğŸ‡¼ ç¹é«”ä¸­æ–‡](./zh-TW/README_zh-TW.md)

</p>
</details>

---

###### 1. Care este rezultatul?

```javascript
function sayHi() {
  console.log(name);
  console.log(age);
  var name = 'Lydia';
  let age = 21;
}

sayHi();
```

- A: `Lydia` È™i `undefined`
- B: `Lydia` È™i `ReferenceError`
- C: `ReferenceError` È™i `21`
- D: `undefined` È™i `ReferenceError`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: D

Ãn interiorul funcÈ›iei, mai Ã®ntÃ¢i declarÄƒm variabila `name` cu cuvÃ¢ntul cheie `var`. Acest lucru Ã®nseamnÄƒ cÄƒ variabila este hoisted (spaÈ›iul de memorie este configurat Ã®n faza de creare) cu valoarea implicitÄƒ `undefined`, pÃ¢nÄƒ cÃ¢nd ajungem efectiv la linia Ã®n care definim variabila. Nu am definit Ã®ncÄƒ variabila pe linia Ã®n care Ã®ncercÄƒm sÄƒ Ã®nregistrÄƒm variabila `name`, aÈ™a cÄƒ aceasta pÄƒstreazÄƒ Ã®ncÄƒ valoarea `undefined`.

Variabilele create cu cuvÃ¢ntul cheie `let` (È™i `const`) sunt hoisted, dar, spre deosebire de `var`, nu sunt <i>iniÈ›ializate</i>. Acestea nu sunt accesibile Ã®nainte de linia Ã®n care le declarÄƒm (initializÄƒm). Aceasta se numeÈ™te zona moartÄƒ temporalÄƒ (temporal dead zone). Atunci cÃ¢nd Ã®ncercÄƒm sÄƒ accesÄƒm variabilele Ã®nainte de a fi declarate, JavaScript aruncÄƒ o excepÈ›ie de tip `ReferenceError`.

</p>
</details>

---

###### 2. Care este rezultatul?

```javascript
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 1);
}

for (let i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 1);
}
```

- A: `0 1 2` È™i `0 1 2`
- B: `0 1 2` È™i `3 3 3`
- C: `3 3 3` È™i `0 1 2`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: C

DatoritÄƒ cozii de evenimente din JavaScript, funcÈ›ia de callback `setTimeout` este apelatÄƒ _dupÄƒ_ ce bucla a fost executatÄƒ. Deoarece variabila `i` din prima buclÄƒ a fost declaratÄƒ folosind cuvÃ¢ntul cheie `var`, aceastÄƒ valoare a fost globalÄƒ. Ãn timpul buclei, am incrementat valoarea lui `i` cu `1` de fiecare datÄƒ, folosind operatorul unary `++`. PÃ¢nÄƒ cÃ¢nd funcÈ›ia de callback `setTimeout` a fost invocatÄƒ, `i` era egal cu `3` Ã®n primul exemplu.

Ãn cea de-a doua buclÄƒ, variabila `i` a fost declaratÄƒ folosind cuvÃ¢ntul cheie `let`: variabilele declarate cu cuvÃ¢ntul cheie `let` (È™i `const`) sunt cu scop la nivel de bloc (un bloc este orice Ã®ntre `{ }`). Ãn fiecare iteraÈ›ie, `i` va avea o valoare nouÄƒ, iar fiecare valoare este Ã®n cadrul buclei.

</p>
</details>

---

###### 3. Care este rezultatul?

```javascript
const shape = {
  radius: 10,
  diameter() {
    return this.radius * 2;
  },
  perimeter: () => 2 * Math.PI * this.radius,
};

console.log(shape.diameter());
console.log(shape.perimeter());
```

- A: `20` È™i `62.83185307179586`
- B: `20` È™i `NaN`
- C: `20` È™i `63`
- D: `NaN` È™i `63`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: B

ReÈ›ineÈ›i cÄƒ valoarea lui `diameter` este o funcÈ›ie obiÈ™nuitÄƒ, Ã®n timp ce valoarea lui `perimeter` este o funcÈ›ie arrow.

Cu funcÈ›iile arrow, cuvÃ¢ntul cheie `this` se referÄƒ la contextul sÄƒu curent de Ã®ncadrare, spre deosebire de funcÈ›iile obiÈ™nuite! Acest lucru Ã®nseamnÄƒ cÄƒ atunci cÃ¢nd apelÄƒm `perimeter`, acesta nu se referÄƒ la obiectul formei, ci la Ã®ncadrarea sa curentÄƒ (de exemplu, fereastra).

Nu existÄƒ nicio valoare `radius` pe acel obiect, ceea ce returneazÄƒ `NaN`.

</p>
</details>

---

###### 4. Care este rezultatul?

```javascript
+true;
!'Lydia';
```

- A: `1` È™i `false`
- B: `false` È™i `NaN`
- C: `false` È™i `false`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: A

Operatorul unary plus Ã®ncearcÄƒ sÄƒ converteascÄƒ un operand Ã®ntr-un numÄƒr. `true` este `1`, È™i `false` este `0`.

È˜irul de caractere `'Lydia'` este o valoare adevÄƒratÄƒ. Ceea ce Ã®ntrebÄƒm de fapt, este "este aceastÄƒ valoare adevÄƒratÄƒ falsÄƒ?". Acest lucru returneazÄƒ `false`.

</p>
</details>

---

###### 5. Care este rezultatul?

```javascript
const bird = {
  size: 'small',
};

const mouse = {
  name: 'Mickey',
  small: true,
};
```

- A: `mouse.bird.size` nu este valid
- B: `mouse[bird.size]` nu este valid
- C: `mouse[bird["size"]]` nu este valid
- D: Toate sunt valide

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: A

Ãn JavaScript, toate cheile obiectelor sunt È™iruri de caractere (cu excepÈ›ia simbolurilor). Chiar dacÄƒ nu le _tipizÄƒm_ ca È™iruri de caractere, ele sunt Ã®ntotdeauna convertite Ã®n È™iruri de caractere Ã®n fundal.

avaScript interpreteazÄƒ (sau dezambaleazÄƒ) instrucÈ›iunile. Atunci cÃ¢nd folosim notaÈ›ia cu paranteze pÄƒtrate, vede prima parantezÄƒ pÄƒtratÄƒ de deschidere `[` È™i continuÄƒ pÃ¢nÄƒ cÃ¢nd gÄƒseÈ™te paranteza pÄƒtratÄƒ de Ã®nchidere `]`. Doar atunci va evalua instrucÈ›iunea.

`mouse[bird.size]`: ÃntÃ¢i evalueazÄƒ `bird.size`, care este `"small"`. `mouse["small"]` returneazÄƒ `true`

Cu toate acestea, cu notaÈ›ia cu punct, acest lucru nu se Ã®ntÃ¢mplÄƒ. `mouse` nu are o cheie numitÄƒ `bird`, ceea ce Ã®nseamnÄƒ cÄƒ `mouse.bird` este `undefined`. Apoi, cerem `size` folosind notaÈ›ia cu punct: `mouse.bird.size`. Deoarece `mouse.bird` este `undefined`, de fapt cerem `undefined.size`. Acest lucru nu este valid È™i va arunca o eroare similarÄƒ cu `Cannot read property "size" of undefined` (Nu se poate citi proprietatea "size" a unei valori nedefinite).

</p>
</details>

---

###### 6. Care este rezultatul?

```javascript
let c = { greeting: 'Hey!' };
let d;

d = c;
c.greeting = 'Hello';
console.log(d.greeting);
```

- A: `Hello`
- B: `Hey!`
- C: `undefined`
- D: `ReferenceError`
- E: `TypeError`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: A

Ãn JavaScript, toate obiectele interacÈ›ioneazÄƒ prin _referinÈ›Äƒ_ atunci cÃ¢nd sunt setate ca egale Ã®ntre ele.

Mai Ã®ntÃ¢i, variabila `c` deÈ›ine o valoare care face referire la un obiect. Ulterior, atribuim variabilei `d` aceeaÈ™i referinÈ›Äƒ pe care o are `c` la obiect.

<img src="https://i.imgur.com/ko5k0fs.png" width="200">

CÃ¢nd modifici un obiect, le modifici pe toate.

</p>
</details>

---

###### 7. Care este rezultatul?

```javascript
let a = 3;
let b = new Number(3);
let c = 3;

console.log(a == b);
console.log(a === b);
console.log(b === c);
```

- A: `true` `false` `true`
- B: `false` `false` `true`
- C: `true` `false` `false`
- D: `false` `true` `true`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: C

`new Number()` este un constructor de funcÈ›ii Ã®ncorporat. DeÈ™i aratÄƒ ca un numÄƒr, nu este Ã®ntr-adevÄƒr un numÄƒr: are o mulÈ›ime de funcÈ›ionalitÄƒÈ›i suplimentare È™i este un obiect.

Atunci cÃ¢nd folosim operatorul `==` (operatorul de egalitate), acesta verificÄƒ doar dacÄƒ au aceeaÈ™i _valuare_. Ambele au valoarea `3`, È™a cÄƒ returneazÄƒ `true`.

Cu toate acestea, atunci cÃ¢nd folosim operatorul `===` (operatorul de egalitate strictÄƒ), atÃ¢t valoarea, cÃ¢t _È™i_ tipul trebuie sÄƒ fie la fel. Nu sunt: `new Number()` nu este un numÄƒr, este un **object**. Ambele returneazÄƒ `false.`

</p>
</details>

---

###### 8. Care este rezultatul?

```javascript
class Chameleon {
  static colorChange(newColor) {
    this.newColor = newColor;
    return this.newColor;
  }

  constructor({ newColor = 'green' } = {}) {
    this.newColor = newColor;
  }
}

const freddie = new Chameleon({ newColor: 'purple' });
console.log(freddie.colorChange('orange'));
```

- A: `orange`
- B: `purple`
- C: `green`
- D: `TypeError`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: D

FuncÈ›ia `colorChange` este staticÄƒ. Metodele statice sunt concepute sÄƒ existe doar pe constructorul Ã®n care sunt create È™i nu pot fi transmise cÄƒtre niciun copil sau apelate pe instanÈ›ele clasei. Deoarece `freddie` este o instanÈ›Äƒ a clasei Chameleon, funcÈ›ia nu poate fi apelatÄƒ pe aceasta. Se aruncÄƒ o eroare de tip `TypeError`.

</p>
</details>

---

###### 9. Care este rezultatul?

```javascript
let greeting;
greetign = {}; // Typo!
console.log(greetign);
```

- A: `{}`
- B: `ReferenceError: greetign is not defined`
- C: `undefined`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: A

Se afiÈ™eazÄƒ obiectul, deoarece tocmai am creat un obiect gol pe obiectul global! Atunci cÃ¢nd am greÈ™it È™i am scris `greeting` Ã®n loc de `greetign`, interpretorul JavaScript a vÄƒzut efectiv acest lucru ca:

1. `global.greetign = {}` Ã®n Node.js
2. `window.greetign = {}`, `frames.greetign = {}` È™i `self.greetign` Ã®n browser-e.
3. `self.greetign` Ã®n web workers.
4. `globalThis.greetign` Ã®n toate mediile.

Pentru a evita acest lucru, putem folosi `"use strict"`. Acest lucru se asigurÄƒ cÄƒ ai declarat o variabilÄƒ Ã®nainte de a-i atribui o valoare.

</p>
</details>

---

###### 10. Ce se Ã®ntÃ¢mplÄƒ cÃ¢nd facem asta?

```javascript
function bark() {
  console.log('Woof!');
}

bark.animal = 'dog';
```

- A: Nimic, este absolut Ã®n regulÄƒ!
- B: `SyntaxError`. Nu poÈ›i adÄƒuga proprietÄƒÈ›i la o funcÈ›ie Ã®n acest fel.
- C: `"Woof"` este Ã®nregistrat.
- D: `ReferenceError`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: A

Acest lucru este posibil Ã®n JavaScript, deoarece funcÈ›iile sunt obiecte! (Totul, Ã®n afarÄƒ de tipurile primitive, sunt obiecte)

O funcÈ›ie este un tip special de obiect. Codul pe care Ã®l scrii tu Ã®nsuÈ›i nu este funcÈ›ia efectivÄƒ. FuncÈ›ia este un obiect cu proprietÄƒÈ›i. AceastÄƒ proprietate este invocabilÄƒ.

</p>
</details>

---

###### 11. Care este rezultatul?

```javascript
function Person(firstName, lastName) {
  this.firstName = firstName;
  this.lastName = lastName;
}

const member = new Person('Lydia', 'Hallie');
Person.getFullName = function () {
  return `${this.firstName} ${this.lastName}`;
};

console.log(member.getFullName());
```

- A: `TypeError`
- B: `SyntaxError`
- C: `Lydia Hallie`
- D: `undefined` `undefined`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: A

Ãn JavaScript, funcÈ›iile sunt obiecte È™i, prin urmare, metoda `getFullName` este adÄƒugatÄƒ obiectului constructor al funcÈ›iei Ã®n sine. Din acest motiv, putem apela `Person.getFullName()`, dar `member.getFullName` aruncÄƒ o eroare de tip `TypeError`.

DacÄƒ doriÈ›i ca o metodÄƒ sÄƒ fie disponibilÄƒ pentru toate instanÈ›ele obiectului, trebuie sÄƒ o adÄƒugaÈ›i la proprietatea prototype:

```js
Person.prototype.getFullName = function () {
  return `${this.firstName} ${this.lastName}`;
};
```

</p>
</details>

---

###### 12. Care este rezultatul?

```javascript
function Person(firstName, lastName) {
  this.firstName = firstName;
  this.lastName = lastName;
}

const lydia = new Person('Lydia', 'Hallie');
const sarah = Person('Sarah', 'Smith');

console.log(lydia);
console.log(sarah);
```

- A: `Person {firstName: "Lydia", lastName: "Hallie"}` È™i `undefined`
- B: `Person {firstName: "Lydia", lastName: "Hallie"}` È™i `Person {firstName: "Sarah", lastName: "Smith"}`
- C: `Person {firstName: "Lydia", lastName: "Hallie"}` È™i `{}`
- D: `Person {firstName: "Lydia", lastName: "Hallie"}` È™i `ReferenceError`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: A

Pentru `sarah`, nu am folosit cuvÃ¢ntul cheie `new`. CÃ¢nd folosim `new`, `this` se referÄƒ la noul obiect gol pe care Ã®l creÄƒm. Cu toate acestea, dacÄƒ nu adÄƒugÄƒm `new`, `this` se referÄƒ la **obiectul global**!

Am spus cÄƒ `this.firstName` este egal cu `"Sarah"` È™i `this.lastName` este egal cu `"Smith"`. Ceea ce am fÄƒcut de fapt este sÄƒ definim `global.firstName = 'Sarah'` È™i `global.lastName = 'Smith'`. `sarah` Ã®n sine rÄƒmÃ¢ne `undefined`, deoarece nu returnÄƒm o valoare din funcÈ›ia `Person`.

</p>
</details>

---

###### 13. Care sunt cele trei faze ale propagÄƒrii evenimentelor?

- A: Target > Capturing > Bubbling
- B: Bubbling > Target > Capturing
- C: Target > Bubbling > Capturing
- D: Capturing > Target > Bubbling

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: D

Ãn timpul fazei de **capturing**, evenimentul trece prin elementele pÄƒrinte pÃ¢nÄƒ la elementul È›intÄƒ. Apoi ajunge la elementul **target**, È™i Ã®ncepe **bubbling**.

<img src="https://i.imgur.com/N18oRgd.png" width="200">

</p>
</details>

---

###### 14. Toate obiectele au prototipuri.

- A: true
- B: false

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: B

Toate obiectele au prototipuri, cu excepÈ›ia **obiectului de bazÄƒ**. Obiectul de bazÄƒ este obiectul creat de utilizator sau un obiect creat folosind cuvÃ¢ntul cheie `new`. Obiectul de bazÄƒ are acces la unele metode È™i proprietÄƒÈ›i, cum ar fi `.toString`. Acesta este motivul pentru care puteÈ›i utiliza metode JavaScript Ã®ncorporate! Toate aceste metode sunt disponibile Ã®n prototip. DeÈ™i JavaScript nu le poate gÄƒsi direct Ã®n obiectul dvs., merge Ã®n jos pe lanÈ›ul prototip È™i le gÄƒseÈ™te acolo, ceea ce le face accesibile pentru dvs.

</p>
</details>

---

###### 15. Care este rezultatul?

```javascript
function sum(a, b) {
  return a + b;
}

sum(1, '2');
```

- A: `NaN`
- B: `TypeError`
- C: `"12"`
- D: `3`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: C

JavaScript este un limbaj **dinamic tipizat**: nu specificÄƒm tipurile variabilelor. Valorile pot fi convertite automat Ã®n alt tip fÄƒrÄƒ sÄƒ È™tiÈ›i, ceea ce se numeÈ™te _coerÈ›ie de tip implicitÄƒ_. **CoerÈ›ia** este conversia dintr-un tip Ã®n altul.

Ãn acest exemplu, JavaScript converteÈ™te numÄƒrul `1` Ã®ntr-un È™ir de caractere, pentru ca funcÈ›ia sÄƒ aibÄƒ sens È™i sÄƒ returneze o valoare. Ãn timpul adunÄƒrii unui tip numeric (`1`) È™i unui tip È™ir de caractere (`'2'`), numÄƒrul este tratat ca un È™ir de caractere. Putem concatena È™iruri de caractere, aÈ™a cum facem cu `"Hello" + "World"`, deci ceea ce se Ã®ntÃ¢mplÄƒ aici este `"1" + "2"` care returneazÄƒ `"12"`.

</p>
</details>

---

###### 16. Care este rezultatul?

```javascript
let number = 0;
console.log(number++);
console.log(++number);
console.log(number);
```

- A: `1` `1` `2`
- B: `1` `2` `2`
- C: `0` `2` `2`
- D: `0` `1` `2`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: C

Operatorul unary **postfix** `++`:

1. ReturneazÄƒ valoarea (aceasta returneazÄƒ `0`)
2. IncrementeazÄƒ valoarea (numÄƒrul este acum `1`)

Operatorul unary **prefix** `++`:

1. IncrementeazÄƒ valoarea (numÄƒrul este acum `2`)
2. ReturneazÄƒ valoarea (aceasta returneazÄƒ `2`)

Aceasta returneazÄƒ `0 2 2`.

</p>
</details>

---

###### 17. Care este rezultatul?

```javascript
function getPersonInfo(one, two, three) {
  console.log(one);
  console.log(two);
  console.log(three);
}

const person = 'Lydia';
const age = 21;

getPersonInfo`${person} is ${age} years old`;
```

- A: `"Lydia"` `21` `["", " is ", " years old"]`
- B: `["", " is ", " years old"]` `"Lydia"` `21`
- C: `"Lydia"` `["", " is ", " years old"]` `21`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: B

DacÄƒ utilizaÈ›i È™iruri template etichetate, valoarea primului argument este Ã®ntotdeauna un È™ir de valori. Argumentele rÄƒmase primesc valorile expresiilor transmise!

</p>
</details>

---

###### 18. Care este rezultatul?

```javascript
function checkAge(data) {
  if (data === { age: 18 }) {
    console.log('You are an adult!');
  } else if (data == { age: 18 }) {
    console.log('You are still an adult.');
  } else {
    console.log(`Hmm.. You don't have an age I guess`);
  }
}

checkAge({ age: 18 });
```

- A: `You are an adult!`
- B: `You are still an adult.`
- C: `Hmm.. You don't have an age I guess`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: C

CÃ¢nd se testeazÄƒ egalitatea, primitivele sunt comparate Ã®n funcÈ›ie de valoarea lor, Ã®n timp ce obiectele sunt comparate Ã®n funcÈ›ie de _referinÈ›a_ lor. JavaScript verificÄƒ dacÄƒ obiectele au o referinÈ›Äƒ cÄƒtre aceeaÈ™i locaÈ›ie Ã®n memorie.

Cele douÄƒ obiecte pe care le comparÄƒm nu au aceeaÈ™i referinÈ›Äƒ: obiectul pe care l-am trecut ca parametru se referÄƒ la o altÄƒ locaÈ›ie Ã®n memorie decÃ¢t obiectul pe care l-am folosit pentru a verifica egalitatea.

Acesta este motivul pentru care ambele `{ age: 18 } === { age: 18 }` È™i `{ age: 18 } == { age: 18 }` returneazÄƒ `false`.

</p>
</details>

---

###### 19. Care este rezultatul?

```javascript
function getAge(...args) {
  console.log(typeof args);
}

getAge(21);
```

- A: `"number"`
- B: `"array"`
- C: `"object"`
- D: `"NaN"`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: C

Parametrul rest (`...args`) ne permite sÄƒ "colectÄƒm" toate argumentele rÄƒmase Ã®ntr-un array. Un array este un obiect, aÈ™a cÄƒ `typeof args` returneazÄƒ `"object"`

</p>
</details>

---

###### 20. Care este rezultatul?

```javascript
function getAge() {
  'use strict';
  age = 21;
  console.log(age);
}

getAge();
```

- A: `21`
- B: `undefined`
- C: `ReferenceError`
- D: `TypeError`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: C

Cu `"use strict"`, puteÈ›i asigura cÄƒ nu declaraÈ›i accidental variabile globale. NiciodatÄƒ nu am declarat variabila `age`, È™i deoarece folosim `"use strict"`, va arunca o eroare de referinÈ›Äƒ. DacÄƒ nu am fi folosit `"use strict"`, ar fi funcÈ›ionat, deoarece proprietatea `age` ar fi fost adÄƒugatÄƒ la obiectul global.

</p>
</details>

---

###### 21. Care este valoarea lui `sum`?

```javascript
const sum = eval('10*10+5');
```

- A: `105`
- B: `"105"`
- C: `TypeError`
- D: `"10*10+5"`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: A

`eval` evalueazÄƒ codul care este trecut ca un È™ir de caractere. DacÄƒ este o expresie, aÈ™a cum este Ã®n acest caz, evalueazÄƒ expresia. Expresia este `10 * 10 + 5`. Aceasta returneazÄƒ numÄƒrul `105`.

</p>
</details>

---

###### 22. CÃ¢t timp este accesibil cool_secret?

```javascript
sessionStorage.setItem('cool_secret', 123);
```

- A: Pentru totdeauna, datele nu se pierd.
- B: CÃ¢nd utilizatorul Ã®nchide fila.
- C: CÃ¢nd utilizatorul Ã®nchide Ã®ntregul browser, nu doar fila.
- D: CÃ¢nd utilizatorul opreÈ™te computerul.

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: B

Datele stocate Ã®n `sessionStorage` sunt eliminate dupÄƒ Ã®nchiderea _filei_.

DacÄƒ aÈ›i fi folosit `localStorage`, datele ar fi rÄƒmas acolo pentru totdeauna, cu excepÈ›ia cazului Ã®n care, de exemplu, este invocatÄƒ comanda `localStorage.clear()`.

</p>
</details>

---

###### 23. Care este rezultatul?

```javascript
var num = 8;
var num = 10;

console.log(num);
```

- A: `8`
- B: `10`
- C: `SyntaxError`
- D: `ReferenceError`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: B

Cu cuvÃ¢ntul cheie `var`, puteÈ›i declara mai multe variabile cu acelaÈ™i nume. Variabila va reÈ›ine apoi cea mai recentÄƒ valoare.

Nu puteÈ›i face acest lucru cu `let` sau `const` deoarece acestea sunt cu scop de bloc.

</p>
</details>

---

###### 24. Care este rezultatul?

```javascript
const obj = { 1: 'a', 2: 'b', 3: 'c' };
const set = new Set([1, 2, 3, 4, 5]);

obj.hasOwnProperty('1');
obj.hasOwnProperty(1);
set.has('1');
set.has(1);
```

- A: `false` `true` `false` `true`
- B: `false` `true` `true` `true`
- C: `true` `true` `false` `true`
- D: `true` `true` `true` `true`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: C

Toate cheile obiectelor (cu excepÈ›ia simbolurilor) sunt È™iruri de caractere Ã®n culise, chiar dacÄƒ nu le tastaÈ›i ca È™iruri de caractere. De aceea `obj.hasOwnProperty('1')` returneazÄƒ de asemenea `true`.

Acest lucru nu funcÈ›ioneazÄƒ Ã®n acelaÈ™i fel pentru un set. Nu existÄƒ `'1'` Ã®n setul nostru: `set.has('1')` returneazÄƒ `false`. Acesta are tipul numeric `1`, `set.has(1)` returneazÄƒ `true`.

</p>
</details>

---

###### 25. Care este rezultatul?

```javascript
const obj = { a: 'one', b: 'two', a: 'three' };
console.log(obj);
```

- A: `{ a: "one", b: "two" }`
- B: `{ b: "two", a: "three" }`
- C: `{ a: "three", b: "two" }`
- D: `SyntaxError`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: C

DacÄƒ aveÈ›i douÄƒ chei cu acelaÈ™i nume, cheia va fi Ã®nlocuitÄƒ. Va rÄƒmÃ¢ne totuÈ™i Ã®n prima sa poziÈ›ie, dar cu ultima valoare specificatÄƒ.

</p>
</details>

---

###### 26. Contextul global de execuÈ›ie JavaScript creeazÄƒ douÄƒ lucruri pentru dvs.: obiectul global È™i cuvÃ¢ntul cheie "this".

- A: true
- B: false
- C: it depends

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: A

Contextul de execuÈ›ie de bazÄƒ este contextul global de execuÈ›ie: este ceea ce este accesibil peste tot Ã®n codul dvs.

</p>
</details>

---

###### 27. Care este rezultatul?

```javascript
for (let i = 1; i < 5; i++) {
  if (i === 3) continue;
  console.log(i);
}
```

- A: `1` `2`
- B: `1` `2` `3`
- C: `1` `2` `4`
- D: `1` `3` `4`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: C

InstrucÈ›iunea `continue` sare peste o iteraÈ›ie dacÄƒ o anumitÄƒ condiÈ›ie returneazÄƒ `true`.

</p>
</details>

---

###### 28. Care este rezultatul?

```javascript
String.prototype.giveLydiaPizza = () => {
  return 'Just give Lydia pizza already!';
};

const name = 'Lydia';

console.log(name.giveLydiaPizza());
```

- A: `"Just give Lydia pizza already!"`
- B: `TypeError: not a function`
- C: `SyntaxError`
- D: `undefined`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: A

`String` este un constructor Ã®ncorporat, la care putem adÄƒuga proprietÄƒÈ›i. Am adÄƒugat doar o metodÄƒ la prototipul sÄƒu. È˜irurile primitive sunt convertite automat Ã®ntr-un obiect È™ir, generat de funcÈ›ia prototip a È™irului. Prin urmare, toate È™irurile (obiecte de È™ir) au acces la acea metodÄƒ!

</p>
</details>

---

###### 29. Care este rezultatul?

```javascript
const a = {};
const b = { key: 'b' };
const c = { key: 'c' };

a[b] = 123;
a[c] = 456;

console.log(a[b]);
```

- A: `123`
- B: `456`
- C: `undefined`
- D: `ReferenceError`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: B

Cheile obiectului sunt convertite automat Ã®n È™iruri de caractere. ÃncercÄƒm sÄƒ setÄƒm un obiect ca cheie pentru obiectul `a`, cu valoarea `123`.

Cu toate acestea, cÃ¢nd transformÄƒm Ã®n È™ir un obiect, acesta devine `"[object Object]"`. Deci ceea ce spunem aici este cÄƒ `a["[object Object]"] = 123`. Apoi, putem Ã®ncerca sÄƒ facem acelaÈ™i lucru din nou. `c` este un alt obiect pe care Ã®l transformÄƒm implicit Ã®n È™ir. AÈ™adar, `a["[object Object]"] = 456`.

Apoi, afiÈ™Äƒm Ã®nregistrarea `a[b]`, care de fapt este `a["[object Object]"]`. Am setat doar asta la `456`, deci returneazÄƒ `456`.

</p>
</details>

---

###### 30. Care este rezultatul?

```javascript
const foo = () => console.log('First');
const bar = () => setTimeout(() => console.log('Second'));
const baz = () => console.log('Third');

bar();
foo();
baz();
```

- A: `First` `Second` `Third`
- B: `First` `Third` `Second`
- C: `Second` `First` `Third`
- D: `Second` `Third` `First`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: B

Avem o funcÈ›ie `setTimeout` È™i am invocat-o mai Ã®ntÃ¢i. Cu toate acestea, a fost Ã®nregistratÄƒ Ã®n ultimul rÃ¢nd.

Acest lucru se datoreazÄƒ faptului cÄƒ Ã®n browsere, nu avem doar motorul de execuÈ›ie, avem È™i ceva numit `WebAPI`.`WebAPI` ne oferÄƒ funcÈ›ia `setTimeout` de exemplu, È™i DOM-ul.

DupÄƒ ce _callback_-ul este trimis cÄƒtre WebAPI, funcÈ›ia `setTimeout` Ã®n sine (dar nu È™i callback-ul!) este scos din stivÄƒ.

<img src="https://i.imgur.com/X5wsHOg.png" width="200">

Acum, `foo` este invocatÄƒ, iar`"First"` este Ã®nregistrat.

<img src="https://i.imgur.com/Pvc0dGq.png" width="200">

`foo` este scoasÄƒ din stivÄƒ, iar `baz` este invocatÄƒ. Se Ã®nregistreazÄƒ `"Third"`.

<img src="https://i.imgur.com/WhA2bCP.png" width="200">

WebAPI-ul nu poate adÄƒuga pur È™i simplu lucruri Ã®n stivÄƒ atunci cÃ¢nd este gata. Ãn schimb, Ã®mpinge funcÈ›ia de callback Ã®ntr-o structurÄƒ numitÄƒ _coadÄƒ_.

<img src="https://i.imgur.com/NSnDZmU.png" width="200">

Aici Ã®ncepe sÄƒ lucreze un event loop. Un **event loop** se uitÄƒ la stivÄƒ È™i la coada de sarcini. DacÄƒ stiva este goalÄƒ, ia primul lucru din coadÄƒ È™i-l adaugÄƒ Ã®n stivÄƒ.

<img src="https://i.imgur.com/uyiScAI.png" width="200">

`bar` este invocatÄƒ, `"Second"` este Ã®nregistrat È™i este scos din stivÄƒ.

</p>
</details>

---

###### 31. Ce reprezintÄƒ "event.target" atunci cÃ¢nd se face clic pe buton?

```html
<div onclick="console.log('first div')">
  <div onclick="console.log('second div')">
    <button onclick="console.log('button')">
      Click!
    </button>
  </div>
</div>
```

- A: Ãn afara `div`
- B: Ãn interior `div`
- C: `button`
- D: Un È™ir de toate elementele Ã®nglobate.

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: C

Cel mai profund element Ã®nglobat care a cauzat evenimentul este È›inta evenimentului. PuteÈ›i opri propagarea acestuia prin `event.stopPropagation`

</p>
</details>

---

###### 32. CÃ¢nd faceÈ›i clic pe paragraf, care este ieÈ™irea Ã®nregistratÄƒ?

```html
<div onclick="console.log('div')">
  <p onclick="console.log('p')">
    Click here!
  </p>
</div>
```

- A: `p` `div`
- B: `div` `p`
- C: `p`
- D: `div`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: A

DacÄƒ facem clic pe `p`, vom vedea douÄƒ Ã®nregistrÄƒri: `p` È™i `div`. Ãn timpul propagÄƒrii evenimentului, existÄƒ 3 faze: capturare, È›intÄƒ È™i propagare. Ãn mod implicit, gestionarii de evenimente sunt executaÈ›i Ã®n faza de propagare (cu excepÈ›ia cazului Ã®n care setaÈ›i `useCapture` la `true`). AceÈ™tia se executÄƒ de la cel mai profund element Ã®nglobat cÄƒtre exterior.

</p>
</details>

---

###### 33. Care este rezultatul?

```javascript
const person = { name: 'Lydia' };

function sayHi(age) {
  return `${this.name} is ${age}`;
}

console.log(sayHi.call(person, 21));
console.log(sayHi.bind(person, 21));
```

- A: `undefined is 21` `Lydia is 21`
- B: `function` `function`
- C: `Lydia is 21` `Lydia is 21`
- D: `Lydia is 21` `function`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: D

Cu ambele metode, putem transmite obiectul la care dorim sÄƒ se refere cuvÃ¢ntul cheie `this`. Cu toate acestea, `.call` este de asemenea _executat imediat_!

`.bind.` returneazÄƒ o _copie_ a funcÈ›iei, dar cu un context legat! Nu este executat imediat.

</p>
</details>

---

###### 34. Care este rezultatul?

```javascript
function sayHi() {
  return (() => 0)();
}

console.log(typeof sayHi());
```

- A: `"object"`
- B: `"number"`
- C: `"function"`
- D: `"undefined"`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: B

FuncÈ›ia `sayHi` returneazÄƒ valoarea returnatÄƒ de expresia funcÈ›iei invocate imediat (IIFE). This function returned `0`, care este de tip `"number"`.
	
InformaÈ›ie utilÄƒ: `typeof` poate returna urmÄƒtoarele valori: `undefined`, `boolean`, `number`, `bigint`, `string`, `symbol`, `function` È™i `object`. NotaÈ›i cÄƒ `typeof null` returneazÄƒ `"object"`.

</p>
</details>

---

###### 35. Care dintre aceste valori sunt considerate falsy?

```javascript
0;
new Number(0);
('');
(' ');
new Boolean(false);
undefined;
```

- A: `0`, `''`, `undefined`
- B: `0`, `new Number(0)`, `''`, `new Boolean(false)`, `undefined`
- C: `0`, `''`, `new Boolean(false)`, `undefined`
- D: Toate dintre ele sunt considerate falsy

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: A

ExistÄƒ 8 valori considerate falsy:

- `undefined`
- `null`
- `NaN`
- `false`
- `''` (È™ir de caractere gol)
- `0`
- `-0`
- `0n` (BigInt(0))

Constructorii de funcÈ›ii, cum ar fi `new Number` È™i `new Boolean` sunt consideraÈ›i truthy.

</p>
</details>

---

###### 36. Care este rezultatul?

```javascript
console.log(typeof typeof 1);
```

- A: `"number"`
- B: `"string"`
- C: `"object"`
- D: `"undefined"`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: B

`typeof 1` returneazÄƒ `"number"`.
`typeof "number"` returneazÄƒ `"string"`

</p>
</details>

---

###### 37. Care este rezultatul?

```javascript
const numbers = [1, 2, 3];
numbers[10] = 11;
console.log(numbers);
```

- A: `[1, 2, 3, null x 7, 11]`
- B: `[1, 2, 3, 11]`
- C: `[1, 2, 3, empty x 7, 11]`
- D: `SyntaxError`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: C

CÃ¢nd setaÈ›i o valoare pentru un element Ã®ntr-un array care depÄƒÈ™eÈ™te lungimea array-ului, JavaScript creeazÄƒ ceea ce se numeÈ™te "slot-uri goale" (empty slots). Acestea au de fapt valoarea `undefined`, dar veÈ›i vedea ceva de genul:

`[1, 2, 3, empty x 7, 11]`

Ã®n funcÈ›ie de locul Ã®n care Ã®l rulaÈ›i (este diferit pentru fiecare browser, Node.js, etc.)

</p>
</details>

---

###### 38. Care este rezultatul?

```javascript
(() => {
  let x, y;
  try {
    throw new Error();
  } catch (x) {
    (x = 1), (y = 2);
    console.log(x);
  }
  console.log(x);
  console.log(y);
})();
```

- A: `1` `undefined` `2`
- B: `undefined` `undefined` `undefined`
- C: `1` `1` `2`
- D: `1` `undefined` `undefined`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: A

Blocul `catch` primeÈ™te argumentul `x`. Acesta nu este acelaÈ™i `x` ca variabila cÃ¢nd transmitem argumente. AceastÄƒ variabilÄƒ `x` este avÃ¢nd domeniu de bloc (block-scoped).

Mai tÃ¢rziu, setÄƒm aceastÄƒ variabilÄƒ cu domeniu de bloc la valoarea `1`, È™i stabilim valoarea variabilei `y`. Acum, Ã®nregistrÄƒm Ã®n consolÄƒ variabila cu domeniu de bloc `x`, care este egalÄƒ cu `1`.

Ãn afara blocului `catch`, `x` rÄƒmÃ¢ne `undefined`, È™i `y` este `2`. Atunci cÃ¢nd dorim sÄƒ afiÈ™Äƒm Ã®n consolÄƒ `console.log(x)` Ã®n afara blocului `catch`, acesta returneazÄƒ `undefined`, È™i `y` returneazÄƒ `2`.

</p>
</details>

---

###### 39. Totul Ã®n JavaScript este fie un...

- A: primitiv sau obiect
- B: funcÈ›ie sau obiect
- C: Ã®ntrebare trucatÄƒ! doar obiecte
- D: numÄƒr sau obiect

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: A

JavaScript are doar tipuri primitive È™i obiecte.

Tipurile primitive sunt `boolean`, `null`, `undefined`, `bigint`, `number`, `string`, È™i `symbol`.

Ceea ce diferenÈ›iazÄƒ un tip primitiv de un obiect este faptul cÄƒ tipurile primitive nu au proprietÄƒÈ›i sau metode. Cu toate acestea, veÈ›i observa cÄƒ `'foo'.toUpperCase()` se evalueazÄƒ la `'FOO'` È™i nu duce la o eroare `TypeError`. Acest lucru se Ã®ntÃ¢mplÄƒ pentru cÄƒ atunci cÃ¢nd Ã®ncercaÈ›i sÄƒ accesaÈ›i o proprietate sau o metodÄƒ pe un tip primitiv, cum ar fi un È™ir de caractere (string), JavaScript va Ã®nconjura implicit tipul primitiv folosind una dintre clasele de Ã®nveliÈ™, adicÄƒ `String`, È™i apoi va renunÈ›a imediat la Ã®nveliÈ™ dupÄƒ ce expresia se evalueazÄƒ. Toate tipurile primitive, cu excepÈ›ia `null` È™i `undefined` prezintÄƒ acest comportament.

</p>
</details>

---

###### 40. Care este rezultatul?

```javascript
[[0, 1], [2, 3]].reduce(
  (acc, cur) => {
    return acc.concat(cur);
  },
  [1, 2],
);
```

- A: `[0, 1, 2, 3, 1, 2]`
- B: `[6, 1, 2]`
- C: `[1, 2, 0, 1, 2, 3]`
- D: `[1, 2, 6]`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: C

`[1, 2]` este valoarea noastrÄƒ iniÈ›ialÄƒ. Aceasta este valoarea cu care Ã®ncepem È™i valoarea primului `acc`. Ãn prima rundÄƒ, `acc` este `[1,2]`, È™i `cur` este `[0, 1]`. Le concatenÄƒm, ceea ce duce la rezultatul `[1, 2, 0, 1]`.

Atunci, `[1, 2, 0, 1]` este `acc` È™i `[2, 3]` este `cur`. Le concatenÄƒm È™i obÈ›inem `[1, 2, 0, 1, 2, 3]`

</p>
</details>

---

###### 41. Care este rezultatul?

```javascript
!!null;
!!'';
!!1;
```

- A: `false` `true` `false`
- B: `false` `false` `true`
- C: `false` `true` `true`
- D: `true` `true` `false`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: B

`null` este falsy. `!null` returneazÄƒ `true`. `!true` returneazÄƒ `false`.

`""` este falsy. `!""` returneazÄƒ `true`. `!true` returneazÄƒ `false`.

`1` este truthy. `!1` returneazÄƒ `false`. `!false` returneazÄƒ `true`.

</p>
</details>

---

###### 42. Ce returneazÄƒ metoda `setInterval` Ã®n browser?

```javascript
setInterval(() => console.log('Hi'), 1000);
```

- A: un id unic
- B: cantitatea de milisecunde specificatÄƒ
- C: funcÈ›ia furnizatÄƒ
- D: `undefined`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: A

Aceasta returneazÄƒ un identificator unic. Acest id poate fi utilizat pentru a opri intervalul respectiv cu ajutorul funcÈ›iei `clearInterval()`.

</p>
</details>

---

###### 43. Ce returneazÄƒ acest lucru?

```javascript
[...'Lydia'];
```

- A: `["L", "y", "d", "i", "a"]`
- B: `["Lydia"]`
- C: `[[], "Lydia"]`
- D: `[["L", "y", "d", "i", "a"]]`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: A

Un È™ir de caractere este un obiect iterabil. Operatorul de rÄƒspÃ¢ndire (spread operator) mapeazÄƒ fiecare caracter dintr-un obiect iterabil la un element separat.

</p>
</details>

---

###### 44. Care este rezultatul?

```javascript
function* generator(i) {
  yield i;
  yield i * 2;
}

const gen = generator(10);

console.log(gen.next().value);
console.log(gen.next().value);
```

- A: `[0, 10], [10, 20]`
- B: `20, 20`
- C: `10, 20`
- D: `0, 10 and 10, 20`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: C

FuncÈ›iile regulate nu pot fi oprite Ã®n mijlocul execuÈ›iei dupÄƒ invocare. Cu toate acestea, o funcÈ›ie generator poate fi "opritÄƒ" Ã®n mijloc È™i ulterior poate continua de la locul unde s-a oprit. De fiecare datÄƒ cÃ¢nd o funcÈ›ie generator Ã®ntÃ¢lneÈ™te un cuvÃ¢nt cheie `yield`, funcÈ›ia furnizeazÄƒ valoarea specificatÄƒ dupÄƒ el. NotaÈ›i cÄƒ funcÈ›ia generator Ã®n acest caz nu _returneazÄƒ_ the valoarea, ci _furnizeazÄƒ_ valoarea.

Mai Ã®ntÃ¢i, iniÈ›ializÄƒm funcÈ›ia generator cu `i` egal cu `10`. InvocÄƒm funcÈ›ia generator folosind metoda `next()`. Prima datÄƒ cÃ¢nd invocÄƒm funcÈ›ia generator, `i` este egal cu `10`. Aceasta Ã®ntÃ¢lneÈ™te primul cuvÃ¢nt cheie `yield`: furnizeazÄƒ valoarea lui `i`. Generatorul este acum "pauzat", È™i se Ã®nregistreazÄƒ valoarea `10`.

Apoi, invocÄƒm din nou funcÈ›ia cu metoda `next()`. Ea Ã®ncepe sÄƒ continue de unde s-a oprit anterior, Ã®ncÄƒ cu `i` egal cu `10`. Acum, Ã®ntÃ¢lneÈ™te urmÄƒtorul cuvÃ¢nt cheie `yield`, È™i furnizeazÄƒ `i * 2`. `i` este egal cu `10`, aÈ™a cÄƒ returneazÄƒ `10 * 2`, adicÄƒ `20`. Acest lucru duce la rezultatul `10, 20`.

</p>
</details>

---

###### 45. Ce returneazÄƒ asta?

```javascript
const firstPromise = new Promise((res, rej) => {
  setTimeout(res, 500, 'one');
});

const secondPromise = new Promise((res, rej) => {
  setTimeout(res, 100, 'two');
});

Promise.race([firstPromise, secondPromise]).then(res => console.log(res));
```

- A: `"one"`
- B: `"two"`
- C: `"two" "one"`
- D: `"one" "two"`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: B

Atunci cÃ¢nd transmitem mai multe promisiuni metodei `Promise.race`, ea rezolvÄƒ/rejecteazÄƒ _prima_ promisiune care se rezolvÄƒ/rejecteazÄƒ. Pentru metoda `setTimeout`, transmitem un cronometru: 500ms pentru prima promisiune (`firstPromise`), È™i 100ms pentru a doua promisiune (`secondPromise`). Acest lucru Ã®nseamnÄƒ cÄƒ `secondPromise` se rezolvÄƒ primul cu valoarea `'two'`. `res` conÈ›ine acum valoarea `'two'`, care se Ã®nregistreazÄƒ Ã®n consolÄƒ.

</p>
</details>

---

###### 46. Care este resultatul?

```javascript
let person = { name: 'Lydia' };
const members = [person];
person = null;

console.log(members);
```

- A: `null`
- B: `[null]`
- C: `[{}]`
- D: `[{ name: "Lydia" }]`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: D

Ãn primul rÃ¢nd, declarÄƒm o variabilÄƒ `person` cu valoarea unui obiect care are o proprietate `name`.

<img src="https://i.imgur.com/TML1MbS.png" width="200">

Apoi, declarÄƒm o variabilÄƒ numitÄƒ `members`. SetÄƒm primul element al acestui array egal cu valoarea variabilei `person`. Obiectele interacÈ›ioneazÄƒ prin _referinÈ›Äƒ_ atunci cÃ¢nd le setÄƒm egale Ã®ntre ele. Atunci cÃ¢nd atribuiÈ›i o referinÈ›Äƒ de la o variabilÄƒ la alta, faceÈ›i o _copie_ a acelei referinÈ›e. (notaÈ›i cÄƒ acestea nu au _aceaÈ™i_ referinÈ›Äƒ!)

<img src="https://i.imgur.com/FSG5K3F.png" width="300">

Apoi, setÄƒm variabila `person` egalÄƒ cu `null`.

<img src="https://i.imgur.com/sYjcsMT.png" width="300">

Noi modificÄƒm doar valoarea variabilei `person` nu È™i primul element din array, deoarece acel element are o referinÈ›Äƒ diferitÄƒ (copiatÄƒ) la obiect. Primul element din `members` Ã®ncÄƒ pÄƒstreazÄƒ referinÈ›a sa la obiectul original. CÃ¢nd Ã®nregistrÄƒm Ã®n consolÄƒ array-ul `members` primul element pÄƒstreazÄƒ valoarea obiectului, care este afiÈ™atÄƒ Ã®n consolÄƒ.

</p>
</details>

---

###### 47. Care este rezultatul?

```javascript
const person = {
  name: 'Lydia',
  age: 21,
};

for (const item in person) {
  console.log(item);
}
```

- A: `{ name: "Lydia" }, { age: 21 }`
- B: `"name", "age"`
- C: `"Lydia", 21`
- D: `["name", "Lydia"], ["age", 21]`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: B

Cu un ciclu `for-in` putem itera prin cheile obiectului, Ã®n acest caz `name` È™i `age`. Ãn interior, cheile obiectului sunt È™iruri de caractere (dacÄƒ nu sunt de tip Symbol). Ãn fiecare iteraÈ›ie, setÄƒm valoarea lui `item` egalÄƒ cu cheia curentÄƒ pe care o parcurge. Mai Ã®ntÃ¢i, `item` este egal cu `name`, È™i este Ã®nregistrat Ã®n consolÄƒ. Apoi, `item` este egal cu `age`, care este, de asemenea, Ã®nregistrat Ã®n consolÄƒ.

</p>
</details>

---

###### 48. Care este rezultatul?

```javascript
console.log(3 + 4 + '5');
```

- A: `"345"`
- B: `"75"`
- C: `12`
- D: `"12"`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: B

Asociativitatea operatorilor este ordinea Ã®n care compilatorul evalueazÄƒ expresiile, fie de la stÃ¢nga la dreapta, fie de la dreapta la stÃ¢nga. Acest lucru se Ã®ntÃ¢mplÄƒ doar dacÄƒ toÈ›i operatorii au aceeaÈ™i precedenÈ›Äƒ. Ãn cazul nostru, avem doar un tip de operator: `+`. Pentru adunare, asociativitatea este de la stÃ¢nga la dreapta.

`3 + 4` este evaluat mai Ã®ntÃ¢i. Acest lucru duce la numÄƒrul `7`.

`7 + '5'` duce la rezultatul `"75"` datoritÄƒ coerÈ›iei. JavaScript converteÈ™te numÄƒrul `7` Ã®ntr-un È™ir de caractere, aÈ™a cum am discutat Ã®n Ã®ntrebarea 15. Putem concatena douÄƒ È™iruri de caractere folosind operatorul `+`. `"7" + "5"` rezultÄƒ Ã®n `"75"`.

</p>
</details>

---

###### 49. Care este valoarea lui`num`?

```javascript
const num = parseInt('7*6', 10);
```

- A: `42`
- B: `"42"`
- C: `7`
- D: `NaN`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: C

Este returnat doar primul numÄƒr din È™ir. Bazat pe _radix_ (al doilea argument pentru a specifica Ã®n ce tip de numÄƒr dorim sÄƒ-l parsÄƒm: bazÄƒ 10, hexazecimal, octal, binar, etc.), `parseInt` verificÄƒ dacÄƒ caracterele din È™ir sunt valide. OdatÄƒ ce Ã®ntÃ¢lneÈ™te un caracter care nu este un numÄƒr valid Ã®n baza specificatÄƒ, opreÈ™te parsarea È™i ignorÄƒ caracterele ulterioare.

`*` nu este un numÄƒr valid. ParseazÄƒ doar `"7"` Ã®n numÄƒrul zecimal `7`. Acum, `num` conÈ›ine valoarea `7`.

</p>
</details>

---

###### 50. Care este rezultatul?

```javascript
[1, 2, 3].map(num => {
  if (typeof num === 'number') return;
  return num * 2;
});
```

- A: `[]`
- B: `[null, null, null]`
- C: `[undefined, undefined, undefined]`
- D: `[ 3 x empty ]`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: C

CÃ¢nd se parcurge array-ul, valoarea lui `num` este egalÄƒ cu elementul prin care parcurge Ã®n acel moment. Ãn acest caz, elementele sunt numere, astfel cÄƒ condiÈ›ia din instrucÈ›iunea `typeof num === "number"` returneazÄƒ `true`. FuncÈ›ia map creeazÄƒ un nou array È™i introduce valorile returnate de funcÈ›ie.

Cu toate acestea, nu returnÄƒm o valoare. Atunci cÃ¢nd nu returnÄƒm o valoare din funcÈ›ie, funcÈ›ia returneazÄƒ `undefined`. Pentru fiecare element din array, blocul funcÈ›iei este apelat, deci pentru fiecare element returnÄƒm `undefined`.

</p>
</details>

---

###### 51. Care este rezultatul?

```javascript
function getInfo(member, year) {
  member.name = 'Lydia';
  year = '1998';
}

const person = { name: 'Sarah' };
const birthYear = '1997';

getInfo(person, birthYear);

console.log(person, birthYear);
```

- A: `{ name: "Lydia" }, "1997"`
- B: `{ name: "Sarah" }, "1998"`
- C: `{ name: "Lydia" }, "1998"`
- D: `{ name: "Sarah" }, "1997"`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: A

Argumentele sunt transmise prin _valoare_, cu excepÈ›ia cazului Ã®n care valoarea lor este un obiect, caz Ã®n care sunt transmise prin _referinÈ›Äƒ_. `birthYear` este transmis prin valoare, deoarece este un È™ir de caractere (string), nu un obiect. Atunci cÃ¢nd transmitem argumente prin valoare, se creeazÄƒ o _copie_ a acelei valori (consultaÈ›i Ã®ntrebarea 46).

Variabila `birthYear` are o referinÈ›Äƒ la valoarea `"1997"`. Argumentul `year` are, de asemenea, o referinÈ›Äƒ la valoarea `"1997"`, dar nu este aceeaÈ™i valoare la care se referÄƒ `birthYear`. Atunci cÃ¢nd actualizÄƒm valoarea lui `year` prin setarea lui `year` egal cu `"1998"`, actualizÄƒm doar valoarea lui `year`. `birthYear` rÄƒmÃ¢ne Ã®n continuare egal cu `"1997"`.

Valoarea lui `person` este un obiect. Argumentul `member` are o referinÈ›Äƒ (copiatÄƒ) cÄƒtre _acelaÈ™i_ obiect. Atunci cÃ¢nd modificÄƒm o proprietate a obiectului la care se referÄƒ `member` valoarea lui `person` va fi de asemenea modificatÄƒ, deoarece ambele au o referinÈ›Äƒ la acelaÈ™i obiect. Proprietatea `name` a lui `person` este acum egalÄƒ cu valoarea `"Lydia"`.

</p>
</details>

---

###### 52. Care este rezultatul?

```javascript
function greeting() {
  throw 'Hello world!';
}

function sayHi() {
  try {
    const data = greeting();
    console.log('It worked!', data);
  } catch (e) {
    console.log('Oh no an error:', e);
  }
}

sayHi();
```

- A: `It worked! Hello world!`
- B: `Oh no an error: undefined`
- C: `SyntaxError: can only throw Error objects`
- D: `Oh no an error: Hello world!`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: D

Cu instrucÈ›iunea `throw` putem crea erori personalizate. Cu aceastÄƒ instrucÈ›iune, puteÈ›i arunca excepÈ›ii. O excepÈ›ie poate fi un <b>È™ir de caractere</b>, un <b>numÄƒr</b>, un <b>boolean</b> sau un <b>obiect</b>. Ãn acest caz, excepÈ›ia noastrÄƒ este È™irul `'Hello world!'`.

Cu instrucÈ›iunea `catch` putem specifica ce sÄƒ facem dacÄƒ o excepÈ›ie este aruncatÄƒ Ã®n blocul `try`. O excepÈ›ie este aruncatÄƒ: È™irul `'Hello world!'`. `e` este acum egal cu acel È™ir, pe care Ã®l Ã®nregistrÄƒm. Acest lucru duce la rezultatul `'Oh an error: Hello world!'`.

</p>
</details>

---

###### 53. Care este rezultatul?

```javascript
function Car() {
  this.make = 'Lamborghini';
  return { make: 'Maserati' };
}

const myCar = new Car();
console.log(myCar.make);
```

- A: `"Lamborghini"`
- B: `"Maserati"`
- C: `ReferenceError`
- D: `TypeError`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: B

Atunci cÃ¢nd o funcÈ›ie constructor este apelatÄƒ cu cuvÃ¢ntul cheie `new`, aceasta creeazÄƒ un obiect È™i stabileÈ™te cuvÃ¢ntul cheie `this` sÄƒ se refere la acel obiect. Ãn mod implicit, dacÄƒ funcÈ›ia constructor nu returneazÄƒ explicit nimic, va returna obiectul creat recent.

Ãn acest caz, funcÈ›ia constructor `Car` returneazÄƒ Ã®n mod explicit un obiect nou cu proprietatea `make` setatÄƒ la `"Maserati"`, ceea ce suprascrie comportamentul implicit. Prin urmare, atunci cÃ¢nd este apelat `new Car()` obiectul _returnat_ este atribuit lui `myCar`, ceea ce duce la rezultatul `"Maserati"` atunci cÃ¢nd se acceseazÄƒ `myCar.make`.

</p>
</details>

---

###### 54. Care este rezultatul?

```javascript
(() => {
  let x = (y = 10);
})();

console.log(typeof x);
console.log(typeof y);
```

- A: `"undefined", "number"`
- B: `"number", "number"`
- C: `"object", "number"`
- D: `"number", "undefined"`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: A

`let x = (y = 10);` este de fapt o prescurtare pentru

```javascript
y = 10;
let x = y;
```

CÃ¢nd setÄƒm `y` egal cu `10`, adÄƒugÄƒm de fapt o proprietate `y` la obiectul global (`window` Ã®ntr-un browser, `global` Ã®n Node). Ãntr-un browser, `window.y` este acum egal cu `10`.

Apoi, declarÄƒm o variabilÄƒ `x` cu valoarea `y`, care este `10`. Variabilele declarate cu cuvÃ¢ntul cheie `let` au domeniu de bloc _block scoped_, ele sunt definite doar Ã®n blocul Ã®n care sunt declarate; Ã®n cazul de faÈ›Äƒ, Ã®n funcÈ›ia expresie invocatÄƒ imediat (IIFE). Atunci cÃ¢nd folosim operatorul `typeof` operandul `x` nu este definit: Ã®ncercÄƒm sÄƒ accesÄƒm `x` Ã®n afara blocului Ã®n care este declarat. Acest lucru Ã®nseamnÄƒ cÄƒ `x` nu este definit. Valorile care nu au primit o valoare sau nu au fost declarate sunt de tip `"undefined"`. `console.log(typeof x)` returneazÄƒ `"undefined"`.

Cu toate acestea, am creat o variabilÄƒ globalÄƒ `y` atunci cÃ¢nd am setat `y` egal cu `10`. AceastÄƒ valoare este accesibilÄƒ oriunde Ã®n codul nostru. `y` este definitÄƒ È™i deÈ›ine o valoare de tip `"number"`. `console.log(typeof y)` returneazÄƒ `"number"`.

</p>
</details>

---

###### 55. Care este rezultatul?

```javascript
class Dog {
  constructor(name) {
    this.name = name;
  }
}

Dog.prototype.bark = function() {
  console.log(`Woof I am ${this.name}`);
};

const pet = new Dog('Mara');

pet.bark();

delete Dog.prototype.bark;

pet.bark();
```

- A: `"Woof I am Mara"`, `TypeError`
- B: `"Woof I am Mara"`, `"Woof I am Mara"`
- C: `"Woof I am Mara"`, `undefined`
- D: `TypeError`, `TypeError`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: A

Putem È™terge proprietÄƒÈ›i din obiecte folosind cuvÃ¢ntul cheie `delete` inclusiv de pe prototip. Prin È™tergerea unei proprietÄƒÈ›i de pe prototip, aceasta nu mai este disponibilÄƒ Ã®n lanÈ›ul prototipului. Ãn acest caz, funcÈ›ia `bark` nu mai este disponibilÄƒ pe prototip dupÄƒ `delete Dog.prototype.bark`, dar Ã®ncercÄƒm totuÈ™i sÄƒ o accesÄƒm.

CÃ¢nd Ã®ncercÄƒm sÄƒ apelÄƒm ceva care nu este o funcÈ›ie, este aruncatÄƒ o excepÈ›ie  `TypeError`. Ãn acest caz, se genereazÄƒ eroarea `TypeError: pet.bark is not a function`, deoarece `pet.bark` este `undefined`.

</p>
</details>

---

###### 56. Care este rezultatul?

```javascript
const set = new Set([1, 1, 2, 3, 4]);

console.log(set);
```

- A: `[1, 1, 2, 3, 4]`
- B: `[1, 2, 3, 4]`
- C: `{1, 1, 2, 3, 4}`
- D: `{1, 2, 3, 4}`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: D

Obiectul `Set` este o colecÈ›ie de valori unice: o valoare poate apÄƒrea doar o singurÄƒ datÄƒ Ã®ntr-un set.

m transmis iterable-ul `[1, 1, 2, 3, 4]` cu o valoare duplicatÄƒ `1`. Deoarece nu putem avea douÄƒ valori identice Ã®ntr-un set, una dintre ele este eliminatÄƒ. Acest lucru duce la rezultatul `{1, 2, 3, 4}`.

</p>
</details>

---

###### 57. Care este rezultatul?

```javascript
// counter.js
let counter = 10;
export default counter;
```

```javascript
// index.js
import myCounter from './counter';

myCounter += 1;

console.log(myCounter);
```

- A: `10`
- B: `11`
- C: `Error`
- D: `NaN`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: C

Un modul importat este _doar pentru citire_: nu puteÈ›i modifica modulul importat. Doar modulul care le exportÄƒ poate schimba valorile acestora.

CÃ¢nd Ã®ncercÄƒm sÄƒ incrementÄƒm valoarea lui `myCounter`, apare o eroare: `myCounter` este doar pentru citire È™i nu poate fi modificat.

</p>
</details>

---

###### 58. Care este rezultatul?

```javascript
const name = 'Lydia';
age = 21;

console.log(delete name);
console.log(delete age);
```

- A: `false`, `true`
- B: `"Lydia"`, `21`
- C: `true`, `true`
- D: `undefined`, `undefined`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: A

Operatorul `delete` returneazÄƒ o valoare booleanÄƒ: `true` Ã®n cazul È™tergerii reuÈ™ite, Ã®n caz contrar va returna `false`. Cu toate acestea, variabilele declarate cu cuvintele cheie `var`, `const` sau `let` nu pot fi È™terse folosind operatorul `delete`.

Variabila `name` a fost declaratÄƒ cu cuvÃ¢ntul cheie `const` aÈ™a cÄƒ È™tergerea sa nu reuÈ™eÈ™te: se returneazÄƒ `false`. Atunci cÃ¢nd setÄƒm `age` egal cu `21`, de fapt am adÄƒugat o proprietate numitÄƒ `age` la obiectul global. Ãn acest fel, puteÈ›i È™terge cu succes proprietÄƒÈ›i din obiecte, inclusiv din obiectul global, aÈ™a cÄƒ `delete age` returneazÄƒ `true`.

</p>
</details>

---

###### 59. Care este rezultatul?

```javascript
const numbers = [1, 2, 3, 4, 5];
const [y] = numbers;

console.log(y);
```

- A: `[[1, 2, 3, 4, 5]]`
- B: `[1, 2, 3, 4, 5]`
- C: `1`
- D: `[1]`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: C

Putem dezasambla (unpack) valori din array-uri sau proprietÄƒÈ›i din obiecte prin destructurare. De exemplu:

```javascript
[a, b] = [1, 2];
```

<img src="https://i.imgur.com/ADFpVop.png" width="200">

Valoarea lui `a` este acum `1`, iar valoarea lui `b` este acum `2`. Ceea ce am fÄƒcut Ã®n Ã®ntrebare este:

```javascript
[y] = [1, 2, 3, 4, 5];
```

<img src="https://i.imgur.com/NzGkMNk.png" width="200">

Acest lucru Ã®nseamnÄƒ cÄƒ valoarea lui `y` este egalÄƒ cu prima valoare din array, care este numÄƒrul `1`. CÃ¢nd Ã®nregistrÄƒm Ã®n consolÄƒ `y`, se returneazÄƒ `1`.

</p>
</details>

---

###### 60. Care este rezultatul?

```javascript
const user = { name: 'Lydia', age: 21 };
const admin = { admin: true, ...user };

console.log(admin);
```

- A: `{ admin: true, user: { name: "Lydia", age: 21 } }`
- B: `{ admin: true, name: "Lydia", age: 21 }`
- C: `{ admin: true, user: ["Lydia", 21] }`
- D: `{ admin: true }`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: B

Este posibil sÄƒ combinÄƒm obiecte folosind operatorul de rÄƒspÃ¢ndire`...`. Acesta vÄƒ permite sÄƒ creaÈ›i copii ale perechilor cheie/valoare dintr-un obiect È™i sÄƒ le adÄƒugaÈ›i la alt obiect. Ãn acest caz, creÄƒm copii ale obiectului `user` È™i le adÄƒugÄƒm la obiectul `admin`. Obiectul `admin` conÈ›ine acum perechile cheie/valoare copiate, ceea ce duce la rezultatul `{ admin: true, name: "Lydia", age: 21 }`.

</p>
</details>

---

###### 61. Care este rezultatul?

```javascript
const person = { name: 'Lydia' };

Object.defineProperty(person, 'age', { value: 21 });

console.log(person);
console.log(Object.keys(person));
```

- A: `{ name: "Lydia", age: 21 }`, `["name", "age"]`
- B: `{ name: "Lydia", age: 21 }`, `["name"]`
- C: `{ name: "Lydia"}`, `["name", "age"]`
- D: `{ name: "Lydia"}`, `["age"]`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: B

Cu metoda `defineProperty` putem adÄƒuga noi proprietÄƒÈ›i la un obiect sau sÄƒ modificÄƒm cele existente. Atunci cÃ¢nd adÄƒugÄƒm o proprietate la un obiect folosind metoda `defineProperty` aceasta nu este, Ã®n mod implicit, _nu enumerabilÄƒ_. Metoda `Object.keys` returneazÄƒ toate numele de proprietÄƒÈ›i _enumerabile_ dintr-un obiect, Ã®n acest caz doar `"name"`.

ProprietÄƒÈ›ile adÄƒugate folosind metoda `defineProperty` sunt, Ã®n mod implicit, imutabile (nu pot fi schimbate). PuteÈ›i anula acest comportament folosind proprietÄƒÈ›ile `writable`, `configurable` È™i `enumerable` Ãn acest fel, metoda `defineProperty` vÄƒ oferÄƒ un control mai mare asupra proprietÄƒÈ›ilor pe care le adÄƒugaÈ›i la un obiect.

</p>
</details>

---

###### 62. Care este rezultatul?

```javascript
const settings = {
  username: 'lydiahallie',
  level: 19,
  health: 90,
};

const data = JSON.stringify(settings, ['level', 'health']);
console.log(data);
```

- A: `"{"level":19, "health":90}"`
- B: `"{"username": "lydiahallie"}"`
- C: `"["level", "health"]"`
- D: `"{"username": "lydiahallie", "level":19, "health":90}"`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: A

Al doilea argument al funcÈ›iei `JSON.stringify` este _replacer-ul_. Replacer-ul poate fi fie o funcÈ›ie, fie un array, È™i vÄƒ permite sÄƒ controlaÈ›i ce È™i cum ar trebui sÄƒ fie serializate (convertite Ã®n È™ir de caractere) valorile.

DacÄƒ replacer-ul este un _array_, Ã®n È™irul JSON vor fi incluse doar numele de proprietÄƒÈ›i care sunt prezente Ã®n array. Ãn acest caz, doar proprietÄƒÈ›ile cu numele `"level"` È™i `"health"` sunt incluse, Ã®n timp ce `"username"` este exclus. Astfel, `data` devine egal cu `"{"level":19, "health":90}"`.

DacÄƒ replacer-ul este o _funcÈ›ie_, aceastÄƒ funcÈ›ie este apelatÄƒ pentru fiecare proprietate din obiectul pe care Ã®l serializaÈ›i. Valoarea returnatÄƒ de aceastÄƒ funcÈ›ie va fi valoarea proprietÄƒÈ›ii atunci cÃ¢nd este adÄƒugatÄƒ Ã®n È™irul JSON. DacÄƒ valoarea este `undefined`, aceastÄƒ proprietate este exclusÄƒ din È™irul JSON.

</p>
</details>

---

###### 63. Care este rezultatul?

```javascript
let num = 10;

const increaseNumber = () => num++;
const increasePassedNumber = number => number++;

const num1 = increaseNumber();
const num2 = increasePassedNumber(num1);

console.log(num1);
console.log(num2);
```

- A: `10`, `10`
- B: `10`, `11`
- C: `11`, `11`
- D: `11`, `12`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: A

Operatorul unary `++` _returneazÄƒ mai Ã®ntÃ¢i_ valoarea operandului È™i _apoi incrementeazÄƒ_ valoarea operandului. Valoarea lui `num1` este `10`, deoarece funcÈ›ia `increaseNumber` returneazÄƒ mai Ã®ntÃ¢i valoarea lui `num`, care este `10`, È™i numai apoi incrementeazÄƒ valoarea lui `num`.

`num2` este `10`, deoarece am transmis `num1` cÄƒtre funcÈ›ia `increasePassedNumber`. `number` ieste egal cu `10`(valoarea lui `num1`). IarÄƒÈ™i, operatorul unary `++` _returneazÄƒ mai Ã®ntÃ¢i_ valoarea operandului È™i _apoi incrementeazÄƒs_ valoarea operandului. Valoarea lui `number` este `10`, aÈ™a cÄƒ `num2` este egal cu `10`.

</p>
</details>

---

###### 64. Care este rezultatul?

```javascript
const value = { number: 10 };

const multiply = (x = { ...value }) => {
  console.log((x.number *= 2));
};

multiply();
multiply();
multiply(value);
multiply(value);
```

- A: `20`, `40`, `80`, `160`
- B: `20`, `40`, `20`, `40`
- C: `20`, `20`, `20`, `40`
- D: `NaN`, `NaN`, `20`, `40`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: C

Ãn ES6, putem iniÈ›ializa parametri cu o valoare implicitÄƒ. Valoarea parametrului va fi valoarea implicitÄƒ, dacÄƒ nu a fost furnizatÄƒ nicio altÄƒ valoare funcÈ›iei sau dacÄƒ valoarea parametrului este `"undefined"`. Ãn acest caz, rÄƒspÃ¢ndim proprietÄƒÈ›ile obiectului `value`  Ã®ntr-un obiect nou, astfel Ã®ncÃ¢t `x` are valoarea implicitÄƒ `{ number: 10 }`.

Argumentul implicit este evaluat la _momentul apelului_! De fiecare datÄƒ cÃ¢nd apelÄƒm funcÈ›ia, se creeazÄƒ un obiect _nou_. InvocÄƒm funcÈ›ia `multiply` primele douÄƒ ori fÄƒrÄƒ a furniza o valoare: `x` are valoarea implicitÄƒ `{ number: 10 }`. Apoi Ã®nregistrÄƒm Ã®n consolÄƒ valoarea Ã®nmulÈ›itÄƒ a acelui numÄƒr, care este `20`.

A treia oarÄƒ cÃ¢nd apelÄƒm `multiply`, furnizÄƒm un argument: obiectul numit `value`. Operatorul `*=` este, de fapt, o prescurtare pentru `x.number = x.number * 2`: modificÄƒm valoarea lui`x.number`, È™i Ã®nregistrÄƒm Ã®n consolÄƒ valoarea Ã®nmulÈ›itÄƒ, care este `20`.

A patra oarÄƒ, trecem din nou obiectul `value`. `x.number` a fost modificat anterior la `20`, deci `x.number *= 2` Ã®nregistreazÄƒ `40`.

</p>
</details>

---

###### 65. Care este rezultatul?

```javascript
[1, 2, 3, 4].reduce((x, y) => console.log(x, y));
```

- A: `1` `2` È™i `3` `3` È™i `6` `4`
- B: `1` `2` È™i `2` `3` È™i `3` `4`
- C: `1` `undefined` È™i `2` `undefined` È™i `3` `undefined` È™i `4` `undefined`
- D: `1` `2` È™i `undefined` `3` È™i `undefined` `4`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: D

Primul argument pe care Ã®l primeÈ™te metoda `reduce` este _acumulator-ul_, `x` Ã®n acest caz. Al doilea argument este _valoarea curentÄƒ_, `y`. Cu metoda `reduce`, executÄƒm o funcÈ›ie de apel pe fiecare element din array, ceea ce poate duce Ã®n cele din urmÄƒ la o singurÄƒ valoare.

Ãn acest exemplu, nu returnÄƒm nicio valoare, ci doar Ã®nregistrÄƒm valorile accumulatorului È™i valorii curente.

Valoarea accumulatorului este egalÄƒ cu valoarea returnatÄƒ anterior de funcÈ›ia de apel. DacÄƒ nu furnizaÈ›i argumentul opÈ›ional `initialValue` metodei `reduce`, accumulatorul este egal cu primul element la prima apelare.

La prima apelare, accumulatorul (`x`) este `1`, iar valoarea curentÄƒ (`y`) este `2`. Nu returnÄƒm din funcÈ›ia de apel, ci Ã®nregistrÄƒm valorile accumulatorului È™i valoarea curentÄƒ: se Ã®nregistreazÄƒ `1` È™i `2`.

DacÄƒ nu returnaÈ›i o valoare dintr-o funcÈ›ie, aceasta va returna `undefined`. OLa urmÄƒtoarea apelare, accumulatorul este `undefined`, iar valoarea curentÄƒ este `3`. Se Ã®nregistreazÄƒ `undefined` È™i `3`.

La a patra apelare, din nou nu returnÄƒm din funcÈ›ia de apel. Accumulatorul este din nou `undefined`, iar valoarea curentÄƒ este `4`. Se Ã®nregistreazÄƒ `undefined` È™i `4`.

</p>
</details>
  
---

###### 66. Cu ce constructor putem extinde cu succes clasa `Dog`?

```javascript
class Dog {
  constructor(name) {
    this.name = name;
  }
};

class Labrador extends Dog {
  // 1
  constructor(name, size) {
    this.size = size;
  }
  // 2
  constructor(name, size) {
    super(name);
    this.size = size;
  }
  // 3
  constructor(size) {
    super(name);
    this.size = size;
  }
  // 4
  constructor(name, size) {
    this.name = name;
    this.size = size;
  }

};
```

- A: 1
- B: 2
- C: 3
- D: 4

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: B

Ãntr-o clasÄƒ derivatÄƒ, nu puteÈ›i accesa cuvÃ¢ntul cheie `this` Ã®nainte de a apela `super`. DacÄƒ Ã®ncercaÈ›i sÄƒ faceÈ›i acest lucru, va arunca o ReferenceError: 1 È™i 4 ar arunca o eroare de referinÈ›Äƒ.

Cu cuvÃ¢ntul cheie `super`, apelÄƒm constructorul clasei pÄƒrinte cu argumentele date. Constructorul pÄƒrintelui primeÈ™te argumentul `name`, deci trebuie sÄƒ transmitem `name` la `super`.

Clasa `Labrador` primeÈ™te doi argumente, `name` deoarece extinde clasa `Dog`, È™i `size` ca o proprietate suplimentarÄƒ Ã®n clasa `Labrador`. Ambele trebuie sÄƒ fie transmise funcÈ›iei constructor din clasa `Labrador`, ceea ce se face corect utilizÃ¢nd constructorul 2.

</p>
</details>

---

###### 67. Care este rezultatul?

```javascript
// index.js
console.log('running index.js');
import { sum } from './sum.js';
console.log(sum(1, 2));

// sum.js
console.log('running sum.js');
export const sum = (a, b) => a + b;
```

- A: `running index.js`, `running sum.js`, `3`
- B: `running sum.js`, `running index.js`, `3`
- C: `running sum.js`, `3`, `running index.js`
- D: `running index.js`, `undefined`, `running sum.js`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: B

Cu cuvÃ¢ntul cheie `import`, toate modulele importate sunt _preparate Ã®n prealabil_. Acest lucru Ã®nseamnÄƒ cÄƒ modulele importate sunt executate _mai Ã®ntÃ¢i_, codul din fiÈ™ierul care importÄƒ modulul este executat _dupÄƒ accea_.

Acesta este un diferenÈ›Äƒ Ã®ntre `require()` Ã®n CommonJS È™i `import`! Cu `require()`, puteÈ›i Ã®ncÄƒrca dependenÈ›ele la cerere Ã®n timp ce codul este Ã®n curs de desfÄƒÈ™urare. DacÄƒ am fi folosit `require` Ã®n loc de `import`, ar fi fost Ã®nregistrate Ã®n consolÄƒ mesajele `running index.js`, `running sum.js`, `3`.

</p>
</details>

---

###### 68. Care este rezultatul?

```javascript
console.log(Number(2) === Number(2));
console.log(Boolean(false) === Boolean(false));
console.log(Symbol('foo') === Symbol('foo'));
```

- A: `true`, `true`, `false`
- B: `false`, `true`, `false`
- C: `true`, `false`, `true`
- D: `true`, `true`, `true`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: A

Fiecare Symbol este complet unic. Scopul argumentului furnizat cÄƒtre Symbol este de a oferi Symbolului o descriere. Valoarea Symbolului nu depinde de argumentul furnizat. Ãn timp ce testÄƒm egalitatea, creÄƒm douÄƒ simboluri complet noi: primul `Symbol('foo')`, È™i al doilea `Symbol('foo')`. Aceste douÄƒ valori sunt unice È™i nu sunt egale Ã®ntre ele, `Symbol('foo') === Symbol('foo')` returneazÄƒ `false`.

</p>
</details>

---

###### 69. Care este rezultatul?

```javascript
const name = 'Lydia Hallie';
console.log(name.padStart(13));
console.log(name.padStart(2));
```

- A: `"Lydia Hallie"`, `"Lydia Hallie"`
- B: `" Lydia Hallie"`, `" Lydia Hallie"` (`"[13x whitespace]Lydia Hallie"`, `"[2x whitespace]Lydia Hallie"`)
- C: `" Lydia Hallie"`, `"Lydia Hallie"` (`"[1x whitespace]Lydia Hallie"`, `"Lydia Hallie"`)
- D: `"Lydia Hallie"`, `"Lyd"`,

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: C

Cu metoda `padStart` putem adÄƒuga umpluturÄƒ la Ã®nceputul unui È™ir. Valoarea transmisÄƒ acestei metode este lungimea _totalÄƒ_ a È™irului Ã®mpreunÄƒ cu umplutura. È˜irul `"Lydia Hallie"` are o lungime de `12`. `name.padStart(13)` introduce 1 spaÈ›iu la Ã®nceputul È™irului, deoarece 12 + 1 este 13.

DacÄƒ argumentul transmis metodei `padStart` este mai mic decÃ¢t lungimea È™irului, nu va fi adÄƒugatÄƒ nicio umpluturÄƒ.

</p>
</details>

---

###### 70. Care este rezultatul?

```javascript
console.log('ğŸ¥‘' + 'ğŸ’»');
```

- A: `"ğŸ¥‘ğŸ’»"`
- B: `257548`
- C: Un È™ir care conÈ›ine punctele de cod ale caracterelor
- D: Eroare

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: A

Cu operatorul `+`, puteÈ›i concatena È™iruri. Ãn acest caz, concatenÄƒm È™irul `"ğŸ¥‘"` cu È™irul `"ğŸ’»"`, rezultÃ¢nd `"ğŸ¥‘ğŸ’»"`.

</p>
</details>

---

###### 71. Cum putem Ã®nregistra valorile aflate Ã®n comentarii dupÄƒ instrucÈ›iunea console.log?

```javascript
function* startGame() {
  const answer = yield 'Do you love JavaScript?';
  if (answer !== 'Yes') {
    return "Oh wow... Guess we're done here";
  }
  return 'JavaScript loves you back â¤ï¸';
}

const game = startGame();
console.log(/* 1 */); // Do you love JavaScript?
console.log(/* 2 */); // JavaScript loves you back â¤ï¸
```

- A: `game.next("Yes").value` È™i `game.next().value`
- B: `game.next.value("Yes")` È™i `game.next.value()`
- C: `game.next().value` È™i `game.next("Yes").value`
- D: `game.next.value()` È™i `game.next.value("Yes")`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: C

O funcÈ›ie generator "pauzeazÄƒ" execuÈ›ia cÃ¢nd Ã®ntÃ¢lneÈ™te cuvÃ¢ntul cheie `yield`. Mai Ã®ntÃ¢i, trebuie sÄƒ permitem funcÈ›iei sÄƒ emitÄƒ È™irul "Do you love JavaScript?", ceea ce poate fi fÄƒcut apelÃ¢nd `game.next().value`.

Fiecare linie este executatÄƒ pÃ¢nÄƒ cÃ¢nd gÄƒseÈ™te primul cuvÃ¢nt cheie `yield`. ExistÄƒ un cuvÃ¢nt cheie `yield` pe prima linie din funcÈ›ie: execuÈ›ia se opreÈ™te cu primul `yield`. _Acest lucru Ã®nseamnÄƒ cÄƒ variabila `answer` nu este definitÄƒ Ã®ncÄƒ!_

CÃ¢nd apelÄƒm `game.next("Yes").value`, cuvÃ¢ntul cheie `yield` anterior este Ã®nlocuit cu valoarea parametrilor transmiÈ™i funcÈ›iei `next()`, `"Yes"` Ã®n acest caz. Valoarea variabilei `answer` este acum egalÄƒ cu `"Yes"`. CondiÈ›ia declaraÈ›iei if returneazÄƒ `false`, È™i `JavaScript loves you back â¤ï¸` este Ã®nregistrat Ã®n consolÄƒ.

</p>
</details>

---

###### 72. Care este rezultatul?

```javascript
console.log(String.raw`Hello\nworld`);
```

- A: `Hello world!`
- B: `Hello` <br />&nbsp; &nbsp; &nbsp;`world`
- C: `Hello\nworld`
- D: `Hello\n` <br /> &nbsp; &nbsp; &nbsp;`world`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: C

`String.raw` returneazÄƒ un È™ir Ã®n care escape-urile (`\n`, `\v`, `\t` etc.) sunt ignorate! Backslash-urile pot fi o problemÄƒ, deoarece puteÈ›i ajunge cu ceva similar cu:

`` const path = `C:\Documents\Projects\table.html` ``

Acest lucru ar rezulta Ã®n:

`"C:DocumentsProjects able.html"`

Cu `String.raw`, acesta ar ignora pur È™i simplu escape-ul È™i ar afiÈ™a:

`C:\Documents\Projects\table.html`

Ãn acest caz, È™irul este `Hello\nworld`, care este Ã®nregistrat Ã®n consolÄƒ.

</p>
</details>

---

###### 73. Care este rezultatul?

```javascript
async function getData() {
  return await Promise.resolve('I made it!');
}

const data = getData();
console.log(data);
```

- A: `"I made it!"`
- B: `Promise {<resolved>: "I made it!"}`
- C: `Promise {<pending>}`
- D: `undefined`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: C

O funcÈ›ie `async` Ã®ntotdeauna returneazÄƒ o promisiune. InstrucÈ›iunea `await` Ã®ncÄƒ trebuie sÄƒ aÈ™tepte ca promisiunea sÄƒ se rezolve: o promisiune Ã®n aÈ™teptare este returnatÄƒ atunci cÃ¢nd apelÄƒm `getData()` pentru a o atribui variabilei `data`.

DacÄƒ dorim sÄƒ avem acces la valoarea rezolvatÄƒ `"I made it"`, am putea folosi metoda `.then()` pe `data`:

`data.then(res => console.log(res))`

Acest lucru ar fi Ã®nregistrat `"I made it!"`

</p>
</details>

---

###### 74. Care este rezultatul?

```javascript
function addToList(item, list) {
  return list.push(item);
}

const result = addToList('apple', ['banana']);
console.log(result);
```

- A: `['apple', 'banana']`
- B: `2`
- C: `true`
- D: `undefined`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: B

Metoda`.push()` returneazÄƒ _lungimea_ noului È™ir! Ãnainte, È™irul conÈ›inea un element (È™irul `"banana"`) È™i avea o lungime de `1`. DupÄƒ adÄƒugarea È™irului `"apple"` Ã®n È™ir, È™irul conÈ›ine douÄƒ elemente È™i are o lungime de `2`. Aceasta este valoarea returnatÄƒ de funcÈ›ia `addToList`.

Metoda `push` modificÄƒ È™irul original. DacÄƒ doreaÈ›i sÄƒ returnaÈ›i _È™irul_ din funcÈ›ie Ã®n loc de _lungimea È™irului_, ar fi trebuit sÄƒ returnaÈ›i `list` dupÄƒ ce aÈ›i adÄƒugat `item` la el.

</p>
</details>

---

###### 75. Care este rezultatul?

```javascript
const box = { x: 10, y: 20 };

Object.freeze(box);

const shape = box;
shape.x = 100;

console.log(shape);
```

- A: `{ x: 100, y: 20 }`
- B: `{ x: 10, y: 20 }`
- C: `{ x: 100 }`
- D: `ReferenceError`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: B

`Object.freeze` face imposibilÄƒ adÄƒugarea, eliminarea sau modificarea proprietÄƒÈ›ilor unui obiect (cu excepÈ›ia cazului Ã®n care valoarea proprietÄƒÈ›ii este un alt obiect).

CÃ¢nd creÄƒm variabila `shape` È™i o setÄƒm egalÄƒ cu obiectul Ã®ngheÈ›at `box`, `shape` de asemenea se referÄƒ la un obiect Ã®ngheÈ›at. PuteÈ›i verifica dacÄƒ un obiect este Ã®ngheÈ›at folosind `Object.isFrozen`. Ãn acest caz, `Object.isFrozen(shape)` ar returna true, deoarece variabila `shape` are o referinÈ›Äƒ cÄƒtre un obiect Ã®ngheÈ›at.

Deoarece `shape` este Ã®ngheÈ›at È™i deoarece valoarea lui`x` nu este un obiect, nu putem modifica proprietatea `x`. `x` rÄƒmÃ¢ne egal cu `10`, È™i `{ x: 10, y: 20 }` este afiÈ™at Ã®n consolÄƒ.

</p>
</details>

---

###### 76. Care este rezultatul?

```javascript
const { firstName: myName } = { firstName: 'Lydia' };

console.log(firstName);
```

- A: `"Lydia"`
- B: `"myName"`
- C: `undefined`
- D: `ReferenceError`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: D

Folosind [destructuring assignment](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment) cu sintaxa de mai jos putem extrage valori din array-uri sau proprietÄƒÈ›i din obiecte Ã®n variabile distincte:

```javascript
const { firstName } = { firstName: 'Lydia' };
// ES5 version:
// var firstName = { firstName: 'Lydia' }.firstName;

console.log(firstName); // "Lydia"
```

De asemenea, o proprietate poate fi extras dintr-un obiect È™i atribuitÄƒ unei variabile cu un nume diferit decÃ¢t proprietatea obiectului:

```javascript
const { firstName: myName } = { firstName: 'Lydia' };
// ES5 version:
// var myName = { firstName: 'Lydia' }.firstName;

console.log(myName); // "Lydia"
console.log(firstName); // Uncaught ReferenceError: firstName is not defined
```

Prin urmare, `firstName` nu existÄƒ ca variabilÄƒ, astfel Ã®ncÃ¢t Ã®ncercarea de a accesa valoarea sa va genera o eroare `ReferenceError`.

**NotÄƒ:** FiÈ›i conÈ™tienÈ›i de proprietÄƒÈ›ile Ã®n `global scope` (spaÈ›iul global):

```javascript
const { name: myName } = { name: 'Lydia' };

console.log(myName); // "lydia"
console.log(name); // "" ----- Browser e.g. Chrome
console.log(name); // ReferenceError: name is not defined  ----- NodeJS

```

Ãn cazul Ã®n care JavaScript nu poate gÄƒsi o variabilÄƒ Ã®n _cadrul curent_, acesta urcÄƒ pe [Scope chain](https://github.com/getify/You-Dont-Know-JS/blob/2nd-ed/scope-closures/ch3.md) È™i o cautÄƒ. DacÄƒ ajunge la nivelul superior al cadrului, adicÄƒ la **spaÈ›iul global**, È™i tot nu o gÄƒseÈ™te, va arunca o excepÈ›ie `ReferenceError`.

- Ãn **Browser-e** cum ar fi _Chrome_, `name` este o _proprietate de spaÈ›iu global depÄƒÈ™itÄƒ_. Ãn acest exemplu, codul ruleazÄƒ Ã®n _spaÈ›iul global_ È™i nu existÄƒ o variabilÄƒ localÄƒ definitÄƒ de utilizator pentru `name`, aÈ™a cÄƒ cautÄƒ _variabilele/proprietÄƒÈ›ile_ predefinite Ã®n spaÈ›iul global, care Ã®n cazul browser-elor Ã®nseamnÄƒ cÄƒ cautÄƒ Ã®n obiectul `window` de unde extrage valoarea [window.name](https://developer.mozilla.org/en-US/docs/Web/API/Window/name) care este egalÄƒ cu un **È™ir gol**.

- Ãn **NodeJS**, nu existÄƒ o astfel de proprietate pe obiectul `global` aÈ™adar Ã®ncercarea de a accesa o variabilÄƒ inexistentÄƒ va genera o [ReferenceError](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Not_defined).

</p>
</details>

---

###### 77. Este aceasta o funcÈ›ie purÄƒ?

```javascript
function sum(a, b) {
  return a + b;
}
```

- A: Da
- B: Nu

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: A

O funcÈ›ie purÄƒ este o funcÈ›ie care _Ã®ntotdeauna_ returneazÄƒ acelaÈ™i rezultat, dacÄƒ aceleaÈ™i argumente sunt furnizate.

FuncÈ›ia `sum` Ã®ntotdeauna returneazÄƒ acelaÈ™i rezultat. DacÄƒ Ã®i furnizÄƒm `1` È™i `2`, va returna _Ã®ntotdeauna_ `3` fÄƒrÄƒ efecte secundare. DacÄƒ Ã®i furnizÄƒm `5` È™i `10`, va returna _Ã®ntotdeauna_ `15`, È™i tot aÈ™a. Aceasta este definiÈ›ia unei funcÈ›ii pure.

</p>
</details>

---

###### 78. Care este rezultatul?

```javascript
const add = () => {
  const cache = {};
  return num => {
    if (num in cache) {
      return `From cache! ${cache[num]}`;
    } else {
      const result = num + 10;
      cache[num] = result;
      return `Calculated! ${result}`;
    }
  };
};

const addFunction = add();
console.log(addFunction(10));
console.log(addFunction(10));
console.log(addFunction(5 * 2));
```

- A: `Calculated! 20` `Calculated! 20` `Calculated! 20`
- B: `Calculated! 20` `From cache! 20` `Calculated! 20`
- C: `Calculated! 20` `From cache! 20` `From cache! 20`
- D: `Calculated! 20` `From cache! 20` `Error`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: C

FuncÈ›ia `add` este o funcÈ›ie _memoizatÄƒ_. Cu ajutorul memoizÄƒrii, putem sÄƒ memorÄƒm rezultatele unei funcÈ›ii pentru a accelera execuÈ›ia ulterioarÄƒ. Ãn acest caz, creÄƒm un obiect `cache` care stocheazÄƒ valorile returnate anterior.

DacÄƒ apelÄƒm din nou funcÈ›ia `addFunction` cu acelaÈ™i argument, funcÈ›ia verificÄƒ mai Ã®ntÃ¢i dacÄƒ a primit deja acea valoare Ã®n memoria sa cache. DacÄƒ acest lucru este adevÄƒrat, se va returna valoarea din cache, economisind timp de execuÈ›ie. DacÄƒ nu este Ã®n cache, funcÈ›ia va calcula valoarea È™i o va memora ulterior.

ApelÄƒm funcÈ›ia `addFunction` de trei ori cu aceeaÈ™i valoare: Ã®n prima invocare, valoarea funcÈ›iei cÃ¢nd `num` este egal cu `10` nu este Ã®ncÄƒ Ã®n cache. CondiÈ›ia instrucÈ›iunii `num in cache` returneazÄƒ `false`, iar blocul `else` este executat: se afiÈ™eazÄƒ `Calculated! 20` iar valoarea rezultatului este adÄƒugatÄƒ Ã®n obiectul de cache. Acum, `cache` aratÄƒ astfel `{ 10: 20 }`.

A doua oarÄƒ, obiectul `cache` conÈ›ine valoarea care este returnatÄƒ pentru `10`. CondiÈ›ia instrucÈ›iunii `num in cache` returneazÄƒ `true`, È™i se afiÈ™eazÄƒ `'From cache! 20'`.

A treia oarÄƒ, trecem `5 * 2` funcÈ›iei, care este evaluat la `10`. Obiectul `cache` conÈ›ine valoarea care este returnatÄƒ pentru `10`. CondiÈ›ia instrucÈ›iunii `num in cache` returneazÄƒ `true`, È™i se afiÈ™eazÄƒ `'From cache! 20'`.

</p>
</details>

---

###### 79. Care este rezultatul?

```javascript
const myLifeSummedUp = ['â˜•', 'ğŸ’»', 'ğŸ·', 'ğŸ«'];

for (let item in myLifeSummedUp) {
  console.log(item);
}

for (let item of myLifeSummedUp) {
  console.log(item);
}
```

- A: `0` `1` `2` `3` È™i `"â˜•"` `"ğŸ’»"` `"ğŸ·"` `"ğŸ«"`
- B: `"â˜•"` `"ğŸ’»"` `"ğŸ·"` `"ğŸ«"` È™i `"â˜•"` `"ğŸ’»"` `"ğŸ·"` `"ğŸ«"`
- C: `"â˜•"` `"ğŸ’»"` `"ğŸ·"` `"ğŸ«"` È™i `0` `1` `2` `3`
- D: `0` `1` `2` `3` È™i `{0: "â˜•", 1: "ğŸ’»", 2: "ğŸ·", 3: "ğŸ«"}`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: A

Cu o buclÄƒ _for-in_, putem itera peste proprietÄƒÈ›ile **enumerabile**. Ãntr-un È™ir, proprietÄƒÈ›ile enumerate sunt "cheile" elementelor din È™ir, care sunt de fapt indexurile lor. PuteÈ›i vedea un È™ir ca:

`{0: "â˜•", 1: "ğŸ’»", 2: "ğŸ·", 3: "ğŸ«"}`

Unde cheile sunt proprietÄƒÈ›ile enumerate. `0` `1` `2` `3` sunt afiÈ™ate.

Cu o buclÄƒ _for-of_, putem itera peste obiecte **iterabile**. Un È™ir este un obiect iterabil. CÃ¢nd iterÄƒm peste È™ir, variabila "item" este egalÄƒ cu elementul pe care Ã®l parcurge Ã®n acel moment, sunt afiÈ™ate `"â˜•"` `"ğŸ’»"` `"ğŸ·"` `"ğŸ«"`.

</p>
</details>

---

###### 80. Care este rezultatul?

```javascript
const list = [1 + 2, 1 * 2, 1 / 2];
console.log(list);
```

- A: `["1 + 2", "1 * 2", "1 / 2"]`
- B: `["12", 2, 0.5]`
- C: `[3, 2, 0.5]`
- D: `[1, 1, 1]`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: C

Elementele dintr-un È™ir pot stoca orice valoare. Numere, È™iruri, obiecte, alte È™iruri, null, valori booleane, undefined È™i alte expresii precum date, funcÈ›ii È™i calculaÈ›ii.

Elementul va fi egal cu valoarea returnatÄƒ. `1 + 2` returneazÄƒ `3`, `1 * 2` returneazÄƒ `2`, È™i `1 / 2` returneazÄƒ `0.5`.

</p>
</details>

---

###### 81. Care este rezultatul?

```javascript
function sayHi(name) {
  return `Hi there, ${name}`;
}

console.log(sayHi());
```

- A: `Hi there,`
- B: `Hi there, undefined`
- C: `Hi there, null`
- D: `ReferenceError`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: B

Ãn mod implicit, argumentele au valoarea `undefined`, cu excepÈ›ia cazului Ã®n care s-a transmis o valoare funcÈ›iei. Ãn acest caz, nu am transmis o valoare pentru argumentul `name`. `name` este egal cu `undefined` iar acesta este afiÈ™at.

Ãn ES6, putem suprascrie aceastÄƒ valoare implicitÄƒ `undefined` cu parametri impliciti. De exemplu:

`function sayHi(name = "Lydia") { ... }`

Ãn acest caz, dacÄƒ nu am fi furnizat o valoare sau am fi furnizat `undefined`, `name` ar fi fost Ã®ntotdeauna egal cu È™irul `Lydia`.

</p>
</details>

---

###### 82. Care este rezultatul?

```javascript
var status = 'ğŸ˜';

setTimeout(() => {
  const status = 'ğŸ˜';

  const data = {
    status: 'ğŸ¥‘',
    getStatus() {
      return this.status;
    },
  };

  console.log(data.getStatus());
  console.log(data.getStatus.call(this));
}, 0);
```

- A: `"ğŸ¥‘"` È™i `"ğŸ˜"`
- B: `"ğŸ¥‘"` È™i `"ğŸ˜"`
- C: `"ğŸ˜"` È™i `"ğŸ˜"`
- D: `"ğŸ˜"` È™i `"ğŸ˜"`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: B

Valoarea cuvÃ¢ntului cheie `this` depinde de locul Ã®n care este utilizat. Ãntr-o **metodÄƒ**, cum ar fi metoda `getStatus`, cuvÃ¢ntul cheie `this` se referÄƒ la _obiectul la care aparÈ›ine metoda_. Metoda aparÈ›ine obiectului `data`, deci `this` se referÄƒ la obiectul `data`. CÃ¢nd Ã®nregistrÄƒm `this.status`, se Ã®nregistreazÄƒ proprietatea `status` de pe obiectul `data` care este `"ğŸ¥‘"`.

Cu metoda `call` putem schimba obiectul la care se referÄƒ cuvÃ¢ntul cheie `this`. Ãn **funcÈ›ii**, cuvÃ¢ntul cheie `this` se referÄƒ la _obiectul la care aparÈ›ine funcÈ›ia_. Am declarat funcÈ›ia `setTimeout` pe _obiectul global_, deci Ã®n interiorul funcÈ›iei `setTimeout`, cuvÃ¢ntul cheie `this` se referÄƒ la _obiectul global_. Pe obiectul global existÄƒ o variabilÄƒ numitÄƒ status cu valoarea `"ğŸ˜"`. CÃ¢nd Ã®nregistraÈ›i `this.status`, se Ã®nregistreazÄƒ `"ğŸ˜"`.

</p>
</details>

---

###### 83. Care este rezultatul?

```javascript
const person = {
  name: 'Lydia',
  age: 21,
};

let city = person.city;
city = 'Amsterdam';

console.log(person);
```

- A: `{ name: "Lydia", age: 21 }`
- B: `{ name: "Lydia", age: 21, city: "Amsterdam" }`
- C: `{ name: "Lydia", age: 21, city: undefined }`
- D: `"Amsterdam"`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: A

Am setat variabila `city` egalÄƒ cu valoarea proprietÄƒÈ›ii numitÄƒ `city` pe obiectul `person`. Nu existÄƒ o proprietate pe acest obiect numitÄƒ `city`, astfel cÄƒ variabila `city` are valoarea `undefined`.

ReÈ›ineÈ›i cÄƒ nu facem referire la obiectul `person` Ã®n sine! Pur È™i simplu am setat variabila `city` egalÄƒ cu valoarea curentÄƒ a proprietÄƒÈ›ii `city` de pe obiectul `person`.

Apoi, am setat `city` egal cu È™irul de caractere `"Amsterdam"`. Acest lucru nu schimbÄƒ obiectul `person` nu existÄƒ o referinÈ›Äƒ la acel obiect.

Atunci cÃ¢nd se afiÈ™eazÄƒ obiectul `person` se va afiÈ™a obiectul original, nealterat.

</p>
</details>

---

###### 84. Care este rezultatul?

```javascript
function checkAge(age) {
  if (age < 18) {
    const message = "Sorry, you're too young.";
  } else {
    const message = "Yay! You're old enough!";
  }

  return message;
}

console.log(checkAge(21));
```

- A: `"Sorry, you're too young."`
- B: `"Yay! You're old enough!"`
- C: `ReferenceError`
- D: `undefined`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: C

Variabilele declarate cu cuvintele cheie `const` È™i `let` au _domeniu de vizibilitate la nivel de bloc_. Un bloc poate fi definit Ã®ntre parantezele acolade (`{ }`). Ãn acest caz, parantezele acolade ale instrucÈ›iunilor if/else. Nu puteÈ›i face referire la o variabilÄƒ Ã®n afara blocului Ã®n care a fost declaratÄƒ, va fi generatÄƒ o eroare de tip ReferenceError.

</p>
</details>

---

###### 85. Ce tip de informaÈ›ii ar fi Ã®nregistrate?

```javascript
fetch('https://www.website.com/api/user/1')
  .then(res => res.json())
  .then(res => console.log(res));
```

- A: Rezultatul metodei `fetch`.
- B: Rezultatul celei de-a doua apelÄƒri a metodei `fetch`.
- C: Rezultatul funcÈ›iei de retur (callback) din `.then()`-ul anterior.
- D: Ar fi Ã®ntotdeauna `undefined`.

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: C

Valoarea lui `res` Ã®n al doilea `.then` este egalÄƒ cu valoarea returnatÄƒ de `.then` anterior. PuteÈ›i continua sÄƒ Ã®nÈ™iraÈ›i `.then`-uri Ã®n acest fel, unde valoarea este pasatÄƒ cÄƒtre urmÄƒtorul manipulator.

</p>
</details>

---

###### 86. Care opÈ›iune este o modalitate de a seta `hasName` egala cu `true`, cu condiÈ›ia sÄƒ nu puteÈ›i furniza `true` ca argument?

```javascript
function getName(name) {
  const hasName = //
}
```

- A: `!!name`
- B: `name`
- C: `new Boolean(name)`
- D: `name.length`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: A

Cu `!!name`, determinÄƒm dacÄƒ valoarea lu `name` este adevÄƒratÄƒ sau falsÄƒ. DacÄƒ `name` este adevÄƒrat, ceea ce dorim sÄƒ testÄƒm, `!name` returneazÄƒ `false`. `!false` (practic, ceea ce este `!!name`) returneazÄƒ `true`.

Prin setarea lui `hasName` egal cu `name`, se face ca `hasName` sÄƒ fie egal cu valoarea pe care aÈ›i furnizat-o funcÈ›iei `getName`, nu cu valoarea booleanÄƒ `true`.

`new Boolean(true)` returneazÄƒ un obiect Ã®ncapsulator, nu valoarea booleanÄƒ Ã®n sine.

`name.length` returneazÄƒ lungimea argumentului furnizat, nu dacÄƒ acesta este `true`.

</p>
</details>

---

###### 87. Care este rezultatul?

```javascript
console.log('I want pizza'[0]);
```

- A: `"""`
- B: `"I"`
- C: `SyntaxError`
- D: `undefined`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: B

Pentru a obÈ›ine un caracter la un anumit index dintr-un È™ir de caractere, puteÈ›i utiliza notaÈ›ia cu paranteze pÄƒtrate. Primul caracter din È™ir are indexul 0, È™i aÈ™a mai departe. Ãn acest caz, dorim sÄƒ obÈ›inem elementul cu indexul 0, adicÄƒ caracterul `"I'`, care va fi afiÈ™at Ã®n jurnal.

ReÈ›ineÈ›i cÄƒ aceastÄƒ metodÄƒ nu este suportatÄƒ Ã®n IE7 È™i versiunile anterioare. Ãn acest caz, utilizaÈ›i `.charAt()`.

</p>
</details>

---

###### 88. Care este rezultatul?

```javascript
function sum(num1, num2 = num1) {
  console.log(num1 + num2);
}

sum(10);
```

- A: `NaN`
- B: `20`
- C: `ReferenceError`
- D: `undefined`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: B

PuteÈ›i seta valoarea implicitÄƒ a unui parametru la valoarea altui parametru al funcÈ›iei, atÃ¢ta timp cÃ¢t acestea sunt definite _Ã®nainte_ de parametrul cu valoarea implicitÄƒ. Am transmis valoarea `10` funcÈ›iei `sum`. DacÄƒ funcÈ›ia `sum` primeÈ™te doar un argument, Ã®nseamnÄƒ cÄƒ valoarea pentru `num2` nu este transmisÄƒ, iar valoarea lui `num1` este egalÄƒ cu valoarea transmisÄƒ `10` Ã®n acest caz. Valoarea implicitÄƒ a lui `num2` este valoarea lui `num1`, care este `10`. `num1 + num2` returneazÄƒ `20`.

DacÄƒ Ã®ncercaÈ›i sÄƒ setaÈ›i valoarea implicitÄƒ a unui parametru egalÄƒ cu un parametru care este definit _dupÄƒ_ (Ã®n dreapta), valoarea parametrului nu a fost Ã®ncÄƒ iniÈ›ializatÄƒ, ceea ce va genera o eroare.

</p>
</details>

---

###### 89. Care este rezultatul?

```javascript
// module.js
export default () => 'Hello world';
export const name = 'Lydia';

// index.js
import * as data from './module';

console.log(data);
```

- A: `{ default: function default(), name: "Lydia" }`
- B: `{ default: function default() }`
- C: `{ default: "Hello world", name: "Lydia" }`
- D: Obiectul global al `module.js`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: A

Cu sintaxa `import * as name`, importÄƒm _toate exporturile_ din fiÈ™ierul `module.js` Ã®n fiÈ™ierul `index.js` sub forma unui nou obiect numit `data`. Ãn fiÈ™ierul `module.js` existÄƒ douÄƒ exporturi: exportul implicit È™i un export cu nume. Exportul implicit este o funcÈ›ie care returneazÄƒ È™irul de caractere `"Hello World"`, iar exportul cu nume este o variabilÄƒ numitÄƒ `name` care are valoarea È™irului de caractere `"Lydia"`.

Obiectul `data` are o proprietate `default` pentru exportul implicit, iar celelalte proprietÄƒÈ›i au numele exporturilor cu nume È™i valorile lor corespunzÄƒtoare.

</p>
</details>

---

###### 90. Care este rezultatul?

```javascript
class Person {
  constructor(name) {
    this.name = name;
  }
}

const member = new Person('John');
console.log(typeof member);
```

- A: `"class"`
- B: `"function"`
- C: `"object"`
- D: `"string"`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: C

Clasele sunt o sintaxÄƒ mai simplÄƒ pentru constructorii de funcÈ›ii. Echivalentul clasei `Person` sub forma unui constructor de funcÈ›ii ar fi:

```javascript
function Person(name) {
  this.name = name;
}
```

Apelarea unui constructor de funcÈ›ii cu `new` duce la crearea unei instanÈ›e a obiectului `Person`, iar cuvÃ¢ntul cheie `typeof` returneazÄƒ `"object"` pentru o astfel de instanÈ›Äƒ. `typeof member` returneazÄƒ `"object"`.

</p>
</details>

---

###### 91. Care este rezultatul?

```javascript
let newList = [1, 2, 3].push(4);

console.log(newList.push(5));
```

- A: `[1, 2, 3, 4, 5]`
- B: `[1, 2, 3, 5]`
- C: `[1, 2, 3, 4]`
- D: `Error`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: D

Metoda `.push` returneazÄƒ _lungimea nouÄƒ_ a array-ului, nu array-ul Ã®nsuÈ™i! Prin setarea `newList` egal cu `[1, 2, 3].push(4)`, am setat `newList` egal cu noua lungime a array-ului: `4`.

Apoi, Ã®ncercÄƒm sÄƒ folosim metoda `.push` pe `newList`. Deoarece `newList` este o valoare numericÄƒ `4`, nu putem folosi metoda `.push` se va genera o eroare de tip TypeError.

</p>
</details>

---

###### 92. Care este rezultatul?

```javascript
function giveLydiaPizza() {
  return 'Here is pizza!';
}

const giveLydiaChocolate = () =>
  "Here's chocolate... now go hit the gym already.";

console.log(giveLydiaPizza.prototype);
console.log(giveLydiaChocolate.prototype);
```

- A: `{ constructor: ...}` `{ constructor: ...}`
- B: `{}` `{ constructor: ...}`
- C: `{ constructor: ...}` `{}`
- D: `{ constructor: ...}` `undefined`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: D

FuncÈ›iile obiÈ™nuite, cum ar fi funcÈ›ia `giveLydiaPizza` au o proprietate `prototype` care este un obiect (obiectul prototip) cu o proprietate `constructor`. Cu toate acestea, funcÈ›iile arrow, cum ar fi funcÈ›ia `giveLydiaChocolate`, nu au aceastÄƒ proprietate `prototype`. `undefined` este returnat atunci cÃ¢nd Ã®ncearca sÄƒ acceseze proprietatea `prototype` folosind `giveLydiaChocolate.prototype`.

</p>
</details>

---

###### 93. Care este rezultatul?

```javascript
const person = {
  name: 'Lydia',
  age: 21,
};

for (const [x, y] of Object.entries(person)) {
  console.log(x, y);
}
```

- A: `name` `Lydia` È™i `age` `21`
- B: `["name", "Lydia"]` È™i `["age", 21]`
- C: `["name", "age"]` È™i `undefined`
- D: `Error`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: A

`Object.entries(person)` returneazÄƒ un array de array-uri imbricate, care conÈ›in cheile È™i obiectele:

`[ [ 'name', 'Lydia' ], [ 'age', 21 ] ]`

Folosind bucla `for-of` putem itera prin fiecare element din array, Ã®n acest caz, subarray-urile. Putem dezasambla subarray-urile instantaneu Ã®n bucla `for-of`, folosind `const [x, y]`. Astfel, `x` este egal cu primul element din subarray, iar `y` este egal cu al doilea element din subarray.

Primul subarray este `[ "name", "Lydia" ]`, cu `x` egal cu `"name"`, È™i `y` egal cu `"Lydia"`, care sunt afiÈ™ate Ã®n jurnal.
Al doilea subarray este `[ "age", 21 ]`, cu `x` egal cu `"age"`, È™i `y` egal cu `21`, care sunt afiÈ™ate Ã®n jurnal.

</p>
</details>

---

###### 94. Care este rezultatul?

```javascript
function getItems(fruitList, ...args, favoriteFruit) {
  return [...fruitList, ...args, favoriteFruit]
}

getItems(["banana", "apple"], "pear", "orange")
```

- A: `["banana", "apple", "pear", "orange"]`
- B: `[["banana", "apple"], "pear", "orange"]`
- C: `["banana", "apple", ["pear"], "orange"]`
- D: `SyntaxError`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: D

`...args`  este un parametru rest. Valoarea parametrului rest este un array care conÈ›ine toate argumentele rÄƒmase È™i **poate fi doar ultimul parametru**! Ãn acest exemplu, parametrul rest era al doilea parametru. Acest lucru nu este posibil È™i va genera o eroare de sintaxÄƒ.

```javascript
function getItems(fruitList, favoriteFruit, ...args) {
  return [...fruitList, ...args, favoriteFruit];
}

getItems(['banana', 'apple'], 'pear', 'orange');
```

Exemplul de mai sus funcÈ›ioneazÄƒ. Acesta returneazÄƒ array-ul `[ 'banana', 'apple', 'orange', 'pear' ]`

</p>
</details>

---

###### 95. Care este rezultatul?

```javascript
function nums(a, b) {
  if (a > b) console.log('a is bigger');
  else console.log('b is bigger');
  return
  a + b;
}

console.log(nums(4, 2));
console.log(nums(1, 2));
```

- A: `a is bigger`, `6` È™i `b is bigger`, `3`
- B: `a is bigger`, `undefined` È™i `b is bigger`, `undefined`
- C: `undefined` È™i `undefined`
- D: `SyntaxError`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: B

Ãn JavaScript, nu _trebuie_ sÄƒ scriem explicit semnul punct È™i virgulÄƒ (`;`) totuÈ™i motorul JavaScript le adaugÄƒ automat dupÄƒ instrucÈ›iuni. Acest lucru se numeÈ™te **InserÈ›ia AutomatÄƒ a Semnelor de Punct È™i VirgulÄƒ**. O instrucÈ›iune poate fi, de exemplu, variabile sau cuvinte cheie precum `throw`, `return`, `break`, etc.

Aici, am scris o instrucÈ›iune `return` È™i o altÄƒ valoare `a + b` pe o _linie nouÄƒ_. Cu toate acestea, deoarece este o linie nouÄƒ, motorul JavaScript nu È™tie cÄƒ este de fapt valoarea pe care am dorit sÄƒ o returnÄƒm. Ãn schimb, a adÄƒugat automat un punct È™i virgulÄƒ dupÄƒ `return`. PuteÈ›i vedea acest lucru ca:

```javascript
return;
a + b;
```

Acest lucru Ã®nseamnÄƒ cÄƒ `a + b` nu este niciodatÄƒ atins, deoarece o funcÈ›ie se opreÈ™te din executare dupÄƒ cuvÃ¢ntul cheie `return`. DacÄƒ nu se returneazÄƒ nicio valoare, aÈ™a cum se Ã®ntÃ¢mplÄƒ aici, funcÈ›ia returneazÄƒ `undefined`. ReÈ›ineÈ›i cÄƒ nu existÄƒ inserÈ›ie automatÄƒ a semnelor de punct È™i virgulÄƒ dupÄƒ instrucÈ›iunile `if/else`!

</p>
</details>

---

###### 96. Care este rezultatul?

```javascript
class Person {
  constructor() {
    this.name = 'Lydia';
  }
}

Person = class AnotherPerson {
  constructor() {
    this.name = 'Sarah';
  }
};

const member = new Person();
console.log(member.name);
```

- A: `"Lydia"`
- B: `"Sarah"`
- C: `Error: cannot redeclare Person`
- D: `SyntaxError`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: B

Putem seta clasele egale cu alte clase sau constructori de funcÈ›ii. Ãn acest caz, am setat `Person` egal cu `AnotherPerson`. Numele Ã®n acest constructor este `Sarah`, astfel Ã®ncÃ¢t proprietatea `Person` de pe noua instanÈ›Äƒ `member` este `"Sarah"`.

</p>
</details>

---

###### 97. Care este rezultatul?

```javascript
const info = {
  [Symbol('a')]: 'b',
};

console.log(info);
console.log(Object.keys(info));
```

- A: `{Symbol('a'): 'b'}` È™i `["{Symbol('a')"]`
- B: `{}` È™i `[]`
- C: `{ a: "b" }` È™i `["a"]`
- D: `{Symbol('a'): 'b'}` È™i `[]`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: D

Un simbol nu este _enumerabil_. Metoda `Object.keys` returneazÄƒ toate proprietÄƒÈ›ile cheie _enumerabil_ ale unui obiect. Simbolul nu va fi vizibil, È™i va fi returnat un array gol. Atunci cÃ¢nd se afiÈ™eazÄƒ Ã®ntregul obiect, vor fi vizibile toate proprietÄƒÈ›ile, inclusiv cele care nu sunt enumerate.

Asta este una dintre multele calitÄƒÈ›i ale unui simbol: pe lÃ¢ngÄƒ faptul cÄƒ reprezintÄƒ o valoare complet unicÄƒ (ceea ce previne coliziunile accidentale de nume pe obiecte, de exemplu, atunci cÃ¢nd lucraÈ›i cu douÄƒ biblioteci care doresc sÄƒ adauge proprietÄƒÈ›i la acelaÈ™i obiect), puteÈ›i "ascunde" proprietÄƒÈ›i pe obiecte Ã®n acest fel (deÈ™i nu Ã®n Ã®ntregime. ÃncÄƒ puteÈ›i accesa simbolurile folosind metoda `Object.getOwnPropertySymbols()`).

</p>
</details>

---

###### 98. Care este rezultatul?

```javascript
const getList = ([x, ...y]) => [x, y]
const getUser = user => { name: user.name, age: user.age }

const list = [1, 2, 3, 4]
const user = { name: "Lydia", age: 21 }

console.log(getList(list))
console.log(getUser(user))
```

- A: `[1, [2, 3, 4]]` È™i `SyntaxError`
- B: `[1, [2, 3, 4]]` È™i `{ name: "Lydia", age: 21 }`
- C: `[1, 2, 3, 4]` È™i `{ name: "Lydia", age: 21 }`
- D: `Error` È™i `{ name: "Lydia", age: 21 }`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: A

FuncÈ›ia `getList` primeÈ™te un array ca argument. Ãntre parantezele funcÈ›iei `getList` dezasamblÄƒm acest array imediat. PuteÈ›i vedea acest lucru ca:

`[x, ...y] = [1, 2, 3, 4]`

Cu ajutorul parametrului rest `...y`, punem toÈ›i "parametrii rÄƒmaÈ™i" Ã®ntr-un array. Parametrii rÄƒmaÈ™i Ã®n acest caz sunt `2`, `3` È™i `4`. Valoarea lui `y` este un array care conÈ›ine toÈ›i parametrii rÄƒmaÈ™i. Valoarea lui `x` este egal cu `1` Ã®n acest caz, deci cÃ¢nd afiÈ™Äƒm `[x, y]`, va fi afiÈ™at `[1, [2, 3, 4]]`.

FuncÈ›ia `getUser` primeÈ™te un obiect ca argument. Cu funcÈ›iile arrow, nu _trebuie_ sÄƒ scriem acolade dacÄƒ dorim sÄƒ returnÄƒm doar o valoare. Cu toate acestea, dacÄƒ doriÈ›i sÄƒ returnaÈ›i instantaneu un _obiect_ dintr-o funcÈ›ie arrow, trebuie sÄƒ-l scrieÈ›i Ã®ntre paranteze. Altfel, tot ce este Ã®ntre acolade va fi interpretat ca o instrucÈ›iune bloc. Ãn acest caz, codul dintre acolade nu este un cod JavaScript valid, aÈ™a cÄƒ se va genera o eroare de sintaxÄƒ `SyntaxError`. 

FuncÈ›ia urmÄƒtoare ar fi returnat un obiect:

`const getUser = user => ({ name: user.name, age: user.age })`

</p>
</details>

---

###### 99. Care este rezultatul?

```javascript
const name = 'Lydia';

console.log(name());
```

- A: `SyntaxError`
- B: `ReferenceError`
- C: `TypeError`
- D: `undefined`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: C

Variabila `name` conÈ›ine o valoare de tip È™ir de caractere (string), care nu este o funcÈ›ie È™i, prin urmare, nu poate fi invocatÄƒ.

TypeError-urile sunt generate atunci cÃ¢nd o valoare nu este de tipul aÈ™teptat. JavaScript e aÈ™tepta ca `name` sÄƒ fie o funcÈ›ie, deoarece Ã®ncercÄƒm sÄƒ o apelÄƒm. Cu toate acestea, era de tip È™ir de caractere (string), aÈ™a cÄƒ a generat o eroare de tip TypeError: name nu este o funcÈ›ie!

SyntaxError-urile sunt generate atunci cÃ¢nd aÈ›i scris ceva care nu este JavaScript valid, de exemplu, atunci cÃ¢nd aÈ›i scris cuvÃ¢ntul `return` ca `retrun`.
ReferenceError-urile sunt generate atunci cÃ¢nd JavaScript nu poate gÄƒsi o referinÈ›Äƒ la o valoare la care Ã®ncercaÈ›i sÄƒ accesaÈ›i.

</p>
</details>

---

###### 100. Care este valoarea lui output?

```javascript
// ğŸ‰âœ¨ Aceasta este a 100-a mea Ã®ntrebare! âœ¨ğŸ‰

const output = `${[] && 'Im'}possible!
You should${'' && `n't`} see a therapist after so much JavaScript lol`;
```

- A: `possible! You should see a therapist after so much JavaScript lol`
- B: `Impossible! You should see a therapist after so much JavaScript lol`
- C: `possible! You shouldn't see a therapist after so much JavaScript lol`
- D: `Impossible! You shouldn't see a therapist after so much JavaScript lol`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: B

`[]` este o valoare adevÄƒratÄƒ (truthy). Cu operatorul `&&` valoarea din partea dreaptÄƒ va fi returnatÄƒ dacÄƒ valoarea din partea stÃ¢ngÄƒ este adevÄƒratÄƒ. Ãn acest caz, valoarea din partea stÃ¢ngÄƒ, `[]` este adevÄƒratÄƒ, astfel cÄƒ se va returna `"Im'`.

`""` este o valoare falsÄƒ (falsy). DacÄƒ valoarea din partea stÃ¢ngÄƒ este falsÄƒ, nu se returneazÄƒ nimic. `n't` nu va fi returnat.

</p>
</details>

---

###### 101. Care este valoarea ieÈ™irii?

```javascript
const one = false || {} || null;
const two = null || false || '';
const three = [] || 0 || true;

console.log(one, two, three);
```

- A: `false` `null` `[]`
- B: `null` `""` `true`
- C: `{}` `""` `[]`
- D: `null` `null` `true`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: C

Cu operatorul  `||` utem returna primul operand adevÄƒrat (truthy). DacÄƒ toate valorile sunt false, se va returna ultimul operand.

`(false || {} || null)`: obiectul go `{}` este o valoare adevÄƒratÄƒ (truthy). Aceasta este prima (È™i singura) valoare adevÄƒratÄƒ, care este returnatÄƒ. `one` este egal cu `{}`.

`(null || false || "")`: toate operanzii sunt valori false. Acest lucru Ã®nseamnÄƒ cÄƒ ultimul operand `""` este returnat. `two` este egal cu `""`.

`([] || 0 || "")`: array-ul gol `[]` este o valoare adevÄƒratÄƒ (truthy). Aceasta este prima valoare adevÄƒratÄƒ, care este returnatÄƒ. `three` este egal cu `[]`.

</p>
</details>

---

###### 102. Care este valoarea ieÈ™irii?

```javascript
const myPromise = () => Promise.resolve('I have resolved!');

function firstFunction() {
  myPromise().then(res => console.log(res));
  console.log('second');
}

async function secondFunction() {
  console.log(await myPromise());
  console.log('second');
}

firstFunction();
secondFunction();
```

- A: `I have resolved!`, `second` È™i `I have resolved!`, `second`
- B: `second`, `I have resolved!` È™i `second`, `I have resolved!`
- C: `I have resolved!`, `second` È™i `second`, `I have resolved!`
- D: `second`, `I have resolved!` È™i `I have resolved!`, `second`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: D

Cu o promisiune, spunem Ã®n principiu _Vreau sÄƒ execut aceastÄƒ funcÈ›ie, dar o pun deoparte pentru moment Ã®n timp ce ruleazÄƒ, deoarece acest lucru poate dura ceva timp. Doar atunci cÃ¢nd o anumitÄƒ valoare este rezolvatÄƒ (sau respinsÄƒ), È™i atunci cÃ¢nd stiva de apeluri este goalÄƒ, doresc sÄƒ folosesc aceastÄƒ valoare._

Putem obÈ›ine aceastÄƒ valoare atÃ¢t cu `.then` cÃ¢t È™i cu cuvÃ¢ntul cheie `await` Ã®ntr-o funcÈ›ie `async`. Cu toate cÄƒ putem obÈ›ine valoarea unei promisiuni cu ambele metode `.then` È™i `await`, ele funcÈ›ioneazÄƒ puÈ›in diferit.

Ãn `firstFunction`, am pus (Ã®ntr-un fel) funcÈ›ia `myPromise` deoparte Ã®n timp ce aceasta se executa, dar am continuat sÄƒ executÄƒm restul codului, care este `console.log('second')` Ã®n acest caz. Apoi, funcÈ›ia a fost rezolvatÄƒ cu È™irul `I have resolved`, care a fost apoi Ã®nregistrat Ã®n jurnal dupÄƒ ce s-a constatat cÄƒ stiva de apeluri era goalÄƒ.

Cu cuvÃ¢ntul cheie `await` Ã®n `secondFunction`, efectiv pauzÄƒm execuÈ›ia unei funcÈ›ii asincrone pÃ¢nÄƒ cÃ¢nd valoarea a fost rezolvatÄƒ Ã®nainte de a trece la urmÄƒtoarea linie.

Acest lucru Ã®nseamnÄƒ cÄƒ a aÈ™teptat ca `myPromise` sÄƒ fie rezolvat cu valoarea `I have resolved`, È™i doar dupÄƒ ce s-a Ã®ntÃ¢mplat acest lucru, s-a trecut la urmÄƒtoarea linie: a fost Ã®nregistrat `second`.

</p>
</details>

---

###### 103. Care este valoarea ieÈ™irii?

```javascript
const set = new Set();

set.add(1);
set.add('Lydia');
set.add({ name: 'Lydia' });

for (let item of set) {
  console.log(item + 2);
}
```

- A: `3`, `NaN`, `NaN`
- B: `3`, `7`, `NaN`
- C: `3`, `Lydia2`, `[object Object]2`
- D: `"12"`, `Lydia2`, `[object Object]2`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: C

Operatorul `+` nu este folosit doar pentru adunarea valorilor numerice, ci Ã®l putem utiliza È™i pentru concatenarea È™irurilor de caractere. Ori de cÃ¢te ori motorul JavaScript observÄƒ cÄƒ una sau mai multe valori nu sunt de tip numÄƒr, va converti numÄƒrul Ã®ntr-un È™ir de caractere.

Primul operand este `1`, care este o valoare numericÄƒ. `1 + 2` returneazÄƒ numÄƒrul 3.

Cu toate acestea, al doilea operand este un È™ir de caractere `"Lydia"`. `"Lydia"` este un È™ir de caractere È™i `2` este un numÄƒr: `2` este convertit Ã®ntr-un È™ir de caractere. `"Lydia"` È™i `"2"` sunt concatenate, rezultÃ¢nd È™irul de caractere `"Lydia2"`.

`{ name: "Lydia" }` este un obiect. Niciun numÄƒr, niciun obiect nu este un È™ir de caractere, astfel cÄƒ sunt convertite Ã®n È™iruri. Ori de cÃ¢te ori convertim un obiect regulat Ã®n È™ir de caractere, devine `"[object Object]"`. `"[object Object]"` concatenat cu `"2"` devine `"[object Object]2"`.

</p>
</details>

---

###### 104. Care este rezultatul?

```javascript
Promise.resolve(5);
```

- A: `5`
- B: `Promise {<pending>: 5}`
- C: `PromiseÂ {<fulfilled>: 5}`
- D: `Error`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: C

Putem pasa orice tip de valoare dorim cÄƒtre `Promise.resolve`, fie o promisiune, fie o valoare non-promisiune. Metoda Ã®n sine returneazÄƒ o promisiune cu valoarea rezolvatÄƒ (`<fulfilled>`). DacÄƒ pasaÈ›i o funcÈ›ie regulatÄƒ, va fi o promisiune rezolvatÄƒ cu o valoare regulatÄƒ. DacÄƒ pasaÈ›i o promisiune, va fi o promisiune rezolvatÄƒ cu valoarea rezolvatÄƒ a promisiunii respective pasate.

Ãn acest caz, am pasat doar valoarea numericÄƒ `5`. Aceasta returneazÄƒ o promisiune rezolvatÄƒ cu valoarea `5`.

</p>
</details>

---

###### 105. Care este rezultatul?

```javascript
function compareMembers(person1, person2 = person) {
  if (person1 !== person2) {
    console.log('Not the same!');
  } else {
    console.log('They are the same!');
  }
}

const person = { name: 'Lydia' };

compareMembers(person);
```

- A: `Not the same!`
- B: `They are the same!`
- C: `ReferenceError`
- D: `SyntaxError`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: B

Obiectele sunt pasate prin referinÈ›Äƒ. Atunci cÃ¢nd verificÄƒm obiecte pentru egalitate strictÄƒ (`===`), comparÄƒm referinÈ›ele lor.

Am setat valoarea implicitÄƒ pentru `person2` egalÄƒ cu obiectul `person` È™i am pasat obiectul `person` ca valoare pentru `person1`.

Acest lucru Ã®nseamnÄƒ cÄƒ ambele valori au o referinÈ›Äƒ cÄƒtre aceeaÈ™i locaÈ›ie Ã®n memorie, astfel cÄƒ sunt egale.

Blocul de cod din instrucÈ›iunea `else` se executÄƒ, È™i este Ã®nregistrat mesajul`They are the same!`.

</p>
</details>

---

###### 106. Care este rezultatul?

```javascript
const colorConfig = {
  red: true,
  blue: false,
  green: true,
  black: true,
  yellow: false,
};

const colors = ['pink', 'red', 'blue'];

console.log(colorConfig.colors[1]);
```

- A: `true`
- B: `false`
- C: `undefined`
- D: `TypeError`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: D

Ãn JavaScript, avem douÄƒ moduri de a accesa proprietÄƒÈ›i pe un obiect: notare cu paranteze pÄƒtrate sau notare cu punct. Ãn acest exemplu, folosim notarea cu punct (`colorConfig.colors`) Ã®n loc de notarea cu paranteze pÄƒtrate  (`colorConfig["colors"]`).

Cu notarea cu punct, JavaScript Ã®ncearcÄƒ sÄƒ gÄƒseascÄƒ proprietatea pe obiect cu exact acelaÈ™i nume. Ãn acest exemplu, JavaScript Ã®ncearcÄƒ sÄƒ gÄƒseascÄƒ o proprietate numitÄƒ `colors` pe obiectul `colorConfig`. Nu existÄƒ o proprietate numitÄƒ `colors`, aÈ™a cÄƒ acest lucru returneazÄƒ `undefined`. Apoi, Ã®ncercÄƒm sÄƒ accesÄƒm valoarea primului element folosind `[1]`. Nu putem face acest lucru pe o valoare care este `undefined`, astfel cÄƒ se genereazÄƒ o eroare de tip `TypeError`: `Cannot read property '1' of undefined`.

JavaScript interpreteazÄƒ (sau deschide) declaraÈ›iile. Atunci cÃ¢nd folosim notaÈ›ia cu paranteze pÄƒtrate, vede prima parantezÄƒ deschisÄƒ `[` È™i continuÄƒ pÃ¢nÄƒ gÄƒseÈ™te paranteza de Ã®nchidere `]`. Abia atunci va evalua declaraÈ›ia. DacÄƒ am fi folosit `colorConfig[colors[1]]`, ar fi returnat valoarea proprietÄƒÈ›ii `red` pe obiectul `colorConfig`.

</p>
</details>

---

###### 107. Care este rezultatul?

```javascript
console.log('â¤ï¸' === 'â¤ï¸');
```

- A: `true`
- B: `false`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: A

Ãn culise, emoji-urile sunt reprezentate ca coduri Unicode. Codurile Unicode pentru emoji-ul inimii sunt `"U+2764 U+FE0F"`. Acestea sunt Ã®ntotdeauna aceleaÈ™i pentru aceleaÈ™i emoji-uri, aÈ™a cÄƒ comparÄƒm douÄƒ È™iruri identice Ã®ntre ele, ceea ce returneazÄƒ

</p>
</details>

---

###### 108. Care dintre aceste metode modificÄƒ array-ul original?

```javascript
const emojis = ['âœ¨', 'ğŸ¥‘', 'ğŸ˜'];

emojis.map(x => x + 'âœ¨');
emojis.filter(x => x !== 'ğŸ¥‘');
emojis.find(x => x !== 'ğŸ¥‘');
emojis.reduce((acc, cur) => acc + 'âœ¨');
emojis.slice(1, 2, 'âœ¨');
emojis.splice(1, 2, 'âœ¨');
```

- A: `Toate`
- B: `map` `reduce` `slice` `splice`
- C: `map` `slice` `splice`
- D: `splice`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: D

Cu metoda `splice` mmodificÄƒm array-ul original prin È™tergerea, Ã®nlocuirea sau adÄƒugarea de elemente. Ãn acest caz, am eliminat 2 elemente de la indexul 1 (am eliminat `'ğŸ¥‘'` È™i `'ğŸ˜'`) È™i am adÄƒugat emoji-ul âœ¨ Ã®n locul lor.

`map`, `filter` È™i `slice` returneazÄƒ un nou array, `find` returneazÄƒ un element, ia `reduce` returneazÄƒ o valoare redusÄƒ.

</p>
</details>

---

###### 109. Care este rezultatul?

```javascript
const food = ['ğŸ•', 'ğŸ«', 'ğŸ¥‘', 'ğŸ”'];
const info = { favoriteFood: food[0] };

info.favoriteFood = 'ğŸ';

console.log(food);
```

- A: `['ğŸ•', 'ğŸ«', 'ğŸ¥‘', 'ğŸ”']`
- B: `['ğŸ', 'ğŸ«', 'ğŸ¥‘', 'ğŸ”']`
- C: `['ğŸ', 'ğŸ•', 'ğŸ«', 'ğŸ¥‘', 'ğŸ”']`
- D: `ReferenceError`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: A

Am setat valoarea proprietÄƒÈ›ii `favoriteFood` pe obiectul `info` egal cu È™irul de caractere cu emoji-ul de pizza, `'ğŸ•'`. Un È™ir de caractere este un tip de date primitiv. Ãn JavaScript, tipurile de date primitive nu interacÈ›ioneazÄƒ prin referinÈ›Äƒ.

Ãn JavaScript, tipurile de date primitive (tot ceea ce nu este obiect) interacÈ›ioneazÄƒ prin _valoare_. Ãn acest caz, am setat valoarea proprietÄƒÈ›ii `favoriteFood` pe obiectul `info` egalÄƒ cu valoarea primului element din array-ul `food` care este un È™ir de caractere cu emoji-ul de pizza Ã®n acest caz (`'ğŸ•'`). Un È™ir de caractere este un tip de date primitiv È™i interacÈ›ioneazÄƒ prin valoare (vedeÈ›i [blogpost](https://www.theavocoder.com/complete-javascript/2018/12/21/by-value-vs-by-reference) meu dacÄƒ doriÈ›i sÄƒ aflaÈ›i mai multe).

Apoi, schimbÄƒm valoarea proprietÄƒÈ›ii `favoriteFood` pe obiectul `info`. Array-ul `food` nu s-a schimbat, deoarece valoarea `favoriteFood` era doar o _copie_ a valorii primului element din array È™i nu are o referinÈ›Äƒ la aceeaÈ™i locaÈ›ie Ã®n memorie ca elementul din `food[0]`. CÃ¢nd Ã®nregistrÄƒm array-ul `food`, acesta rÄƒmÃ¢ne neschimbat, `['ğŸ•', 'ğŸ«', 'ğŸ¥‘', 'ğŸ”']`.

</p>
</details>

---

###### 110. Ce face aceastÄƒ metodÄƒ?

```javascript
JSON.parse();
```

- A: Parcurge JSON-ul pentru a obÈ›ine o valoare JavaScript
- B: Parcurge un obiect JavaScript pentru a obÈ›ine un JSON
- C: Parcurge orice valoare JavaScript Ã®ntr-un JSON
- D: Parcurge doar JSON-ul Ã®ntr-un obiect JavaScript

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: A

Cu metoda `JSON.parse()` putem parsa un È™ir JSON Ã®ntr-o valoare JavaScript.

```javascript
// Transformarea unui numÄƒr Ã®ntr-un JSON valid, apoi parsarea È™irului JSON Ã®ntr-o valoare JavaScript:
const jsonNumber = JSON.stringify(4); // '4'
JSON.parse(jsonNumber); // 4

// Transformarea unei valori de tip array Ã®ntr-un JSON valid, apoi parsarea È™irului JSON Ã®ntr-o valoare JavaScript:
const jsonArray = JSON.stringify([1, 2, 3]); // '[1, 2, 3]'
JSON.parse(jsonArray); // [1, 2, 3]

// Transformarea unui obiect Ã®ntr-un JSON valid, apoi parsarea È™irului JSON Ã®ntr-o valoare JavaScript:
const jsonArray = JSON.stringify({ name: 'Lydia' }); // '{"name":"Lydia"}'
JSON.parse(jsonArray); // { name: 'Lydia' }
```

</p>
</details>

---

###### 111. Care este rezultatul?

```javascript
let name = 'Lydia';

function getName() {
  console.log(name);
  let name = 'Sarah';
}

getName();
```

- A: Lydia
- B: Sarah
- C: `undefined`
- D: `ReferenceError`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: D

Fiecare funcÈ›ie are propriul sÄƒu _context de execuÈ›ie_ (sau _domeniu_). FuncÈ›ia `getName` cautÄƒ mai Ã®ntÃ¢i Ã®n propriul sÄƒu context (domeniu) pentru a vedea dacÄƒ conÈ›ine variabila `name` pe care Ã®ncercÄƒm sÄƒ o accesÄƒm. Ãn acest caz, funcÈ›ia `getName` conÈ›ine propria sa variabilÄƒ `name` declarÄƒm variabila `name` cu cuvÃ¢ntul cheie `let`, È™i cu valoarea `'Sarah'`.

Variabilele declarate cu cuvÃ¢ntul cheie `let` (È™i `const`) sunt hoisted, dar, spre deosebire de `var`, nu sunt <i>iniÈ›ializate</i>. Ele nu sunt accesibile Ã®nainte de linia Ã®n care le declarÄƒm (iniÈ›ializÄƒm). Acest lucru se numeÈ™te "zona temporalÄƒ moartÄƒ" (temporal dead zone). Atunci cÃ¢nd Ã®ncercÄƒm sÄƒ accesÄƒm variabilele Ã®nainte de a fi declarate, JavaScript aruncÄƒ o eroare de tip `ReferenceError`.

DacÄƒ nu am fi declarat variabila `name` Ã®n interiorul funcÈ›iei `getName` motorul JavaScript ar fi cÄƒutat Ã®n josul lanÈ›ului de _domenii_. Domeniul exterior are o variabilÄƒ numitÄƒ `name` cu valoarea `Lydia`. Ãn acest caz, ar fi afiÈ™at `Lydia`.

```javascript
let name = 'Lydia';

function getName() {
  console.log(name);
}

getName(); // Lydia
```

</p>
</details>

---

###### 112. Care este rezultatul?

```javascript
function* generatorOne() {
  yield ['a', 'b', 'c'];
}

function* generatorTwo() {
  yield* ['a', 'b', 'c'];
}

const one = generatorOne();
const two = generatorTwo();

console.log(one.next().value);
console.log(two.next().value);
```

- A: `a` È™i `a`
- B: `a` È™i `undefined`
- C: `['a', 'b', 'c']` È™i `a`
- D: `a` È™i `['a', 'b', 'c']`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: C

Cu cuvÃ¢ntul cheie `yield`, cedÄƒm valorile Ã®ntr-o funcÈ›ie generator. Cu cuvÃ¢ntul cheie `yield*`, putem ceda valori dintr-o altÄƒ funcÈ›ie generator sau dintr-un obiect iterabil (de exemplu, un array).

Ãn `generatorOne`, folosim cuvÃ¢ntul cheie `yield` pentru a ceda intrega mulÈ›ime `['a', 'b', 'c']`. Valoarea proprietÄƒÈ›ii `value` a obiectului returnat de metoda `next` pe obiectul `one` (`one.next().value`) este egalÄƒ cu Ã®ntregul array `['a', 'b', 'c']`.

```javascript
console.log(one.next().value); // ['a', 'b', 'c']
console.log(one.next().value); // undefined
```

Ãn `generatorTwo`, folosim cuvÃ¢ntul cheie `yield*`. Acest lucru Ã®nseamnÄƒ cÄƒ prima valoare cedatÄƒ din `two`, este egalÄƒ cu prima valoare cedatÄƒ din iterator. Iteratorul este mulÈ›imea `['a', 'b', 'c']`. Prima valoare cedatÄƒ este `a`, aÈ™a cÄƒ prima datÄƒ cÃ¢nd apelÄƒm `two.next().value`, este returnatÄƒ valoarea  `a`.

```javascript
console.log(two.next().value); // 'a'
console.log(two.next().value); // 'b'
console.log(two.next().value); // 'c'
console.log(two.next().value); // undefined
```

</p>
</details>

---

###### 113. Care este rezultatul?

```javascript
console.log(`${(x => x)('I love')} to program`);
```

- A: `I love to program`
- B: `undefined to program`
- C: `${(x => x)('I love') to program`
- D: `TypeError`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: A

Expresiile din È™irurile È™ablon (template literals) sunt evaluate mai Ã®ntÃ¢i. Acest lucru Ã®nseamnÄƒ cÄƒ È™irul va conÈ›ine valoarea returnatÄƒ de expresie, funcÈ›ia imediat invocatÄƒ `(x => x)('I love')` Ã®n acest caz. Trecem valoarea `'I love'` ca argument cÄƒtre funcÈ›ia arrow `x => x`. `x` este egal cu `'I love'`, care este returnatÄƒ. Aceasta duce la rezultatul `I love to program`.

</p>
</details>

---

###### 114. Ce se va Ã®ntÃ¢mpla?

```javascript
let config = {
  alert: setInterval(() => {
    console.log('Alert!');
  }, 1000),
};

config = null;
```

- A: FuncÈ›ia de callback a `setInterval` nu va fi invocatÄƒ
- B: FuncÈ›ia de callback a `setInterval` este invocatÄƒ o singurÄƒ datÄƒ
- C: FuncÈ›ia de callback a `setInterval` va fi totuÈ™i apelatÄƒ Ã®n fiecare secundÄƒ
- D: Nu am apelat niciodatÄƒ `config.alert()`, config este `null`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: C

Ãn mod normal, atunci cÃ¢nd setÄƒm obiecte egal cu `null`, acele obiecte sunt _colectate de gunoi_ (garbage collected), deoarece nu mai existÄƒ nicio referinÈ›Äƒ cÄƒtre acel obiect. Cu toate acestea, deoarece funcÈ›ia de callback din `setInterval` este o funcÈ›ie arrow (È™i, prin urmare, legatÄƒ de obiectul `config`), funcÈ›ia de callback Ã®ncÄƒ menÈ›ine o referinÈ›Äƒ la obiectul  `config`. 
AtÃ¢ta timp cÃ¢t existÄƒ o referinÈ›Äƒ, obiectul nu va fi colectat de gunoi (garbage collected). 
Deoarece aceasta este o intervalÄƒ de timp, setarea lui `config` la `null` sau `delete` lui `config.alert` nu va colecta intervalul de gunoi È™i intervalul va continua sÄƒ fie apelat.
Pentru a-l opri È™i a-l elimina din memorie, trebuie sÄƒ folosiÈ›i `clearInterval(config.alert)`.
Deoarece acest lucru nu a fost fÄƒcut, funcÈ›ia de callback a `setInterval` va fi Ã®n continuare invocatÄƒ la fiecare 1000 ms (1 secundÄƒ).

</p>
</details>

---

###### 115. Ce metodÄƒ(e) va returna valoarea `'Hello world!'`?

```javascript
const myMap = new Map();
const myFunc = () => 'greeting';

myMap.set(myFunc, 'Hello world!');

//1
myMap.get('greeting');
//2
myMap.get(myFunc);
//3
myMap.get(() => 'greeting');
```

- A: 1
- B: 2
- C: 2 È™i 3
- D: Toate

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: B

CÃ¢nd adÄƒugÄƒm o pereche cheie/valoare folosind metoda `set`, cheia va fi valoarea primului argument transmis funcÈ›iei `set`, iar valoarea va fi cea de-a doua valoare transmisÄƒ funcÈ›ie `set`. Cheia Ã®n acest caz este _funcÈ›ia_ `() => 'greeting'`, iar valoarea `'Hello world'`. `myMap` este acum `{ () => 'greeting' => 'Hello world!' }`.

1 este incorect pentru cÄƒ cheia nu este `'greeting'` ci `() => 'greeting'`.
3 este incorect pentru cÄƒ creÄƒm o nouÄƒ funcÈ›ie prin transmiterea ei ca parametru cÄƒtre metoda `get`. Obiectele interacÈ›ioneazÄƒ prin _referinÈ›Äƒ_. FuncÈ›iile sunt obiecte, motiv pentru care douÄƒ funcÈ›ii nu sunt niciodatÄƒ strict egale, chiar dacÄƒ sunt identice: ele au o referinÈ›Äƒ cÄƒtre un loc diferit Ã®n memorie.

</p>
</details>

---

###### 116. Care este rezultatul?

```javascript
const person = {
  name: 'Lydia',
  age: 21,
};

const changeAge = (x = { ...person }) => (x.age += 1);
const changeAgeAndName = (x = { ...person }) => {
  x.age += 1;
  x.name = 'Sarah';
};

changeAge(person);
changeAgeAndName();

console.log(person);
```

- A: `{name: "Sarah", age: 22}`
- B: `{name: "Sarah", age: 23}`
- C: `{name: "Lydia", age: 22}`
- D: `{name: "Lydia", age: 23}`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: C

Ambele funcÈ›ii `changeAge` È™i `changeAgeAndName` au un parametru implicit, È™i anume un obiect _nou_ creat `{ ...person }`. Acest obiect conÈ›ine copii ale tuturor cheilor/valorilor din obiectul `person`.

Ãn primul rÃ¢nd, apelÄƒm funcÈ›ia `changeAge` È™i transmitem obiectul `person` ca argument. AceastÄƒ funcÈ›ie creÈ™te valoarea proprietÄƒÈ›ii `age` cu 1. `person` devine `{ name: "Lydia", age: 22 }`.

Apoi, apelÄƒm funcÈ›ia `changeAgeAndName`, Ã®nsÄƒ nu transmitem un parametru. Ãn schimb, valoarea lui `x` este egalÄƒ cu un obiect _nou_: `{ ...person }`. Deoarece este un obiect nou, acesta nu afecteazÄƒ valorile proprietÄƒÈ›ilor din obiectul `person`. `person` rÄƒmÃ¢ne egal cu `{ name: "Lydia", age: 22 }`.

</p>
</details>

---

###### 117. Care dintre opÈ›iunile urmÄƒtoare va returna `6`?

```javascript
function sumValues(x, y, z) {
  return x + y + z;
}
```

- A: `sumValues([...1, 2, 3])`
- B: `sumValues([...[1, 2, 3]])`
- C: `sumValues(...[1, 2, 3])`
- D: `sumValues([1, 2, 3])`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: C

Cu operatorul spread `...`, putem _rÄƒspÃ¢ndi_ obiecte iterabile Ã®n elemente individuale. FuncÈ›ia `sumValues` primeÈ™te trei argumente: `x`, `y` È™i `z`. `...[1, 2, 3]` va rezulta Ã®n `1, 2, 3`, pe care le transmitem funcÈ›iei `sumValues`.

</p>
</details>

---

###### 118. Care este rezultatul?

```javascript
let num = 1;
const list = ['ğŸ¥³', 'ğŸ¤ ', 'ğŸ¥°', 'ğŸ¤ª'];

console.log(list[(num += 1)]);
```

- A: `ğŸ¤ `
- B: `ğŸ¥°`
- C: `SyntaxError`
- D: `ReferenceError`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: B

Cu operandul `+=` incrementÄƒm valoarea lui `num` cu `1`. IniÈ›ial, `num` avea valoarea `1`, deci `1 + 1` este `2`. Elementul de pe al doilea index Ã®n mulÈ›imea `list` este ğŸ¥°, `console.log(list[2])` va afiÈ™a ğŸ¥°.

</p>
</details>

---

###### 119. Care este rezultatul?

```javascript
const person = {
  firstName: 'Lydia',
  lastName: 'Hallie',
  pet: {
    name: 'Mara',
    breed: 'Dutch Tulip Hound',
  },
  getFullName() {
    return `${this.firstName} ${this.lastName}`;
  },
};

console.log(person.pet?.name);
console.log(person.pet?.family?.name);
console.log(person.getFullName?.());
console.log(member.getLastName?.());
```

- A: `undefined` `undefined` `undefined` `undefined`
- B: `Mara` `undefined` `Lydia Hallie` `ReferenceError`
- C: `Mara` `null` `Lydia Hallie` `null`
- D: `null` `ReferenceError` `null` `ReferenceError`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: B

Cu operatorul de verificare opÈ›ionalÄƒ `?.`, nu mai este necesar sÄƒ verificÄƒm explicit dacÄƒ valorile mai profunde Ã®ncorporate sunt valide sau nu. DacÄƒ Ã®ncercÄƒm sÄƒ accesÄƒm o proprietate pe o valoare `undefined` sau `null` valoarea (_nullish_), expresia face un scurtcircuit È™i returneazÄƒ `undefined`.

`person.pet?.name`: `person` are o proprietate numitÄƒ `pet`: `person.pet` nu este `nullish`. Are o proprietate numitÄƒ `name`, È™i returneazÄƒ `Mara`.
`person.pet?.family?.name`: `person` are o proprietate numitÄƒ `pet`: `person.pet` nu este `nullish`. `pet` _nu_ are o proprietate numitÄƒ `family`, `person.pet.family` este `nullish`. Expresia returneazÄƒ `undefined`.
`person.getFullName?.()`: `person` are o proprietate `getFullName`: `person.getFullName()` nu este `nullish` È™i poate fi invocatÄƒ, care returneazÄƒ `Lydia Hallie`.
`member.getLastName?.()`: variabila `member` nu existÄƒ, prin urmare se va genera o excepÈ›ie de tip `ReferenceError` gets thrown!

</p>
</details>

---

###### 120. Care este rezultatul?

```javascript
const groceries = ['banana', 'apple', 'peanuts'];

if (groceries.indexOf('banana')) {
  console.log('We have to buy bananas!');
} else {
  console.log(`We don't have to buy bananas!`);
}
```

- A: We have to buy bananas!
- B: We don't have to buy bananas
- C: `undefined`
- D: `1`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: B

Am trecut condiÈ›ia `groceries.indexOf("banana")` Ã®n instrucÈ›iunea `if`. `groceries.indexOf("banana")` returneazÄƒ `0`, care este o valoare falsÄƒ. Deoarece condiÈ›ia din instrucÈ›iunea `if` este falsÄƒ, se executÄƒ codul din blocul `else`, È™i `We don't have to buy bananas!` se afiÈ™eazÄƒ.

</p>
</details>

---

###### 121. Care este rezultatul?

```javascript
const config = {
  languages: [],
  set language(lang) {
    return this.languages.push(lang);
  },
};

console.log(config.language);
```

- A: `function language(lang) { this.languages.push(lang }`
- B: `0`
- C: `[]`
- D: `undefined`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: D

Metoda `language` este un `setter`. Setter-urile nu reÈ›in o valoare realÄƒ; scopul lor este sÄƒ _modifice_ proprietÄƒÈ›i. Atunci cÃ¢nd apelaÈ›i o metodÄƒ `setter`, aceasta va returna `undefined`.

</p>
</details>

---

###### 122. Care este rezultatul?

```javascript
const name = 'Lydia Hallie';

console.log(!typeof name === 'object');
console.log(!typeof name === 'string');
```

- A: `false` `true`
- B: `true` `false`
- C: `false` `false`
- D: `true` `true`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: C

`typeof name` returneazÄƒ `"string"`. È˜irul de caractere `"string"` este o valoare adevÄƒratÄƒ (truthy), aÈ™a cÄƒ `!typeof name` returneazÄƒ valoarea booleanÄƒ `false`. `false === "object"` È™i `false === "string"` ambele returneazÄƒ `false`.

(DacÄƒ dorim sÄƒ verificÄƒm dacÄƒ tipul este (ne)egal cu un anumit tip, ar trebui sÄƒ folosim `!==` Ã®n loc de `!typeof`)

</p>
</details>

---

###### 123. Care este rezultatul?

```javascript
const add = x => y => z => {
  console.log(x, y, z);
  return x + y + z;
};

add(4)(5)(6);
```

- A: `4` `5` `6`
- B: `6` `5` `4`
- C: `4` `function` `function`
- D: `undefined` `undefined` `6`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: A

FuncÈ›ia `add` returneazÄƒ o funcÈ›ie arrow, care returneazÄƒ o altÄƒ funcÈ›ie arrow, care la rÃ¢ndul ei returneazÄƒ o altÄƒ funcÈ›ie arrow (Ã®ncÄƒ sunteÈ›i cu mine?). Prima funcÈ›ie primeÈ™te un argument `x` cu valoarea `4`. ApelÄƒm a doua funcÈ›ie, care primeÈ™te un argument `y` cu valoarea `5`. Apoi apelÄƒm a treia funcÈ›ie, care primeÈ™te un argument `z` cu valoarea `6`. CÃ¢nd Ã®ncercÄƒm sÄƒ accesÄƒm valorile `x`, `y` È™i `z` Ã®n ultima funcÈ›ie arrow, motorul JavaScript urcÄƒ lanÈ›ul de domenii pentru a gÄƒsi valorile pentru `x` È™i `y` Ã®n consecinÈ›Äƒ. Aceasta returneazÄƒ `4` `5` `6`.

</p>
</details>

---

###### 124. Care este rezultatul?

```javascript
async function* range(start, end) {
  for (let i = start; i <= end; i++) {
    yield Promise.resolve(i);
  }
}

(async () => {
  const gen = range(1, 3);
  for await (const item of gen) {
    console.log(item);
  }
})();
```

- A: `Promise {1}` `Promise {2}` `Promise {3}`
- B: `Promise {<pending>}` `Promise {<pending>}` `Promise {<pending>}`
- C: `1` `2` `3`
- D: `undefined` `undefined` `undefined`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: C

FuncÈ›ia generator `range` returneazÄƒ un obiect asincron cu promisiuni pentru fiecare element din intervalul pe care Ã®l transmitem: `Promise{1}`, `Promise{2}`, `Promise{3}`. SetÄƒm variabila `gen` egalÄƒ cu obiectul asincron, dupÄƒ care facem o buclÄƒ peste el folosind o buclÄƒ `for await ... of`. SetÄƒm variabila `item` eegalÄƒ cu valorile promisiunilor returnate: mai Ã®ntÃ¢i `Promise{1}`, apoi `Promise{2}`, apoi `Promise{3}`. Deoarece _aÈ™teptÄƒm_ valoarea lui `item`, adicÄƒ promisiunea rezolvatÄƒ, _valorile_ rezolvate ale promisiunilor sunt returnate: `1`, `2`, apoi `3`.

</p>
</details>

---

###### 125. Care este rezultatul?

```javascript
const myFunc = ({ x, y, z }) => {
  console.log(x, y, z);
};

myFunc(1, 2, 3);
```

- A: `1` `2` `3`
- B: `{1: 1}` `{2: 2}` `{3: 3}`
- C: `{ 1: undefined }` `undefined` `undefined`
- D: `undefined` `undefined` `undefined`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: D

`myFunc` aÈ™teaptÄƒ ca argument un obiect cu proprietÄƒÈ›ile `x`, `y` È™i `z`. Deoarece transmitem doar trei valori numerice separate (1, 2, 3) Ã®n loc de un obiect cu proprietÄƒÈ›ile `x`, `y` È™i `z` ({x: 1, y: 2, z: 3}), `x`, `y` È™i `z` primesc valoarea lor implicitÄƒ, care este `undefined`.

</p>
</details>

---

###### 126. Care este rezultatul?

```javascript
function getFine(speed, amount) {
  const formattedSpeed = new Intl.NumberFormat('en-US', {
    style: 'unit',
    unit: 'mile-per-hour'
  }).format(speed);

  const formattedAmount = new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: 'USD'
  }).format(amount);

  return `È˜oferul a condus ${formattedSpeed} È™i trebuie sÄƒ plÄƒteascÄƒ ${formattedAmount}`;
}

console.log(getFine(130, 300))
```

- A: È˜oferul a condus 130 È™i trebuie sÄƒ plÄƒteascÄƒ 300
- B: È˜oferul a condus 130 mph È™i trebuie sÄƒ plÄƒteascÄƒ \$300.00
- C: È˜oferul a condus undefined È™i trebuie sÄƒ plÄƒteascÄƒ undefined
- D: È˜oferul a condus 130.00 È™i trebuie sÄƒ plÄƒteascÄƒ 300.00

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: B

Cu metoda `Intl.NumberFormat` putem formata valorile numerice Ã®n orice locaÈ›ie. Formatez valoarea numericÄƒ `130` pentru locaÈ›ia `en-US` ca o `unitate` Ã®n `mile-per-hour`, ceea ce rezultÄƒ Ã®n `130 mph`. Valoarea numericÄƒ `300` pentru locaÈ›ia `en-US` ca `monedÄƒ` Ã®n `USD` rezultÄƒ Ã®n `$300.00`.

</p>
</details>

---

###### 127. Care este rezultatul?

```javascript
const spookyItems = ['ğŸ‘»', 'ğŸƒ', 'ğŸ•¸'];
({ item: spookyItems[3] } = { item: 'ğŸ’€' });

console.log(spookyItems);
```

- A: `["ğŸ‘»", "ğŸƒ", "ğŸ•¸"]`
- B: `["ğŸ‘»", "ğŸƒ", "ğŸ•¸", "ğŸ’€"]`
- C: `["ğŸ‘»", "ğŸƒ", "ğŸ•¸", { item: "ğŸ’€" }]`
- D: `["ğŸ‘»", "ğŸƒ", "ğŸ•¸", "[object Object]"]`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: B

Prin destrucÈ›urarea obiectelor, putem extrage valorile din obiectul din partea dreaptÄƒ È™i le atribui valorii cu acelaÈ™i nume de proprietate din obiectul din partea stÃ¢ngÄƒ. Ãn acest caz, atribuim valoarea "ğŸ’€" lui `spookyItems[3]`. Acest lucru Ã®nseamnÄƒ cÄƒ modificÄƒm array-ul `spookyItems`, adÄƒugÄƒm "ğŸ’€" la el. La afiÈ™area Ã®n consolÄƒ a lui `spookyItems`, se va afiÈ™a `["ğŸ‘»", "ğŸƒ", "ğŸ•¸", "ğŸ’€"]`.

</p>
</details>

---

###### 128. Care este rezultatul?

```javascript
const name = 'Lydia Hallie';
const age = 21;

console.log(Number.isNaN(name));
console.log(Number.isNaN(age));

console.log(isNaN(name));
console.log(isNaN(age));
```

- A: `true` `false` `true` `false`
- B: `true` `false` `false` `false`
- C: `false` `false` `true` `false`
- D: `false` `true` `false` `true`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: C

Cu metoda `Number.isNaN` puteÈ›i verifica dacÄƒ valoarea pe care o transmiteÈ›i este o _valoare numericÄƒ_ È™i este egalÄƒ cu `NaN`. `name` nu este o valoare numericÄƒ, aÈ™a cÄƒ `Number.isNaN(name)` returneazÄƒ `false`. `age` este o valoare numericÄƒ, dar nu este egalÄƒ cu `NaN`, astfel cÄƒ `Number.isNaN(age)` returneazÄƒ `false`.

Cu metoda `isNaN` puteÈ›i verifica dacÄƒ valoarea pe care o transmiteÈ›i nu este un numÄƒr. `name` nu este un numÄƒr, aÈ™a cÄƒ `isNaN(name)` returneazÄƒ `true`. `age` este un numÄƒr, astfel cÄƒ `isNaN(age)` returneazÄƒ `false`.

</p>
</details>

---

###### 129. Care este rezultatul?

```javascript
const randomValue = 21;

function getInfo() {
  console.log(typeof randomValue);
  const randomValue = 'Lydia Hallie';
}

getInfo();
```

- A: `"number"`
- B: `"string"`
- C: `undefined`
- D: `ReferenceError`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: D

Variabilele declarate cu cuvÃ¢ntul cheie `const` nu pot fi referite Ã®nainte de iniÈ›ializare: acest lucru se numeÈ™te _zona temporalÄƒ moartÄƒ_ (temporal dead zone). Ãn funcÈ›ia `getInfo`, variabila`randomValue` este de domeniu Ã®n domeniul funcÈ›ional al funcÈ›iei `getInfo`. Pe linia Ã®n care dorim sÄƒ afiÈ™Äƒm valoarea `typeof randomValue`, variabila `randomValue` nu este Ã®ncÄƒ iniÈ›ializatÄƒ: se va genera o eroare de tip `ReferenceError`! Motorul nu a cÄƒutat Ã®n josul lanÈ›ului de domenii deoarece am declarat variabila `randomValue` Ã®n funcÈ›ia `getInfo`.

</p>
</details>

---

###### 130. Care este rezultatul?

```javascript
const myPromise = Promise.resolve('Woah some cool data');

(async () => {
  try {
    console.log(await myPromise);
  } catch {
    throw new Error(`Oops didn't work`);
  } finally {
    console.log('Oh finally!');
  }
})();
```

- A: `Woah some cool data`
- B: `Oh finally!`
- C: `Woah some cool data` `Oh finally!`
- D: `Oops didn't work` `Oh finally!`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: C

Ãn blocul `try`  Ã®nregistrÄƒm valoarea aÈ™teptatÄƒ a variabilei `myPromise`: `"Woah some cool data"`. Deoarece nu s-au generat erori Ã®n blocul `try` codul din blocul `catch` nu se executÄƒ. Codul din blocul `finally` se executÄƒ _Ã®ntotdeauna_, È™i se va afiÈ™a `"Oh finally!"`.

</p>
</details>

---

###### 131. Care este rezultatul?

```javascript
const emojis = ['ğŸ¥‘', ['âœ¨', 'âœ¨', ['ğŸ•', 'ğŸ•']]];

console.log(emojis.flat(1));
```

- A: `['ğŸ¥‘', ['âœ¨', 'âœ¨', ['ğŸ•', 'ğŸ•']]]`
- B: `['ğŸ¥‘', 'âœ¨', 'âœ¨', ['ğŸ•', 'ğŸ•']]`
- C: `['ğŸ¥‘', ['âœ¨', 'âœ¨', 'ğŸ•', 'ğŸ•']]`
- D: `['ğŸ¥‘', 'âœ¨', 'âœ¨', 'ğŸ•', 'ğŸ•']`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: B

Cu metoda `flat` putem crea un nou array aplatizat. AdÃ¢ncimea array-ului aplatizat depinde de valoarea pe care o transmitem. Ãn acest caz, am transmis valoarea `1` (care nu era necesarÄƒ, deoarece aceasta este valoarea implicitÄƒ), ceea ce Ã®nseamnÄƒ cÄƒ vor fi concatenate doar array-urile de pe primul nivel de adÃ¢ncime. `['ğŸ¥‘']` È™i `['âœ¨', 'âœ¨', ['ğŸ•', 'ğŸ•']]`. Concatenarea acestor douÄƒ array-uri rezultÄƒ Ã®n `['ğŸ¥‘', 'âœ¨', 'âœ¨', ['ğŸ•', 'ğŸ•']]`.

</p>
</details>

---

###### 132. Care este rezultatul?

```javascript
class Counter {
  constructor() {
    this.count = 0;
  }

  increment() {
    this.count++;
  }
}

const counterOne = new Counter();
counterOne.increment();
counterOne.increment();

const counterTwo = counterOne;
counterTwo.increment();

console.log(counterOne.count);
```

- A: `0`
- B: `1`
- C: `2`
- D: `3`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: D

`counterOne` este o instanÈ›Äƒ a clasei `Counter`. Clasa `Counter` conÈ›ine o proprietate `count` Ã®n constructorul sÄƒu È™i o metodÄƒ `increment`. Mai Ã®ntÃ¢i, am invocat metoda `increment` de douÄƒ ori, apelÃ¢nd `counterOne.increment()`. Ãn prezent, `counterOne.count` este `2`.

<img src="https://i.imgur.com/KxLlTm9.png" width="400">

Apoi, creÄƒm o nouÄƒ variabilÄƒ `counterTwo`, È™i o setÄƒm egalÄƒ cu `counterOne`. Deoarece obiectele interacÈ›ioneazÄƒ prin referinÈ›Äƒ, creÄƒm doar o nouÄƒ referinÈ›Äƒ cÄƒtre acelaÈ™i loc Ã®n memorie la care indicÄƒ `counterOne`. Deoarece au acelaÈ™i loc Ã®n memorie, orice modificÄƒri fÄƒcute asupra obiectului la care `counterTwo` are o referinÈ›Äƒ se aplicÄƒ È™i la `counterOne`. Ãn prezen, `counterTwo.count` este `2`.

ApelÄƒm `counterTwo.increment()`, ceea ce seteazÄƒ `count` la `3`. Apoi, afiÈ™Äƒm valoarea lui `counterOne`, ceea ce va afiÈ™a `3`.

<img src="https://i.imgur.com/BNBHXmc.png" width="400">

</p>
</details>

---

###### 133. Care este rezultatul?

```javascript
const myPromise = Promise.resolve(Promise.resolve('Promise'));

function funcOne() {
  setTimeout(() => console.log('Timeout 1!'), 0);
  myPromise.then(res => res).then(res => console.log(`${res} 1!`));
  console.log('Last line 1!');
}

async function funcTwo() {
  const res = await myPromise;
  console.log(`${res} 2!`)
  setTimeout(() => console.log('Timeout 2!'), 0);
  console.log('Last line 2!');
}

funcOne();
funcTwo();
```

- A: `Promise 1! Last line 1! Promise 2! Last line 2! Timeout 1! Timeout 2!`
- B: `Last line 1! Timeout 1! Promise 1! Last line 2! Promise2! Timeout 2! `
- C: `Last line 1! Promise 2! Last line 2! Promise 1! Timeout 1! Timeout 2!`
- D: `Timeout 1! Promise 1! Last line 1! Promise 2! Timeout 2! Last line 2!`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: C

Ãn primul rÃ¢nd, apelÄƒm `funcOne`. Pe prima linie a lui `funcOne`, apelÄƒm funcÈ›ia _asincronÄƒ_ `setTimeout`, din care funcÈ›ia de apel se trimite cÄƒtre API-ul Web. (vezi articolul meu despre bucla evenimentelor <a href="https://dev.to/lydiahallie/javascript-visualized-event-loop-3dif">aici</a>.)

Apoi apelÄƒm promisiunea `myPromise` care este o operaÈ›iune _asincronÄƒ_.

Ambele promisiuni È™i Ã®ntÃ¢rzierile (timeout) sunt operaÈ›iuni asincrone, iar funcÈ›ia continuÄƒ sÄƒ ruleze Ã®n timp ce finalizeazÄƒ promisiunea È™i gestioneazÄƒ apelul de Ã®ntÃ¢rziere `setTimeout`. Acest lucru Ã®nseamnÄƒ cÄƒ se va afiÈ™a mai Ã®ntÃ¢i `Last line 1!`, deoarece aceasta nu este o operaÈ›iune asincronÄƒ. 

Deoarece stiva de apel nu este Ã®ncÄƒ goalÄƒ, funcÈ›ia `setTimeout` È™i promisiunea din `funcOne` nu pot fi adÄƒugate Ã®ncÄƒ la stiva de apel.

Ãn `funcTwo`, variabila `res` primeÈ™te o `Promise` pentru cÄƒ `Promise.resolve(Promise.resolve('Promise'))` este echivalent cu `Promise.resolve('Promise')` deoarece rezolvarea unei promisiuni rezolvÄƒ doar valoarea acesteia. CuvÃ¢ntul cheie `await` din aceastÄƒ linie opreÈ™te execuÈ›ia funcÈ›iei pÃ¢nÄƒ cÃ¢nd primeÈ™te rezoluÈ›ia promisiunii È™i apoi continuÄƒ sÄƒ ruleze sincron pÃ¢nÄƒ la finalizare, aÈ™a cÄƒ sunt afiÈ™ate `Promise 2!` apoi `Last line 2!` iar apelul `setTimeout` este trimis cÄƒtre API-ul Web.

Apoi stiva de apel este goalÄƒ. Promisiunile sunt _microtask-uri_ astfel cÄƒ sunt rezolvate Ã®n primul rÃ¢nd atunci cÃ¢nd stiva de apel este goalÄƒ, aÈ™a cÄƒ se afiÈ™eazÄƒ `Promise 1!`.

Acum, deoarece `funcTwo` pa fost scoasÄƒ din stiva de apel, stiva de apel este goalÄƒ. Callback-urile aÈ™teptÃ¢nd Ã®n coadÄƒ (`() => console.log("Timeout 1!")` din `funcOne`, È™i `() => console.log("Timeout 2!")` din `funcTwo`) sunt adÄƒugate pe stivÄƒ unul cÃ¢te unul. Primul callback afiÈ™eazÄƒ `Timeout 1!`, È™i este eliminat din stivÄƒ. Apoi, al doilea callback afiÈ™eazÄƒ `Timeout 2!`, È™i este eliminat din stivÄƒ.

</p>
</details>

---

###### 134. Cum putem apela funcÈ›ia `sum` Ã®n `sum.js` din `index.js`?

```javascript
// sum.js
export default function sum(x) {
  return x + x;
}

// index.js
import * as sum from './sum';
```

- A: `sum(4)`
- B: `sum.sum(4)`
- C: `sum.default(4)`
- D: Exporturile implicite nu sunt importate cu `*`, doar exporturile numite

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: C

Cu asteriscul `*`, importÄƒm toate valorile exportate din acel fiÈ™ier, atÃ¢t exporturile implicite, cÃ¢t È™i cele numite. DacÄƒ avem urmÄƒtorul fiÈ™ierÈ˜

```javascript
// info.js
export const name = 'Lydia';
export const age = 21;
export default 'I love JavaScript';

// index.js
import * as info from './info';
console.log(info);
```

Acesta ar fi rezultatul Ã®nregistrÄƒrilor:

```javascript
{
  default: "I love JavaScript",
  name: "Lydia",
  age: 21
}
```

Pentru exemplul cu funcÈ›ia `sum`, Ã®nseamnÄƒ cÄƒ valoarea importatÄƒ `sum` aratÄƒ Ã®n felul urmÄƒtor:

```javascript
{ default: function sum(x) { return x + x } }
```

Putem invoca aceastÄƒ funcÈ›ie, apelÃ¢nd `sum.default`

</p>
</details>

---

###### 135. Care este rezultatul?

```javascript
const handler = {
  set: () => console.log('Added a new property!'),
  get: () => console.log('Accessed a property!'),
};

const person = new Proxy({}, handler);

person.name = 'Lydia';
person.name;
```

- A: `Added a new property!`
- B: `Accessed a property!`
- C: `Added a new property!` `Accessed a property!`
- D: Nu se Ã®nregistreazÄƒ nimic

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: C

Cu un obiect Proxy, putem adÄƒuga comportament personalizat unui obiect pe care Ã®l transmitem ca al doilea argument. Ãn acest caz, transmitem obiectul `handler` care conÈ›ine douÄƒ proprietÄƒÈ›i: `set` È™i `get`. `set` este invocatÄƒ ori de cÃ¢te ori _set_ (setÄƒm) valori de proprietate, `get` este invocatÄƒ ori de cÃ¢te ori _get_ (accesÄƒm) valori de proprietate.

Primul argument este un obiect gol `{}`, care este valoarea lui `person`. La acest obiect, se adaugÄƒ comportamentul personalizat specificat Ã®n obiectul `handler`. DacÄƒ adÄƒugÄƒm o proprietate la obiectul `person`, `set` va fi invocatÄƒ. DacÄƒ accesÄƒm o proprietate a obiectului `person`, `get` va fi invocatÄƒ.

Ãn primul rÃ¢nd, am adÄƒugat o nouÄƒ proprietate `name` la obiectul proxy (`person.name = "Lydia"`). `set` este invocatÄƒ È™i Ã®nregistreazÄƒ mesajul `"Added a new property!"`.

Then, we access a property value on the proxy object, the `get` property on the handler object got invoked. `"Accessed a property!"` gets logged.

</p>
</details>

---

###### 136. Care dintre urmÄƒtoarele va modifica obiectul `person`?

```javascript
const person = { name: 'Lydia Hallie' };

Object.seal(person);
```

- A: `person.name = "Evan Bacon"`
- B: `person.age = 21`
- C: `delete person.name`
- D: `Object.assign(person, { age: 21 })`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: A

Cu `Object.seal` putem preveni _adÄƒugarea_ de noi proprietÄƒÈ›i sau _eliminarea_ proprietÄƒÈ›ilor existente.

Cu toate acestea, puteÈ›i Ã®ncÄƒ sÄƒ modificaÈ›i valoarea proprietÄƒÈ›ilor existente.

</p>
</details>

---

###### 137. Care dintre urmÄƒtoarele va modifica obiectul `person`?

```javascript
const person = {
  name: 'Lydia Hallie',
  address: {
    street: '100 Main St',
  },
};

Object.freeze(person);
```

- A: `person.name = "Evan Bacon"`
- B: `delete person.address`
- C: `person.address.street = "101 Main St"`
- D: `person.pet = { name: "Mara" }`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: C

Metoda `Object.freeze` _Ã®ngheaÈ›Äƒ_ un obiect. Nu se pot adÄƒuga, modifica sau elimina proprietÄƒÈ›i.

Cu toate acestea, aceasta Ã®ngheaÈ›Äƒ obiectul doar Ã®n mod _superficial_, ceea ce Ã®nseamnÄƒ cÄƒ numai proprietÄƒÈ›ile _directe_ ale obiectului sunt Ã®ngheÈ›ate. DacÄƒ proprietatea este un alt obiect, cum ar fi `address` Ã®n acest caz, proprietÄƒÈ›ile de pe acel obiect nu sunt Ã®ngheÈ›ate È™i pot fi modificate.

</p>
</details>

---

###### 138. Care este rezultatul?

```javascript
const add = x => x + x;

function myFunc(num = 2, value = add(num)) {
  console.log(num, value);
}

myFunc();
myFunc(3);
```

- A: `2` `4` È™i `3` `6`
- B: `2` `NaN` È™i `3` `NaN`
- C: `2` `Error` È™i `3` `6`
- D: `2` `4` È™i `3` `Error`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: A

Ãn primul rÃ¢nd, am apelat `myFunc()` fÄƒrÄƒ a transmite niciun argument. Deoarece nu am transmis argumente, `num` È™i `value` au primit valorile lor implicite: `num` este `2`, È™i `value` este valoarea returnatÄƒ de funcÈ›ia `add`. FuncÈ›iei `add` Ã®i transmitem `num` ca argument, care avea valoarea `2`. `add` returneazÄƒ `4`, care este valoarea lui `value`.

Apoi, am apelat `myFunc(3)` È™i am transmis valoarea `3` ca valoare pentru argumentul `num`. Nu am transmis un argument pentru `value`. Deoarece nu am transmis o valoare pentru argumentul `value` acesta a primit valoarea implicitÄƒ: valoarea returnatÄƒ de funcÈ›ia `add`. FuncÈ›iei `add`, Ã®i transmitem `num`, care are valoarea `3`. `add` returneazÄƒ `6`, care este valoarea lui `value`.

</p>
</details>

---

###### 139. Care este rezultatul?

```javascript
class Counter {
  #number = 10

  increment() {
    this.#number++
  }

  getNum() {
    return this.#number
  }
}

const counter = new Counter()
counter.increment()

console.log(counter.#number)
```

- A: `10`
- B: `11`
- C: `undefined`
- D: `SyntaxError`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: D

Ãn ES2020, putem adÄƒuga variabile private Ã®n clase folosind simbolul `#`. Nu putem accesa aceste variabile Ã®n afara clasei. Atunci cÃ¢nd Ã®ncercÄƒm sÄƒ Ã®nregistrÄƒm `counter.#number`, se aruncÄƒ o eroare de sintaxÄƒ (SyntaxError): nu putem accesa aceastÄƒ variabilÄƒ Ã®n afara clasei `Counter`!

</p>
</details>

---

###### 140. Ce lipseÈ™te?

```javascript
const teams = [
  { name: 'Team 1', members: ['Paul', 'Lisa'] },
  { name: 'Team 2', members: ['Laura', 'Tim'] },
];

function* getMembers(members) {
  for (let i = 0; i < members.length; i++) {
    yield members[i];
  }
}

function* getTeams(teams) {
  for (let i = 0; i < teams.length; i++) {
    // âœ¨ SOMETHING IS MISSING HERE âœ¨
  }
}

const obj = getTeams(teams);
obj.next(); // { value: "Paul", done: false }
obj.next(); // { value: "Lisa", done: false }
```

- A: `yield getMembers(teams[i].members)`
- B: `yield* getMembers(teams[i].members)`
- C: `return getMembers(teams[i].members)`
- D: `return yield getMembers(teams[i].members)`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: B

Pentru a itera prin `membrii` din fiecare element din array-ul `members` trebuie sÄƒ transmitem `teams[i].members` cÄƒtre funcÈ›ia generator `getMembers`. FuncÈ›ia generator returneazÄƒ un obiect generator. Pentru a itera prin fiecare element din acest obiect generator, trebuie sÄƒ folosim `yield*`.

DacÄƒ am fi scris `yield`, `return yield`, sau `return`, Ã®ntreaga funcÈ›ie generator ar fi fost returnatÄƒ prima datÄƒ cÃ¢nd am apelat metoda `next`.

</p>
</details>

---

###### 141. Care este rezultatul?

```javascript
const person = {
  name: 'Lydia Hallie',
  hobbies: ['coding'],
};

function addHobby(hobby, hobbies = person.hobbies) {
  hobbies.push(hobby);
  return hobbies;
}

addHobby('running', []);
addHobby('dancing');
addHobby('baking', person.hobbies);

console.log(person.hobbies);
```

- A: `["coding"]`
- B: `["coding", "dancing"]`
- C: `["coding", "dancing", "baking"]`
- D: `["coding", "running", "dancing", "baking"]`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: C

FuncÈ›ia `addHobby` primeÈ™te douÄƒ argumente, `hobby` È™i `hobbies` cu valoarea implicitÄƒ a array-ului `hobbies` din obiectul `person`.

Ãn primul rÃ¢nd, apelÄƒm funcÈ›ia `addHobby`, È™i transmitem `"running"` ca valoare pentru `hobby` È™i un array gol ca valoare pentru `hobbies`. Deoarece transmitem un array gol ca valoare pentru `hobbies`, `"running"` este adÄƒugat la acest array gol.

Apoi, apelÄƒm funcÈ›ia `addHobby` È™i transmitem `"dancing"` ca valoare pentru `hobby`. Nu am transmis o valoare pentru `hobbies`, astfel cÄƒ aceasta primeÈ™te valoarea implicitÄƒ, adicÄƒ proprietatea `hobbies` din obiectul `person`. AdÄƒugÄƒm hobby-ul `dancing` Ã®n array-ul `person.hobbies`.

Ãn final, apelÄƒm funcÈ›ia `addHobby`, È™i transmitem `"baking"` ca valoare pentru `hobby`, È™i array-ul `person.hobbies` ca valoare pentru `hobbies`. AdÄƒugÄƒm hobby-ul `baking` Ã®n array-ul `person.hobbies`.

DupÄƒ adÄƒugarea lui `dancing` È™i `baking`, valoarea lui `person.hobbies` este `["coding", "dancing", "baking"]`

</p>
</details>

---

###### 142. Care este rezultatul?

```javascript
class Bird {
  constructor() {
    console.log("I'm a bird. ğŸ¦¢");
  }
}

class Flamingo extends Bird {
  constructor() {
    console.log("I'm pink. ğŸŒ¸");
    super();
  }
}

const pet = new Flamingo();
```

- A: `I'm pink. ğŸŒ¸`
- B: `I'm pink. ğŸŒ¸` `I'm a bird. ğŸ¦¢`
- C: `I'm a bird. ğŸ¦¢` `I'm pink. ğŸŒ¸`
- D: Nimic, nu am apelat la nicio metodÄƒ

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: B

CreÄƒm variabila `pet` care este o instanÈ›Äƒ a clasei `Flamingo`. CÃ¢nd instantiem aceastÄƒ instanÈ›Äƒ, `constructor` din clasa `Flamingo` este apelat. Mai Ã®ntÃ¢i, se Ã®nregistreazÄƒ `"I'm pink. ğŸŒ¸"` dupÄƒ care apelÄƒm `super()`. `super()` apeleazÄƒ constructorul clasei pÄƒrinte, `Bird`. Constructorul din clasa `Bird` este apelat È™i Ã®nregistreazÄƒ `"I'm a bird. ğŸ¦¢"`.

</p>
</details>

---

###### 143. Care dintre opÈ›iuni rezultÄƒ Ã®ntr-o eroare?

```javascript
const emojis = ['ğŸ„', 'ğŸ…ğŸ¼', 'ğŸ', 'â­'];

/* 1 */ emojis.push('ğŸ¦Œ');
/* 2 */ emojis.splice(0, 2);
/* 3 */ emojis = [...emojis, 'ğŸ¥‚'];
/* 4 */ emojis.length = 0;
```

- A: 1
- B: 1 È™i 2
- C: 3 È™i 4
- D: 3

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: D

CuvÃ¢ntul cheie `const` Ã®nseamnÄƒ pur È™i simplu cÄƒ nu putem _redeclara_ valoarea acelei variabile, aceasta este _numai pentru citire_ (read-only). Cu toate acestea, valoarea Ã®n sine nu este imutabilÄƒ. ProprietÄƒÈ›ile din array-ul `emojis` pot fi modificate, de exemplu, prin adÄƒugarea de valori noi, prin decuparea lor sau prin setarea lungimii array-ului la 0.

</p>
</details>

---

###### 144. Ce trebuie sÄƒ adÄƒugÄƒm la obiectul `person` pentru a obÈ›ine `["Lydia Hallie", 21]` ca rezultat al `[...person]`?

```javascript
const person = {
  name: "Lydia Hallie",
  age: 21
}

[...person] // ["Lydia Hallie", 21]
```

- A: Nimic, obiectele sunt iterabile Ã®n mod implicit
- B: `*[Symbol.iterator]() { for (let x in this) yield* this[x] }`
- C: `*[Symbol.iterator]() { yield* Object.values(this) }`
- D: `*[Symbol.iterator]() { for (let x in this) yield this }`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: C

Obiectele nu sunt iterabile Ã®n mod implicit. Un obiect devine iterabil atunci cÃ¢nd protocolul iterator este prezent. Putem adÄƒuga acest protocol manual prin adÄƒugarea simbolului iterator `[Symbol.iterator]`, care trebuie sÄƒ returneze un obiect generator, de exemplu, prin definirea unei funcÈ›ii generator `*[Symbol.iterator]() {}`. AceastÄƒ funcÈ›ie generator trebuie sÄƒ furnizeze `Object.values` ale obiectulu `person` pentru a obÈ›ine array-ul `["Lydia Hallie", 21]`: `yield* Object.values(this)`.

</p>
</details>

---

###### 145. Care este rezultatul?

```javascript
let count = 0;
const nums = [0, 1, 2, 3];

nums.forEach(num => {
	if (num) count += 1
})

console.log(count)
```

- A: 1
- B: 2
- C: 3
- D: 4

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: C

CondiÈ›ia `if` din interiorul buclei `forEach` verificÄƒ dacÄƒ valoarea lui `num` este adevÄƒratÄƒ (truthy) sau falsÄƒ (falsy). Deoarece primul numÄƒr din array-ul `nums` este `0`, o valoare falsÄƒ, blocul de cod al instrucÈ›iunii `if` nu va fi executat. `count` se incrementeazÄƒ doar pentru celelalte 3 numere din array-ul `nums`, adicÄƒ `1`, `2` È™i `3`. Deoarece `count` se incrementeazÄƒ cu `1` de 3 ori, valoarea lui `count` este `3`.

</p>
</details>

---

###### 146. Care este rezultatul?

```javascript
function getFruit(fruits) {
	console.log(fruits?.[1]?.[1])
}

getFruit([['ğŸŠ', 'ğŸŒ'], ['ğŸ']])
getFruit()
getFruit([['ğŸ'], ['ğŸŠ', 'ğŸŒ']])
```

- A: `null`, `undefined`, ğŸŒ
- B: `[]`, `null`, ğŸŒ
- C: `[]`, `[]`, ğŸŒ
- D: `undefined`, `undefined`, ğŸŒ

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: D

Simbolul `?` ne permite sÄƒ accesÄƒm opÈ›ional proprietÄƒÈ›i mai adÃ¢nc Ã®n obiecte. ÃncercÄƒm sÄƒ Ã®nregistrÄƒm elementul de pe indexul `1` din sub-array-ul de pe indexul `1` al array-ului `fruits`. DacÄƒ sub-array-ul de pe indexul `1` din array-ul `fruits` nu existÄƒ, va returna pur È™i simplu `undefined`. DacÄƒ sub-array-ul de pe indexul `1` din array-ul `fruits` existÄƒ, dar acest sub-array nu are un element pe indexul `1` va returna, de asemenea, `undefined`. 

Ãn primul rÃ¢nd, Ã®ncercÄƒm sÄƒ Ã®nregistrÄƒm al doilea element din sub-array-ul`['ğŸ']` din `[['ğŸŠ', 'ğŸŒ'], ['ğŸ']]`. Acest sub-array conÈ›ine doar un singur element, ceea ce Ã®nseamnÄƒ cÄƒ nu existÄƒ niciun element pe indexul `1`, È™i va returna `undefined`.

Apoi, apelÄƒm funcÈ›ia `getFruits` fÄƒrÄƒ a transmite o valoare ca argument, ceea ce Ã®nseamnÄƒ cÄƒ `fruits` are implicit o valoare de `undefined`. Deoarece facem o verificare condiÈ›ionalÄƒ pentru accesarea elementului de pe indexul `1` al `fruits`, aceasta va returna `undefined` deoarece acest element de pe indexu `1` nu existÄƒ. 

Ãn cele din urmÄƒ, Ã®ncercÄƒm sÄƒ Ã®nregistrÄƒm al doilea element din sub-array-ul `['ğŸŠ', 'ğŸŒ']` din `['ğŸ'], ['ğŸŠ', 'ğŸŒ']`. Elementul de pe indexul `1` Ã®n acest sub-array este `ğŸŒ`, are este Ã®nregistrat.

</p>
</details>

---

###### 147. Care este rezultatul?

```javascript
class Calc {
	constructor() {
		this.count = 0 
	}

	increase() {
		this.count++
	}
}

const calc = new Calc()
new Calc().increase()

console.log(calc.count)
```

- A: `0`
- B: `1`
- C: `undefined`
- D: `ReferenceError`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: A

Am setat variabila `calc` gal cu o nouÄƒ instanÈ›Äƒ a clasei `Calc`. Apoi, am creat o altÄƒ instanÈ›Äƒ nouÄƒ a clasei `Calc`, È™i am apelat metoda `increase` pe aceastÄƒ instanÈ›Äƒ. Deoarece proprietatea `count` se aflÄƒ Ã®n constructorul clasei `Calc`, proprietatea `count` nu este partajatÄƒ Ã®n prototipul clasei `Calc`. Acest lucru Ã®nseamnÄƒ cÄƒ valoarea lui `count` nu a fost actualizatÄƒ pentru instanÈ›a cÄƒtre care aratÄƒ `calc` astfel Ã®ncÃ¢t `count` rÄƒmÃ¢ne `0`.

</p>
</details>

---

###### 148. Care este rezultatul?

```javascript
const user = {
	email: "e@mail.com",
	password: "12345"
}

const updateUser = ({ email, password }) => {
	if (email) {
		Object.assign(user, { email })
	}

	if (password) {
		user.password = password
	}

	return user
}

const updatedUser = updateUser({ email: "new@email.com" })

console.log(updatedUser === user)
```

- A: `false`
- B: `true`
- C: `TypeError`
- D: `ReferenceError`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: B

FuncÈ›ia `updateUser` actualizeazÄƒ valorile proprietÄƒÈ›ilor `email` È™i `password` ale obiectului `user`, dacÄƒ aceste valori sunt transmise funcÈ›iei, dupÄƒ care funcÈ›ia returneazÄƒ obiectul `user`. Valoarea returnatÄƒ a funcÈ›iei `updateUser` este obiectul `user`, ceea ce Ã®nseamnÄƒ cÄƒ valoarea lui `updatedUser` este o referinÈ›Äƒ cÄƒtre acelaÈ™i obiect `user` la care face referinÈ›Äƒ È™i `user`. `updatedUser === user` este egal cu `true`.

</p>
</details>

---

###### 149. Care este rezultatul?

```javascript
const fruit = ['ğŸŒ', 'ğŸŠ', 'ğŸ']

fruit.slice(0, 1)
fruit.splice(0, 1)
fruit.unshift('ğŸ‡')

console.log(fruit)
```

- A: `['ğŸŒ', 'ğŸŠ', 'ğŸ']`
- B: `['ğŸŠ', 'ğŸ']`
- C: `['ğŸ‡', 'ğŸŠ', 'ğŸ']`
- D: `['ğŸ‡', 'ğŸŒ', 'ğŸŠ', 'ğŸ']`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: C

Ãn primul rÃ¢nd, apelÄƒm metoda `slice` pe array-ul `fruit`. Metoda `slice` nu modificÄƒ array-ul original, ci returneazÄƒ valoarea pe care a tÄƒiat-o din array: emoji-ul de bananÄƒ.
Apoi, apelÄƒm metoda `splice` pe array-ul `fruit`. Metoda `splice` modificÄƒ array-ul original, ceea ce Ã®nseamnÄƒ cÄƒ array-ul `fruit` acum conÈ›ine `['ğŸŠ', 'ğŸ']`.
Ãn cele din urmÄƒ, apelÄƒm metoda `unshift` pe array-u `fruit`, care modificÄƒ array-ul original prin adÄƒugarea valorii furnizate, Ã®n acest caz, â€˜ğŸ‡â€™ ca prim element Ã®n array. Array-ul `fruit` acum conÈ›ine `['ğŸ‡', 'ğŸŠ', 'ğŸ']`.

</p>
</details>

---

###### 150. Care este rezultatul?

```javascript
const animals = {};
let dog = { emoji: 'ğŸ¶' }
let cat = { emoji: 'ğŸˆ' }

animals[dog] = { ...dog, name: "Mara" }
animals[cat] = { ...cat, name: "Sara" }

console.log(animals[dog])
```

- A: `{ emoji: "ğŸ¶", name: "Mara" }`
- B: `{ emoji: "ğŸˆ", name: "Sara" }`
- C: `undefined`
- D: `ReferenceError`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: B

Cheile obiectelor sunt convertite Ã®n È™iruri de caractere.

Deoarece valoarea lui `dog` este un obiect, `animals[dog]` Ã®nseamnÄƒ de fapt cÄƒ creÄƒm o nouÄƒ proprietate numitÄƒ `"object Object"` egalÄƒ cu noul obiect. `animals["object Object"]` este acum egal cu `{ emoji: "ğŸ¶", name: "Mara"}`.

`cat` este, de asemenea, un obiect, ceea ce Ã®nseamnÄƒ cÄƒ `animals[cat]` Ã®nseamnÄƒ de fapt cÄƒ suprascriem valoarea lui  `animals["object Object"]` cu noile proprietÄƒÈ›i ale pisicii. 

Ãnregistrarea `animals[dog]`, sau mai exact `animals["object Object"]` deoarece convertirea obiectului `dog` Ã®ntr-un È™ir rezultÄƒ Ã®n `"object Object"`, returneazÄƒ `{ emoji: "ğŸˆ", name: "Sara" }`.

</p>
</details>

---

###### 151. Care este rezultatul?

```javascript
const user = {
	email: "my@email.com",
	updateEmail: email => {
		this.email = email
	}
}

user.updateEmail("new@email.com")
console.log(user.email)
```

- A: `my@email.com`
- B: `new@email.com`
- C: `undefined`
- D: `ReferenceError`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: A

FuncÈ›ia `updateEmail` este o funcÈ›ie sÄƒgeatÄƒ È™i nu este legatÄƒ de obiectul `user`. Acest lucru Ã®nseamnÄƒ cÄƒ cuvÃ¢ntul cheie `this` nu se referÄƒ la obiectul `user`, ci se referÄƒ la domeniul global Ã®n acest caz. Valoarea `email` din obiectul `user` nu se actualizeazÄƒ. CÃ¢nd se Ã®nregistreazÄƒ valoarea `user.email`, se returneazÄƒ valoarea originalÄƒ `my@email.com`. 

</p>
</details>

---

###### 152. Care este rezultatul?

```javascript
const promise1 = Promise.resolve('First')
const promise2 = Promise.resolve('Second')
const promise3 = Promise.reject('Third')
const promise4 = Promise.resolve('Fourth')

const runPromises = async () => {
	const res1 = await Promise.all([promise1, promise2])
	const res2  = await Promise.all([promise3, promise4])
	return [res1, res2]
}

runPromises()
	.then(res => console.log(res))
	.catch(err => console.log(err))
```

- A: `[['First', 'Second'], ['Fourth']]`
- B: `[['First', 'Second'], ['Third', 'Fourth']]`
- C: `[['First', 'Second']]`
- D: `'Third'`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: D

Metoda `Promise.all` ruleazÄƒ promisiunile transmise Ã®n paralel. DacÄƒ o promisiune eÈ™ueazÄƒ, metoda `Promise.all` se _respinge_ cu valoarea promisiunii respinse. Ãn acest caz, `promise3` a fost respinsÄƒ cu valoarea `"Third"`. Prindem valoarea respinsÄƒ Ã®n metoda `catch` lantatÄƒ Ã®n invocarea `runPromises` pentru a prinde orice erori din interiorul funcÈ›iei `runPromises`. Se Ã®nregistreazÄƒ doar `"Third"` deoarece `promise3` a fost respinsÄƒ cu aceastÄƒ valoare.

</p>
</details>

---

###### 153. Ce valoare ar trebui sÄƒ aibÄƒ `method` pentru a Ã®nregistra `{ name: "Lydia", age: 22 }`? 

```javascript
const keys = ["name", "age"]
const values = ["Lydia", 22]

const method = /* ?? */
Object[method](keys.map((_, i) => {
	return [keys[i], values[i]]
})) // { name: "Lydia", age: 22 }
```

- A: `entries`
- B: `values`
- C: `fromEntries`
- D: `forEach`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: C

Metoda `fromEntries` transformÄƒ o matrice 2D Ã®ntr-un obiect. Primul element din fiecare submatrice va fi cheia, iar al doilea element din fiecare submatrice va fi valoarea. Ãn acest caz, facem mapare peste matricea `keys` care returneazÄƒ o matrice Ã®n care primul element este elementul din matricea cheilor la indexul curent, iar al doilea element este elementul din matricea valorilor la indexul curent. 

Acest lucru creeazÄƒ o matrice de submatrici care conÈ›in cheile È™i valorile corecte, rezultÃ¢nd Ã®n `{ name: "Lydia", age: 22 }`

</p>
</details>

---

###### 154. Care este rezultatul?

```javascript
const createMember = ({ email, address = {}}) => {
	const validEmail = /.+\@.+\..+/.test(email)
	if (!validEmail) throw new Error("Valid email pls")

	return {
		email,
		address: address ? address : null
	}
}

const member = createMember({ email: "my@email.com" })
console.log(member)
```

- A: `{ email: "my@email.com", address: null }`
- B: `{ email: "my@email.com" }`
- C: `{ email: "my@email.com", address: {} }`
- D: `{ email: "my@email.com", address: undefined }`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: C

Valoarea implicitÄƒ a lui `address` este un obiect gol `{}`. CÃ¢nd setÄƒm variabila `member` egalÄƒ cu obiectul returnat de funcÈ›ia `createMember`, nu am transmis o valoare pentru `address`, ceea ce Ã®nseamnÄƒ cÄƒ valoarea lui `address` este obiectul gol implicit `{}`. Un obiect gol este o valoare adevÄƒratÄƒ (truthy), ceea ce Ã®nseamnÄƒ cÄƒ condiÈ›ia din expresia ternarÄƒ `address ? address : null` returneazÄƒ `true`. Prin urmare, valoarea lui `address` este obiectul gol `{}`.

</p>
</details>

---

###### 155. Care este rezultatul?

```javascript
let randomValue = { name: "Lydia" }
randomValue = 23

if (!typeof randomValue === "string") {
	console.log("It's not a string!")
} else {
	console.log("Yay it's a string!")
}
```

- A: `It's not a string!`
- B: `Yay it's a string!`
- C: `TypeError`
- D: `undefined`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: B

CondiÈ›ia din instrucÈ›iunea `if` verificÄƒ dacÄƒ valoarea lui `!typeof randomValue` este egalÄƒ cu `"string"`. Operatorul `!` converteÈ™te valoarea la o valoare booleanÄƒ. DacÄƒ valoarea este adevÄƒratÄƒ (truthy), valoarea returnatÄƒ va fi `false`, iar dacÄƒ valoarea este falsÄƒ (falsy), valoarea returnatÄƒ va fi `true`. Ãn acest caz, valoarea returnatÄƒ de `typeof randomValue` este valoarea adevÄƒratÄƒ (truthy) `"number"`, ceea ce Ã®nseamnÄƒ cÄƒ valoarea lui `!typeof randomValue` este valoarea booleanÄƒ `false`.

`!typeof randomValue === "string"` Ã®ntotdeauna returneazÄƒ `false`, deoarece de fapt verificÄƒm `false === "string"`. Deoarece condiÈ›ia returneazÄƒ `false`, blocul de cod al instrucÈ›iunii `else` se executÄƒ, iar `Yay it's a string!` este Ã®nregistrat.

</p>
</details>
