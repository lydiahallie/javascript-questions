<div align="center">
  <img height="60" src="https://img.icons8.com/color/344/javascript.png">
  <h1>ÃntrebÄƒri JavaScript</h1>

---

<span>Postez Ã®ntrebÄƒri JavaScript cu opÈ›iuni multiple pe [Instagram](https://www.instagram.com/theavocoder) **stories**, pe care le voi posta È™i aici! Ultima actualizare: <a href=#20200612><b>12 Iunie</b></a>

De la nivel de bazÄƒ la avansat: testeazÄƒ cÃ¢t de bine cunoÈ™ti JavaScript, reÃ®mprospÄƒteazÄƒ-È›i puÈ›in cunoÈ™tinÈ›ele sau pregÄƒteÈ™te-te pentru interviul tÄƒu de codare! :muscle: :rocket: Actualizez acest depozit Ã®n mod regulat cu Ã®ntrebÄƒri noi. Am adÄƒugat rÄƒspunsurile Ã®n **secÈ›iunile restrÃ¢nse** de sub Ã®ntrebÄƒri, pur È™i simplu dÄƒ clic pe ele pentru a le extinde. Este doar pentru distracÈ›ie, mult noroc! :heart:</span>

Nu ezita sÄƒ mÄƒ contactezi! ğŸ˜Š <br />
<a href="https://www.instagram.com/theavocoder">Instagram</a> || <a href="https://www.twitter.com/lydiahallie">Twitter</a> || <a href="https://www.linkedin.com/in/lydia-hallie">LinkedIn</a> || <a href="https://www.lydiahallie.dev">Blog</a>

</div>

| Simte-te liber sÄƒ le foloseÈ™ti Ã®ntr-un proiect! ğŸ˜ƒ AÈ™ aprecia _cu adevÄƒrat_ o referinÈ›Äƒ la acest depozit, eu creez Ã®ntrebÄƒrile È™i explicaÈ›iile (da, sunt tristÄƒ lol) È™i comunitatea mÄƒ ajutÄƒ foarte mult sÄƒ Ã®l menÈ›in È™i sÄƒ Ã®l Ã®mbunÄƒtÄƒÈ›esc! ğŸ’ªğŸ¼ MulÈ›umesc È™i distracÈ›ie plÄƒcutÄƒ! |
| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |

---

<details><summary><b> Vezi 20 de traduceri disponibile ğŸ‡¸ğŸ‡¦ğŸ‡ªğŸ‡¬ğŸ‡§ğŸ‡¦ğŸ‡©ğŸ‡ªğŸ‡ªğŸ‡¸ğŸ‡«ğŸ‡·ğŸ‡®ğŸ‡©ğŸ‡¯ğŸ‡µğŸ‡°ğŸ‡·ğŸ‡³ğŸ‡±ğŸ‡§ğŸ‡·ğŸ‡·ğŸ‡ºğŸ‡¹ğŸ‡­ğŸ‡¹ğŸ‡·ğŸ‡ºğŸ‡¦ğŸ‡»ğŸ‡³ğŸ‡¨ğŸ‡³ğŸ‡¹ğŸ‡¼ğŸ‡½ğŸ‡°</b></summary>
<p>

- [ğŸ‡¸ğŸ‡¦ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©](./ar-AR/README_AR.md)
- [ğŸ‡ªğŸ‡¬ Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¹Ø§Ù…ÙŠØ©](./ar-EG/README_ar-EG.md)
- [ğŸ‡§ğŸ‡¦ Bosanski](./bs-BS/README-bs_BS.md)
- [ğŸ‡©ğŸ‡ª Deutsch](./de-DE/README.md)
- [ğŸ‡ªğŸ‡¸ EspaÃ±ol](./es-ES/README-ES.md)
- [ğŸ‡«ğŸ‡· FranÃ§ais](./fr-FR/README_fr-FR.md)
- [ğŸ‡®ğŸ‡© Indonesia](./id-ID/README.md)
- [ğŸ‡®ğŸ‡¹ Italiano](./it-IT/README.md)
- [ğŸ‡¯ğŸ‡µ æ—¥æœ¬èª](./ja-JA/README-ja_JA.md)
- [ğŸ‡°ğŸ‡· í•œêµ­ì–´](./ko-KR/README-ko_KR.md)
- [ğŸ‡³ğŸ‡± Nederlands](./nl-NL/README.md)
- [ğŸ‡µğŸ‡± Polski](./pl-PL/README.md)
- [ğŸ‡§ğŸ‡· PortuguÃªs Brasil](./pt-BR/README_pt_BR.md)
- [ğŸ‡·ğŸ‡º Ğ ÑƒÑÑĞºĞ¸Ğ¹](./ru-RU/README.md)
- [ğŸ‡½ğŸ‡° Shqip](./sq-KS/README_sq_KS.md)
- [ğŸ‡¹ğŸ‡­ à¹„à¸—à¸¢](./th-TH/README-th_TH.md)
- [ğŸ‡¹ğŸ‡· TÃ¼rkÃ§e](./tr-TR/README-tr_TR.md)
- [ğŸ‡ºğŸ‡¦ Ğ£ĞºÑ€Ğ°Ñ—Ğ½ÑÑŒĞºĞ° Ğ¼Ğ¾Ğ²Ğ°](./uk-UA/README.md)
- [ğŸ‡»ğŸ‡³ Tiáº¿ng Viá»‡t](./vi-VI/README-vi.md)
- [ğŸ‡¨ğŸ‡³ ç®€ä½“ä¸­æ–‡](./zh-CN/README-zh_CN.md)
- [ğŸ‡¹ğŸ‡¼ ç¹é«”ä¸­æ–‡](./zh-TW/README_zh-TW.md)

</p>
</details>

---

###### 1. Care este rezultatul?

```javascript
function sayHi() {
  console.log(name);
  console.log(age);
  var name = "Lydia";
  let age = 21;
}

sayHi();
```

- A: `Lydia` È™i `undefined`
- B: `Lydia` È™i `ReferenceError`
- C: `ReferenceError` È™i `21`
- D: `undefined` È™i `ReferenceError`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: D

Ãn interiorul funcÈ›iei, mai Ã®ntÃ¢i declarÄƒm variabila `name` cu cuvÃ¢ntul cheie `var`. Acest lucru Ã®nseamnÄƒ cÄƒ variabila este hoisted (spaÈ›iul de memorie este configurat Ã®n faza de creare) cu valoarea implicitÄƒ `undefined`, pÃ¢nÄƒ cÃ¢nd ajungem efectiv la linia Ã®n care definim variabila. Nu am definit Ã®ncÄƒ variabila pe linia Ã®n care Ã®ncercÄƒm sÄƒ Ã®nregistrÄƒm variabila `name`, aÈ™a cÄƒ aceasta pÄƒstreazÄƒ Ã®ncÄƒ valoarea `undefined`.

Variabilele create cu cuvÃ¢ntul cheie `let` (È™i `const`) sunt hoisted, dar, spre deosebire de `var`, nu sunt <i>iniÈ›ializate</i>. Acestea nu sunt accesibile Ã®nainte de linia Ã®n care le declarÄƒm (initializÄƒm). Aceasta se numeÈ™te zona moartÄƒ temporalÄƒ (temporal dead zone). Atunci cÃ¢nd Ã®ncercÄƒm sÄƒ accesÄƒm variabilele Ã®nainte de a fi declarate, JavaScript aruncÄƒ o excepÈ›ie de tip `ReferenceError`.

</p>
</details>

---

###### 2. Care este rezultatul?

```javascript
for (var i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 1);
}

for (let i = 0; i < 3; i++) {
  setTimeout(() => console.log(i), 1);
}
```

- A: `0 1 2` È™i `0 1 2`
- B: `0 1 2` È™i `3 3 3`
- C: `3 3 3` È™i `0 1 2`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: C

DatoritÄƒ cozii de evenimente din JavaScript, funcÈ›ia de callback `setTimeout` este apelatÄƒ _dupÄƒ_ ce bucla a fost executatÄƒ. Deoarece variabila `i` din prima buclÄƒ a fost declaratÄƒ folosind cuvÃ¢ntul cheie `var`, aceastÄƒ valoare a fost globalÄƒ. Ãn timpul buclei, am incrementat valoarea lui `i` cu `1` de fiecare datÄƒ, folosind operatorul unary `++`. PÃ¢nÄƒ cÃ¢nd funcÈ›ia de callback `setTimeout` a fost invocatÄƒ, `i` era egal cu `3` Ã®n primul exemplu.

Ãn cea de-a doua buclÄƒ, variabila `i` a fost declaratÄƒ folosind cuvÃ¢ntul cheie `let`: variabilele declarate cu cuvÃ¢ntul cheie `let` (È™i `const`) sunt cu scop la nivel de bloc (un bloc este orice Ã®ntre `{ }`). Ãn fiecare iteraÈ›ie, `i` va avea o valoare nouÄƒ, iar fiecare valoare este Ã®n cadrul buclei.

</p>
</details>

---

###### 3. Care este rezultatul?

```javascript
const shape = {
  radius: 10,
  diameter() {
    return this.radius * 2;
  },
  perimeter: () => 2 * Math.PI * this.radius,
};

console.log(shape.diameter());
console.log(shape.perimeter());
```

- A: `20` È™i `62.83185307179586`
- B: `20` È™i `NaN`
- C: `20` È™i `63`
- D: `NaN` È™i `63`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: B

ReÈ›ineÈ›i cÄƒ valoarea lui `diameter` este o funcÈ›ie obiÈ™nuitÄƒ, Ã®n timp ce valoarea lui `perimeter` este o funcÈ›ie arrow.

Cu funcÈ›iile arrow, cuvÃ¢ntul cheie `this` se referÄƒ la contextul sÄƒu curent de Ã®ncadrare, spre deosebire de funcÈ›iile obiÈ™nuite! Acest lucru Ã®nseamnÄƒ cÄƒ atunci cÃ¢nd apelÄƒm `perimeter`, acesta nu se referÄƒ la obiectul formei, ci la Ã®ncadrarea sa curentÄƒ (de exemplu, fereastra).

Nu existÄƒ nicio valoare `radius` pe acel obiect, ceea ce returneazÄƒ `NaN`.

</p>
</details>

---

###### 4. Care este rezultatul?

```javascript
+true;
!"Lydia";
```

- A: `1` È™i `false`
- B: `false` È™i `NaN`
- C: `false` È™i `false`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: A

Operatorul unary plus Ã®ncearcÄƒ sÄƒ converteascÄƒ un operand Ã®ntr-un numÄƒr. `true` este `1`, È™i `false` este `0`.

È˜irul de caractere `'Lydia'` este o valoare adevÄƒratÄƒ. Ceea ce Ã®ntrebÄƒm de fapt, este "este aceastÄƒ valoare adevÄƒratÄƒ falsÄƒ?". Acest lucru returneazÄƒ `false`.

</p>
</details>

---

###### 5. Care este rezultatul?

```javascript
const bird = {
  size: "small",
};

const mouse = {
  name: "Mickey",
  small: true,
};
```

- A: `mouse.bird.size` nu este valid
- B: `mouse[bird.size]` nu este valid
- C: `mouse[bird["size"]]` nu este valid
- D: Toate sunt valide

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: A

Ãn JavaScript, toate cheile obiectelor sunt È™iruri de caractere (cu excepÈ›ia simbolurilor). Chiar dacÄƒ nu le _tipizÄƒm_ ca È™iruri de caractere, ele sunt Ã®ntotdeauna convertite Ã®n È™iruri de caractere Ã®n fundal.

avaScript interpreteazÄƒ (sau dezambaleazÄƒ) instrucÈ›iunile. Atunci cÃ¢nd folosim notaÈ›ia cu paranteze pÄƒtrate, vede prima parantezÄƒ pÄƒtratÄƒ de deschidere `[` È™i continuÄƒ pÃ¢nÄƒ cÃ¢nd gÄƒseÈ™te paranteza pÄƒtratÄƒ de Ã®nchidere `]`. Doar atunci va evalua instrucÈ›iunea.

`mouse[bird.size]`: ÃntÃ¢i evalueazÄƒ `bird.size`, care este `"small"`. `mouse["small"]` returneazÄƒ `true`

Cu toate acestea, cu notaÈ›ia cu punct, acest lucru nu se Ã®ntÃ¢mplÄƒ. `mouse` nu are o cheie numitÄƒ `bird`, ceea ce Ã®nseamnÄƒ cÄƒ `mouse.bird` este `undefined`. Apoi, cerem `size` folosind notaÈ›ia cu punct: `mouse.bird.size`. Deoarece `mouse.bird` este `undefined`, de fapt cerem `undefined.size`. Acest lucru nu este valid È™i va arunca o eroare similarÄƒ cu `Cannot read property "size" of undefined` (Nu se poate citi proprietatea "size" a unei valori nedefinite).

</p>
</details>

---

###### 6. Care este rezultatul?

```javascript
let c = { greeting: "Hey!" };
let d;

d = c;
c.greeting = "Hello";
console.log(d.greeting);
```

- A: `Hello`
- B: `Hey!`
- C: `undefined`
- D: `ReferenceError`
- E: `TypeError`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: A

Ãn JavaScript, toate obiectele interacÈ›ioneazÄƒ prin _referinÈ›Äƒ_ atunci cÃ¢nd sunt setate ca egale Ã®ntre ele.

Mai Ã®ntÃ¢i, variabila `c` deÈ›ine o valoare care face referire la un obiect. Ulterior, atribuim variabilei `d` aceeaÈ™i referinÈ›Äƒ pe care o are `c` la obiect.

<img src="https://i.imgur.com/ko5k0fs.png" width="200">

CÃ¢nd modifici un obiect, le modifici pe toate.

</p>
</details>

---

###### 7. Care este rezultatul?

```javascript
let a = 3;
let b = new Number(3);
let c = 3;

console.log(a == b);
console.log(a === b);
console.log(b === c);
```

- A: `true` `false` `true`
- B: `false` `false` `true`
- C: `true` `false` `false`
- D: `false` `true` `true`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: C

`new Number()` este un constructor de funcÈ›ii Ã®ncorporat. DeÈ™i aratÄƒ ca un numÄƒr, nu este Ã®ntr-adevÄƒr un numÄƒr: are o mulÈ›ime de funcÈ›ionalitÄƒÈ›i suplimentare È™i este un obiect.

Atunci cÃ¢nd folosim operatorul `==` (operatorul de egalitate), acesta verificÄƒ doar dacÄƒ au aceeaÈ™i _valuare_. Ambele au valoarea `3`, È™a cÄƒ returneazÄƒ `true`.

Cu toate acestea, atunci cÃ¢nd folosim operatorul `===` (operatorul de egalitate strictÄƒ), atÃ¢t valoarea, cÃ¢t _È™i_ tipul trebuie sÄƒ fie la fel. Nu sunt: `new Number()` nu este un numÄƒr, este un **object**. Ambele returneazÄƒ `false.`

</p>
</details>

---

###### 8. Care este rezultatul?

```javascript
class Chameleon {
  static colorChange(newColor) {
    this.newColor = newColor;
    return this.newColor;
  }

  constructor({ newColor = "green" } = {}) {
    this.newColor = newColor;
  }
}

const freddie = new Chameleon({ newColor: "purple" });
console.log(freddie.colorChange("orange"));
```

- A: `orange`
- B: `purple`
- C: `green`
- D: `TypeError`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: D

FuncÈ›ia `colorChange` este staticÄƒ. Metodele statice sunt concepute sÄƒ existe doar pe constructorul Ã®n care sunt create È™i nu pot fi transmise cÄƒtre niciun copil sau apelate pe instanÈ›ele clasei. Deoarece `freddie` este o instanÈ›Äƒ a clasei Chameleon, funcÈ›ia nu poate fi apelatÄƒ pe aceasta. Se aruncÄƒ o eroare de tip `TypeError`.

</p>
</details>

---

###### 9. Care este rezultatul?

```javascript
let greeting;
greetign = {}; // Typo!
console.log(greetign);
```

- A: `{}`
- B: `ReferenceError: greetign is not defined`
- C: `undefined`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: A

Se afiÈ™eazÄƒ obiectul, deoarece tocmai am creat un obiect gol pe obiectul global! Atunci cÃ¢nd am greÈ™it È™i am scris `greeting` Ã®n loc de `greetign`, interpretorul JavaScript a vÄƒzut efectiv acest lucru ca:

1. `global.greetign = {}` Ã®n Node.js
2. `window.greetign = {}`, `frames.greetign = {}` È™i `self.greetign` Ã®n browser-e.
3. `self.greetign` Ã®n web workers.
4. `globalThis.greetign` Ã®n toate mediile.

Pentru a evita acest lucru, putem folosi `"use strict"`. Acest lucru se asigurÄƒ cÄƒ ai declarat o variabilÄƒ Ã®nainte de a-i atribui o valoare.

</p>
</details>

---

###### 10. Ce se Ã®ntÃ¢mplÄƒ cÃ¢nd facem asta?

```javascript
function bark() {
  console.log("Woof!");
}

bark.animal = "dog";
```

- A: Nimic, este absolut Ã®n regulÄƒ!
- B: `SyntaxError`. Nu poÈ›i adÄƒuga proprietÄƒÈ›i la o funcÈ›ie Ã®n acest fel.
- C: `"Woof"` este Ã®nregistrat.
- D: `ReferenceError`

<details><summary><b>RÄƒspuns</b></summary>
<p>

#### RÄƒspuns: A

Acest lucru este posibil Ã®n JavaScript, deoarece funcÈ›iile sunt obiecte! (Totul, Ã®n afarÄƒ de tipurile primitive, sunt obiecte)

O funcÈ›ie este un tip special de obiect. Codul pe care Ã®l scrii tu Ã®nsuÈ›i nu este funcÈ›ia efectivÄƒ. FuncÈ›ia este un obiect cu proprietÄƒÈ›i. AceastÄƒ proprietate este invocabilÄƒ.

</p>
</details>

---
